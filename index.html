<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UC4 SysEx Editor</title>
    <style>
        /* System fonts - no external dependencies for offline support */
        
        :root {
            --font-mono: ui-monospace, 'SF Mono', 'Cascadia Code', 'Roboto Mono', Menlo, Consolas, monospace;
            --font-display: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            --bg-dark: #0a0a0c;
            --bg-panel: #111114;
            --bg-control: #18181c;
            --bg-input: #1e1e24;
            --border: #2a2a32;
            --border-light: #3a3a44;
            --text: #e0e0e8;
            --text-dim: #888898;
            --text-muted: #555560;
            --accent: #00d4aa;
            --accent-dim: #00a888;
            --warning: #ffaa00;
            --error: #ff4466;
            --encoder: #00aaff;
            --push: #aa66ff;
            --green-btn: #44dd66;
            --fader: #ff8844;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--font-mono);
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.4;
        }
        
        /* Header */
        .header {
            background: linear-gradient(180deg, var(--bg-panel) 0%, var(--bg-dark) 100%);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .logo {
            font-family: var(--font-display);
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        .logo span {
            color: var(--text-dim);
            font-weight: 400;
        }
        
        .file-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .btn {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: var(--accent);
            color: var(--bg-dark);
            border-color: var(--accent);
            font-weight: 600;
        }
        
        .btn-primary:hover {
            background: var(--accent-dim);
            border-color: var(--accent-dim);
            color: var(--bg-dark);
        }
        
        .btn-divider {
            display: inline-block;
            width: 1px;
            height: 1.5rem;
            background: var(--border);
            margin: 0 0.5rem;
            vertical-align: middle;
        }
        
        .help-link {
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            background: transparent;
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .help-link:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 60;  /* Per z-index scale */
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .toast {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text);
            font-size: 0.9rem;
            max-width: 400px;
            animation: slideIn 0.3s ease-out;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .toast.error {
            border-color: var(--error);
            background: rgba(255, 68, 102, 0.1);
        }
        
        .toast.success {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .toast.warning {
            border-color: var(--warning);
            color: var(--warning);
        }
        
        .toast.info {
            border-color: var(--border-light);
            color: var(--text);
        }
        
        .toast-message {
            flex: 1;
        }
        
        .toast-copy-btn,
        .toast-close-btn {
            background: transparent;
            border: 1px solid currentColor;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.85em;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            color: inherit;
            font-family: inherit;
        }
        
        .toast-copy-btn:hover,
        .toast-close-btn:hover {
            opacity: 1;
        }
        
        .toast-close-btn {
            border: none;
            font-size: 1em;
        }
        
        .toast-copy-btn:focus-visible,
        .toast-close-btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Restore Dialog */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .modal-dialog {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
        }
        
        .modal-dialog h3 {
            font-family: var(--font-display);
            color: var(--accent);
            margin-bottom: 1rem;
        }
        
        .modal-dialog p {
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }
        
        .modal-dialog .info {
            background: var(--bg-input);
            padding: 0.75rem;
            margin: 1rem 0;
            font-size: 0.8rem;
        }
        
        .modal-dialog label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-dim);
            margin: 1rem 0;
            cursor: pointer;
        }
        
        .modal-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        
        /* Filename Prompt Dialog */
        .filename-dialog {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 1.5rem;
            min-width: 350px;
            max-width: 500px;
        }
        
        #filenameModal {
            z-index: 10002;
        }
        
        .filename-dialog h3 {
            font-family: var(--font-display);
            color: var(--accent);
            margin-bottom: 1rem;
            font-size: 1rem;
        }
        
        .filename-input-row {
            display: flex;
            align-items: center;
            gap: 0;
            background: var(--bg-input);
            border: 1px solid var(--border);
        }
        
        .filename-input-row input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            padding: 0.6rem 0.75rem;
            outline: none;
        }
        
        .filename-input-row input:focus {
            background: rgba(0, 200, 255, 0.05);
        }
        
        .filename-ext {
            color: var(--text-dim);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            padding-right: 0.75rem;
        }
        
        .filename-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 1rem;
        }
        
        /* Group Name Editor Modal */
        .group-name-dialog input {
            font-family: var(--font-mono);
            font-size: 1.5rem;
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            text-align: center;
            margin: 1rem 0;
        }
        
        .group-name-dialog input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .group-name-dialog .preview {
            font-size: 0.85rem;
            color: var(--text-dim);
            text-align: center;
            margin-bottom: 0.5rem;
        }
        
        .group-name-dialog .preview span {
            font-family: var(--font-mono);
            color: var(--accent);
            letter-spacing: 0.15em;
        }
        
        .group-name-dialog .hint {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            line-height: 1.6;
        }
        
        .group-name-dialog .error {
            color: var(--error);
            font-size: 0.8rem;
            text-align: center;
            min-height: 1.2em;
        }
        
        .group-name-dialog .warning {
            background: rgba(255, 170, 0, 0.15);
            border: 1px solid var(--warning);
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            color: var(--warning);
            margin-bottom: 1rem;
        }
        
        /* Editable group name styling */
        .group-name {
            cursor: pointer;
            padding: 0 0.25rem;
            border-radius: 2px;
            transition: background 0.15s;
        }
        
        .group-name:hover {
            background: var(--bg-control);
            color: var(--accent);
        }
        
        .group-name.has-warning {
            color: var(--warning);
        }
        
        .group-name-row td {
            cursor: pointer;
        }
        
        .group-name-row td:hover {
            background: var(--bg-control);
            color: var(--accent);
        }
        
        /* Overview Mode */
        .overview-container {
            padding: 1rem;
        }
        
        .overview-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .overview-tab {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .overview-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .overview-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .overview-grid {
            overflow-x: auto;
        }
        
        .overview-section {
            margin-bottom: 2rem;
        }
        
        .overview-section-title {
            font-family: var(--font-display);
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 0 0 0.75rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .overview-section-title.encoders { color: var(--encoder); border-color: var(--encoder); }
        .overview-section-title.push { color: var(--push); border-color: var(--push); }
        .overview-section-title.green { color: var(--green-btn); border-color: var(--green-btn); }
        .overview-section-title.faders { color: var(--fader); border-color: var(--fader); }
        .overview-section-title.fader9 { color: var(--fader); border-color: var(--fader); }
        
        .overview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        
        .overview-table th,
        .overview-table td {
            border: 1px solid var(--border);
            padding: 0.4rem 0.5rem;
            text-align: center;
            min-width: 80px;
        }
        
        .overview-table th {
            background: var(--bg-panel);
            color: var(--text-dim);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .overview-table th.group-header {
            color: var(--accent);
        }
        
        .overview-table th.row-header {
            text-align: left;
            width: 70px;
            min-width: 70px;
        }
        
        .overview-table td {
            background: var(--bg-input);
            cursor: pointer;
            transition: background 0.1s;
        }
        
        .overview-table td:hover {
            background: var(--bg-control);
        }
        
        .overview-table td.conflict {
            background: rgba(255, 170, 0, 0.2);
        }
        
        .overview-table td.conflict-dim {
            background: rgba(255, 170, 0, 0.1);
        }
        
        .overview-table td.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
            background: rgba(0, 255, 170, 0.15);
        }
        
        .overview-table td.qp-source {
            outline: 2px solid var(--warning);
            outline-offset: -2px;
            background: rgba(255, 170, 0, 0.15);
        }
        
        .overview-table td.selected.conflict {
            background: rgba(255, 170, 0, 0.3);
        }
        
        .overview-table td.selected.conflict-dim {
            background: rgba(255, 170, 0, 0.2);
        }
        
        .overview-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        
        .overview-cell .conflict-icon {
            color: var(--warning);
            font-size: 0.65rem;
        }
        
        .group-name-row td {
            font-family: var(--font-display);
            font-size: 0.65rem;
            color: var(--text-muted);
            background: var(--bg-panel) !important;
            padding: 0.2rem 0.5rem;
        }
        
        /* Conflict Filter Chips */
        .conflict-filters {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
        }
        
        .conflict-filters-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 0.5rem;
        }
        
        .filter-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.15s;
            user-select: none;
        }
        
        .filter-chip:hover {
            border-color: var(--accent);
        }
        
        .filter-chip.active {
            background: var(--warning);
            border-color: var(--warning);
            color: var(--bg-dark);
        }
        
        .filter-chip.active.dim {
            background: rgba(255, 170, 0, 0.3);
            border-color: var(--warning);
            color: var(--warning);
        }
        
        .filter-chip .count {
            font-weight: 600;
        }
        
        .filter-chip .checkmark {
            font-size: 0.8rem;
        }
        
        /* Conflict Panel */
        .conflict-panel {
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .conflict-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .conflict-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
        }
        
        .conflict-item:last-child {
            border-bottom: none;
        }
        
        .conflict-item .warning-icon {
            color: var(--warning);
            flex-shrink: 0;
        }
        
        .conflict-item.dim .warning-icon {
            opacity: 0.5;
        }
        
        .conflict-key {
            color: var(--accent);
            font-weight: 600;
            margin-right: 0.5rem;
        }
        
        .conflict-refs {
            color: var(--text-dim);
        }
        
        /* Context Menu */
        .context-menu {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            min-width: 200px;
            z-index: 1000;
            padding: 0.25rem 0;
        }
        
        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text);
        }
        
        .context-menu-item:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        .context-menu-item.disabled {
            color: var(--text-muted);
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: none;
            color: var(--text-muted);
        }
        
        .context-menu-separator {
            height: 1px;
            background: var(--border);
            margin: 0.25rem 0;
        }
        
        /* Quick Paste Toolbar */
        .quick-paste-toolbar {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.75rem;
        }
        
        .quick-paste-toolbar.collapsed {
            padding: 0.4rem 0.75rem;
        }
        
        .quick-paste-toolbar.collapsed .qp-expanded-content {
            display: none;
        }
        
        .qp-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .qp-label {
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.65rem;
        }
        
        .qp-mode-buttons {
            display: flex;
            gap: 2px;
        }
        
        .qp-mode-btn {
            font-family: inherit;
            font-size: 0.7rem;
            padding: 0.3rem 0.6rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
        }
        
        .qp-mode-btn:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .qp-mode-btn.active {
            font-weight: 600;
        }
        
        .qp-mode-btn.active[data-mode="off"] {
            background: var(--bg-input);
            border-color: var(--border-light);
            color: var(--text);
        }
        
        .qp-mode-btn.active[data-mode="copy"] {
            background: var(--encoder);
            border-color: var(--encoder);
            color: var(--bg-dark);
        }
        
        .qp-mode-btn.active[data-mode="paste"] {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
        }
        
        .qp-scope-btns {
            display: flex;
            gap: 2px;
        }
        
        .qp-scope-btn {
            font-family: inherit;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .qp-scope-btn:hover {
            border-color: var(--accent);
        }
        
        .qp-scope-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .qp-scope-btn.locked {
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .qp-scope-btn.locked.active {
            opacity: 1;
        }
        
        .qp-source-display {
            color: var(--text);
            padding: 0.25rem 0.5rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            min-width: 120px;
        }
        
        .qp-source-display.has-source {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .qp-source-display .lock-icon {
            margin-left: 0.25rem;
            font-size: 0.65rem;
        }
        
        .qp-ch-section {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .qp-ch-section select {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            min-width: 60px;
        }
        
        .qp-status {
            color: var(--text-muted);
            font-style: italic;
            margin-left: auto;
        }
        
        .qp-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .qp-action-btn {
            font-family: inherit;
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
        }
        
        .qp-action-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        /* Overview table mode styles */
        .overview-table.qp-copy-mode td {
            cursor: crosshair;
        }
        
        .overview-table.qp-paste-mode td {
            cursor: cell;
        }
        
        .overview-table.qp-paste-mode td.qp-incompatible {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        /* Cell/Column/Row hover highlighting */
        .overview-table td.qp-cell-hover,
        .overview-table td.qp-column-hover,
        .overview-table td.qp-row-hover {
            outline: 2px dashed var(--accent);
            outline-offset: -2px;
            background: rgba(0, 212, 170, 0.1);
        }
        
        /* Just pasted flash animation */
        @keyframes qpFlash {
            0% { background: var(--accent); }
            100% { background: var(--bg-input); }
        }
        
        .overview-table td.just-pasted {
            animation: qpFlash 0.4s ease-out;
        }
        
        /* Paste Special Dialog */
        .paste-special-dialog {
            max-width: 400px;
        }
        
        .paste-source {
            color: var(--accent);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }
        
        .paste-section {
            margin-bottom: 1rem;
        }
        
        .paste-section-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        
        .paste-targets label {
            display: block;
            padding: 0.25rem 0;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .paste-targets input[type="radio"] {
            margin-right: 0.5rem;
        }
        
        .paste-transforms {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .transform-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        
        .transform-row label {
            min-width: 140px;
        }
        
        .transform-row input[type="number"] {
            width: 80px;
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        
        .transform-row select {
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        
        /* Navigation */
        .nav-bar {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 2rem;
            flex-wrap: wrap;
        }
        
        .nav-section {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .nav-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .library-source-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--accent);
            border-radius: 3px;
            font-size: 0.75rem;
            color: var(--accent);
            white-space: nowrap;
        }
        
        .library-source-badge::before {
            content: 'ðŸ”¦';
            font-size: 0.8rem;
        }
        
        .link-groups-toggle {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: pointer;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            transition: all 0.15s;
        }
        
        .link-groups-toggle:hover {
            border-color: var(--accent);
        }
        
        .link-groups-toggle input[type="checkbox"] {
            display: none;
        }
        
        .link-groups-toggle .link-icon {
            font-size: 0.9rem;
            opacity: 0.5;
            transition: opacity 0.15s;
        }
        
        .link-groups-toggle input:checked ~ .link-icon {
            opacity: 1;
        }
        
        .link-groups-toggle input:checked ~ .nav-label {
            color: var(--accent);
        }
        
        .select-wrapper {
            position: relative;
        }
        
        select {
            font-family: inherit;
            font-size: 0.8rem;
            padding: 0.4rem 2rem 0.4rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
            cursor: pointer;
            appearance: none;
            min-width: 100px;
        }
        
        select:hover, select:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .select-wrapper::after {
            content: 'â–¾';
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-dim);
            pointer-events: none;
            font-size: 0.7rem;
        }
        
        .group-tabs {
            display: flex;
            gap: 2px;
        }
        
        .group-tab {
            font-family: inherit;
            font-size: 0.75rem;
            width: 2rem;
            height: 2rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .group-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .group-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .group-name-display {
            font-family: var(--font-display);
            font-size: 0.9rem;
            color: var(--accent);
            padding: 0.4rem 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            min-width: 4rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.15s, background 0.15s;
        }
        
        .group-name-display:hover {
            border-color: var(--accent);
            background: var(--bg-control);
        }
        
        /* Main Content */
        .main-content {
            padding: 1.5rem;
            padding-bottom: 32px;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .no-data {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }
        
        .no-data h2 {
            font-family: var(--font-display);
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }
        
        .no-data p {
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }
        
        /* Control Sections */
        .control-section {
            margin-bottom: 2rem;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .section-title {
            font-family: var(--font-display);
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .section-title::after {
            content: 'â”‚';
            margin-left: 0.75rem;
            color: var(--border);
            font-weight: 300;
        }
        
        .section-title.encoders { color: var(--encoder); }
        .section-title.push { color: var(--push); }
        .section-title.green { color: var(--green-btn); }
        .section-title.faders { color: var(--fader); }
        .section-title.fader9 { color: var(--fader); }
        
        .section-badge {
            font-family: var(--font-display);
            font-size: 0.85rem;
            font-weight: 600;
            padding: 0.2rem 0.6rem;
            background: transparent;
            color: var(--accent);
            letter-spacing: 0.05em;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.15s;
        }
        
        .section-badge:hover {
            background: var(--bg-control);
        }
        
        /* Focused View Inline Group Selectors */
        .focused-section-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .focused-section-header .section-title {
            flex-shrink: 0;
        }
        
        .focused-inline-group-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .focused-inline-group-selector .group-name-badge {
            font-family: var(--font-display);
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            background: var(--bg-control);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: border-color 0.1s, filter 0.1s;
            letter-spacing: 0.05em;
        }
        
        .focused-inline-group-selector .group-name-badge:hover {
            border-color: var(--accent);
            filter: brightness(1.1);
        }
        
        /* Color-code badge by section type */
        .focused-inline-group-selector.encoder-domain .group-name-badge {
            color: var(--encoder);
        }
        
        .focused-inline-group-selector.fader-domain .group-name-badge {
            color: var(--fader);
        }
        
        .focused-inline-group-selector .selector-tabs {
            display: flex;
            gap: 1px;
        }
        
        .focused-inline-group-selector .selector-tab {
            font-family: inherit;
            font-size: 0.65rem;
            width: 1.5rem;
            height: 1.5rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: border-color 0.1s, color 0.1s, background-color 0.1s;
            padding: 0;
        }
        
        .focused-inline-group-selector .selector-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .focused-inline-group-selector .selector-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        /* Mobile: larger touch targets */
        @media (max-width: 768px) {
            .focused-inline-group-selector .selector-tab {
                width: 2rem;
                height: 2rem;
                font-size: 0.75rem;
            }
        }
        
        /* Control Grid */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            overflow: hidden;
        }
        
        .control-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 0.75rem;
            transition: border-color 0.15s;
            overflow: hidden;
            min-width: 0;
        }
        
        .control-card:hover {
            border-color: var(--border-light);
        }
        
        .control-card.encoder { border-left: 3px solid var(--encoder); }
        .control-card.push { border-left: 3px solid var(--push); }
        .control-card.green { border-left: 3px solid var(--green-btn); }
        .control-card.fader { border-left: 3px solid var(--fader); }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .control-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
        }
        
        .control-index {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.4rem;
            gap: 0.5rem;
            min-width: 0;
        }
        
        .param-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            width: 3.5rem;
            flex-shrink: 0;
            text-transform: uppercase;
        }
        
        .param-input {
            flex: 1;
            min-width: 0;
        }
        
        .param-input input,
        .param-input select {
            width: 100%;
            min-width: 0;
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
            box-sizing: border-box;
            text-overflow: ellipsis;
        }
        
        .param-input input:focus,
        .param-input select:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .param-input input[type="number"] {
            -moz-appearance: textfield;
        }
        
        .param-input input::-webkit-outer-spin-button,
        .param-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Fader 9 Special */
        .fader9-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-left: 3px solid var(--fader);
            padding: 0.75rem;
            margin-top: 1rem;
        }
        
        .fader9-card .control-header {
            background: linear-gradient(90deg, rgba(255,136,68,0.1) 0%, transparent 100%);
            margin: -0.75rem -0.75rem 0.75rem -0.75rem;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        
        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 0.5rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem;
            color: var(--text-dim);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        
        .status-dot.loaded {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }
        
        .status-dot.modified {
            background: var(--warning);
            box-shadow: 0 0 8px var(--warning);
        }
        
        /* Warnings */
        .warning-badge {
            font-size: 0.6rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid var(--warning);
            color: var(--warning);
            margin-left: 0.5rem;
        }
        
        /* Hidden file input */
        .hidden-input {
            display: none;
        }
        
        /* View Toggle */
        .view-toggle {
            display: inline-flex;
            gap: 0;
            border-radius: 0;
        }
        
        .view-btn {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--accent);
            margin-left: -1px;
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.15s;
        }
        
        .view-btn:first-child {
            margin-left: 0;
        }
        
        .view-btn:hover {
            background: var(--bg-input);
            color: var(--accent);
        }
        
        .view-btn.active {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .nav-bar {
                flex-direction: column;
                gap: 1rem;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }
        
        /* Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading {
            animation: pulse 1s infinite;
        }
        
        /* ============================================================
           Tooltip System
           ============================================================ */
        
        .tooltip {
            position: fixed;
            min-width: 240px;
            max-width: 320px;
            padding: 0.75rem;
            background: var(--bg-panel);
            border: 1px solid var(--accent);
            color: var(--text);
            font-size: 0.75rem;
            line-height: 1.5;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s ease-out;
            pointer-events: none;
        }
        
        .tooltip.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .tooltip-content {
            position: relative;
            z-index: 1;
        }
        
        .tooltip-arrow {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--bg-panel);
            border: 1px solid var(--accent);
            transform: rotate(45deg);
        }
        
        .tooltip.above .tooltip-arrow {
            bottom: -7px;
            border-top: none;
            border-left: none;
        }
        
        .tooltip.below .tooltip-arrow {
            top: -7px;
            border-bottom: none;
            border-right: none;
        }
        
        .has-tooltip {
            border-bottom: 1px dotted var(--text-dim);
            cursor: help;
        }
        
        /* Clickable labels that open option panels */
        .has-options {
            color: var(--accent);
            cursor: pointer;
            border-bottom: 1px solid var(--accent-dim);
            transition: color 0.15s;
        }
        
        .has-options:hover {
            color: var(--text);
            border-bottom-color: var(--accent);
        }
        
        @media (prefers-reduced-motion: reduce) {
            .tooltip {
                transition: none;
            }
        }
        
        /* Info Panel */
        .info-panel {
            position: fixed;
            min-width: 280px;
            max-width: 400px;
            max-height: 80vh;
            background: var(--bg-panel);
            border: 1px solid var(--accent);
            z-index: 10001;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .info-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg-control);
        }
        
        .info-panel-title {
            font-family: var(--font-display);
            font-size: 0.8rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .info-panel-close {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
            padding: 0;
            border: 1px solid var(--accent);
            border-radius: 4px;
            background: rgba(0, 212, 170, 0.1);
            color: var(--accent);
            cursor: pointer;
            font-size: 1.3rem;
            font-weight: bold;
            line-height: 1;
            transition: all 0.15s;
        }
        
        .info-panel-close:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        .info-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        
        .info-panel-option {
            display: flex;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            transition: background 0.1s;
        }
        
        .info-panel-option:hover {
            background: var(--bg-control);
        }
        
        .info-panel-option.focused {
            background: var(--bg-input);
            outline: 1px solid var(--accent-dim);
            outline-offset: -1px;
        }
        
        .info-panel-marker {
            width: 20px;
            flex-shrink: 0;
            color: var(--accent);
            font-size: 0.75rem;
        }
        
        .info-panel-option-content {
            flex: 1;
            min-width: 0;
        }
        
        .info-panel-option-name {
            font-weight: 600;
            color: var(--text);
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }
        
        .info-panel-option-desc {
            color: var(--text-dim);
            font-size: 0.7rem;
            line-height: 1.4;
        }
        
        /* Touch dismiss overlay */
        .touch-dismiss-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            background: transparent;
        }
        
        /* ============================================================
           Setup Manager Modal
           ============================================================ */
        
        .setup-manager-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.15s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .setup-manager-modal {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.2s ease-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .setup-manager-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg-control);
        }
        
        .setup-manager-title {
            font-family: var(--font-display);
            font-size: 1rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .setup-manager-close {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            padding: 0;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1.5rem;
            line-height: 1;
            transition: all 0.15s;
        }
        
        .setup-manager-close:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .setup-manager-body {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .setup-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.75rem;
        }
        
        @media (max-width: 768px) {
            .setup-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        .setup-card {
            background: var(--bg-control);
            border: 2px solid var(--border);
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
            user-select: none;
            position: relative;
        }
        
        .setup-card:hover {
            border-color: var(--border-light);
        }
        
        .setup-card.selected {
            border-color: var(--accent);
            background: rgba(0, 212, 170, 0.1);
        }
        
        .setup-card-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .setup-card-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
        
        .setup-card-label:hover {
            color: var(--text);
        }
        
        .setup-card-label.no-label {
            color: var(--text-muted);
            font-style: italic;
        }
        
        .setup-card-channel {
            font-size: 0.65rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .setup-card-modified {
            color: var(--warning);
            font-size: 0.8rem;
        }
        
        .setup-manager-footer {
            border-top: 1px solid var(--border);
            padding: 1rem 1.25rem;
            background: var(--bg-control);
        }
        
        .setup-manager-selection {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
        }
        
        .setup-manager-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .setup-manager-actions .btn {
            font-size: 0.7rem;
            padding: 0.4rem 0.75rem;
        }
        
        .setup-manager-actions .btn:disabled {
            opacity: 0.3;
        }
        
        /* Sub-dialog styles */
        .setup-subdialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            border: 1px solid var(--accent);
            padding: 1.25rem;
            z-index: 10001;
            min-width: 400px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .setup-subdialog h4 {
            font-family: var(--font-display);
            color: var(--accent);
            font-size: 0.9rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .setup-subdialog p {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
        }
        
        .setup-subdialog-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.5rem;
            margin: 1rem 0;
        }
        
        .setup-subdialog-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            background: var(--bg-control);
            border: 1px solid var(--border);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .setup-subdialog-item:hover:not(.disabled) {
            border-color: var(--accent);
        }
        
        .setup-subdialog-item.selected {
            background: var(--accent);
            color: var(--bg-dark);
            border-color: var(--accent);
        }
        
        .setup-subdialog-item.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .setup-subdialog-item.source {
            background: var(--bg-input);
            border-color: var(--border-light);
            cursor: default;
        }
        
        .setup-subdialog-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 1rem 0;
            font-size: 0.8rem;
            color: var(--text-dim);
        }
        
        .setup-subdialog-checkbox input {
            accent-color: var(--accent);
        }
        
        .setup-subdialog-warning {
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid var(--warning);
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            color: var(--warning);
            margin: 0.75rem 0;
        }
        
        .setup-subdialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        /* Label editor inline */
        .label-editor {
            margin: 1rem 0;
        }
        
        .label-editor input {
            width: 100%;
            padding: 0.5rem;
            font-family: inherit;
            font-size: 0.85rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            margin-bottom: 0.25rem;
        }
        
        .label-editor input:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .label-editor-hint {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .label-editor-error {
            font-size: 0.7rem;
            color: var(--error);
            margin-top: 0.25rem;
        }
        
        /* Import Dropdown Menu */
        .import-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .import-dropdown-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .import-dropdown-btn::after {
            content: 'â–¾';
            font-size: 0.6rem;
            opacity: 0.7;
        }
        
        .import-dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 2px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            min-width: 160px;
            z-index: 1001;
            display: none;
        }
        
        .import-dropdown.open .import-dropdown-menu {
            display: block;
        }
        
        .import-dropdown-item {
            padding: 0.6rem 0.8rem;
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--text);
            white-space: nowrap;
        }
        
        .import-dropdown-item:hover {
            background: var(--bg-control);
            color: var(--accent);
        }
        
        .import-dropdown-item.disabled {
            opacity: 0.4;
            pointer-events: none;
            cursor: not-allowed;
        }
        
        .import-dropdown-divider {
            height: 1px;
            background: var(--border);
            margin: 0.25rem 0;
        }
        
        /* Library Modal */
        .library-modal {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
        }
        
        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .library-header h2 {
            font-family: var(--font-display);
            color: var(--accent);
            font-size: 1.1rem;
            margin: 0;
        }
        
        .library-close {
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .library-close:hover {
            color: var(--text);
        }
        
        .library-filters {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .library-search {
            display: flex;
            align-items: center;
            background: var(--bg-input);
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
        }
        
        .library-search input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 0.85rem;
            outline: none;
        }
        
        .library-search-icon {
            color: var(--text-muted);
            margin-right: 0.5rem;
        }
        
        .library-search-clear {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 0.25rem;
            display: none;
        }
        
        .library-search-clear.visible {
            display: block;
        }
        
        .library-search-clear:hover {
            color: var(--text);
        }
        
        .library-filter-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .library-filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .library-filter-group label {
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        
        .library-filter-group select {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.35rem 0.5rem;
            cursor: pointer;
        }
        
        .library-tag-chips {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .library-tag-chip {
            background: var(--bg-control);
            border: 1px solid var(--border);
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: pointer;
        }
        
        .library-tag-chip.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
        }
        
        .library-tag-chip:focus {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }
        
        .library-tag-chip .remove {
            font-size: 0.8rem;
            opacity: 0.7;
        }
        
        .library-tag-chip:hover .remove {
            opacity: 1;
        }
        
        .library-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }
        
        .library-loading,
        .library-error,
        .library-empty {
            text-align: center;
            padding: 3rem;
            color: var(--text-dim);
        }
        
        .library-error {
            color: var(--error);
        }
        
        .library-retry-btn {
            margin-top: 1rem;
        }
        
        .library-cards {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .library-card {
            background: var(--bg-control);
            border: 1px solid var(--border);
            padding: 1rem;
        }
        
        .library-card:hover {
            border-color: var(--border-light);
        }
        
        .library-card:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            border-color: var(--accent);
        }
        
        .library-card:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        .library-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.5rem;
        }
        
        .library-card-title {
            font-size: 0.9rem;
            color: var(--text);
            font-weight: 600;
        }
        
        .library-card-badge {
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-input);
            padding: 0.15rem 0.4rem;
        }
        
        .library-card-desc {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        
        .library-card-meta {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }
        
        .library-card-tags {
            display: flex;
            gap: 0.3rem;
            flex-wrap: wrap;
            margin-bottom: 0.75rem;
        }
        
        .library-card-tag {
            font-size: 0.65rem;
            color: var(--text-muted);
            background: var(--bg-input);
            padding: 0.1rem 0.35rem;
        }
        
        .library-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .library-card-actions .btn {
            font-size: 0.7rem;
            padding: 0.4rem 0.75rem;
        }
        
        /* Library keyboard navigation and focus styles */
        .library-card:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        .library-card:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        .library-tag-chip:focus {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }
        
        .library-tag-chip:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 1px;
        }
        
        .library-search input:focus {
            outline: none;
        }
        
        .library-search:focus-within {
            border-color: var(--accent);
        }
        
        .library-footer {
            padding: 0.75rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        
        .library-footer a {
            color: var(--accent);
            text-decoration: none;
        }
        
        .library-footer a:hover {
            text-decoration: underline;
        }
        
        /* Share Dialog */
        .share-dialog {
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .share-dialog h3 {
            margin-bottom: 1rem;
        }
        
        .share-field {
            margin-bottom: 1rem;
        }
        
        .share-field label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
            color: var(--text-dim);
        }
        
        .share-field input,
        .share-field select,
        .share-field textarea {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: inherit;
            font-size: 0.9rem;
        }
        
        .share-field input:focus,
        .share-field select:focus,
        .share-field textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .share-field textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .share-field .char-count {
            font-size: 0.75rem;
            color: var(--text-dim);
            text-align: right;
            margin-top: 0.25rem;
        }
        
        .share-field .char-count.warning {
            color: var(--warning);
        }
        
        .share-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .share-tag {
            padding: 0.25rem 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.15s;
        }
        
        .share-tag:hover {
            border-color: var(--accent);
        }
        
        .share-tag.selected {
            background: var(--accent);
            color: var(--bg);
            border-color: var(--accent);
        }
        
        .share-tag-count {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 0.5rem;
        }
        
        .share-source {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            font-size: 0.85rem;
        }
        
        .share-source-label {
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }
        
        /* Library loading spinner */
        .library-spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 1rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Preview Mode Banner */
        .preview-banner {
            background: linear-gradient(90deg, #1a3a4a 0%, #0d2530 100%);
            border: 1px solid #2a5a6a;
            border-left: 4px solid var(--warning);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .preview-banner-text {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .preview-banner-icon {
            color: var(--warning);
            font-size: 1.1rem;
        }
        
        .preview-banner-title {
            font-weight: 600;
            color: var(--text);
        }
        
        .preview-banner-subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
        }
        
        .preview-banner-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .preview-banner-actions .btn {
            font-size: 0.75rem;
        }
        
        /* Disabled state for preview mode */
        body.preview-mode .file-actions .btn:not(.preview-allowed),
        body.preview-mode .nav-bar select,
        body.preview-mode .nav-bar .btn,
        body.preview-mode .group-tabs button,
        body.preview-mode .group-name-display,
        body.preview-mode .focused-inline-group-selector .selector-tab,
        body.preview-mode .focused-inline-group-selector .group-name-badge {
            pointer-events: none;
            opacity: 0.5;
        }
        
        body.preview-mode .control-input,
        body.preview-mode .control-select,
        body.preview-mode .control-card input,
        body.preview-mode .control-card select,
        body.preview-mode .encoder-row input,
        body.preview-mode .encoder-row select,
        body.preview-mode .fader-row input,
        body.preview-mode .fader-row select,
        body.preview-mode .btn-row input,
        body.preview-mode .btn-row select,
        body.preview-mode .main-content input,
        body.preview-mode .main-content select {
            pointer-events: none;
            opacity: 0.7;
        }
        
        /* aria-live regions */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Version Footer */
        .app-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px;
            background: var(--bg-dark);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            z-index: 50;
        }
        
        .app-footer a {
            color: var(--text-dim);
            text-decoration: none;
        }
        
        .app-footer a:hover {
            color: var(--accent);
        }
        
        .footer-sep {
            color: var(--border-light);
        }
        
        /* ============================================================
           Mobile Compatibility (Phase 6)
           ============================================================ */
        
        /* Mobile: < 640px */
        @media (max-width: 640px) {
            /* Footer: relative positioning */
            .app-footer {
                position: relative;
                height: auto;
                padding: 0.5rem;
            }
            
            /* Header: stack toolbar items */
            .header {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.5rem;
            }
            
            .header-title {
                font-size: 1rem;
            }
            
            .toolbar {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.25rem;
            }
            
            .toolbar .btn {
                padding: 0.5rem;
                min-height: 44px;
                min-width: 44px;
            }
            
            /* Navigation: horizontal scroll for tabs */
            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }
            
            .nav-tabs::-webkit-scrollbar {
                display: none;
            }
            
            /* Focused view: single column */
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .control-card {
                padding: 1rem;
            }
            
            /* Param inputs: larger touch targets */
            .param-input input,
            .param-input select {
                min-height: 44px;
                font-size: 16px;  /* Prevents iOS zoom on focus */
            }
            
            /* Overview grid: larger cells */
            .overview-cell {
                min-width: 60px;
                min-height: 44px;
                font-size: 0.65rem;
            }
            
            /* Modals: full width, scrollable */
            .modal-content {
                width: calc(100vw - 2rem);
                max-width: none;
                max-height: calc(100vh - 2rem);
                overflow-y: auto;
                margin: 1rem;
            }
            
            /* Setup Manager: 3 columns instead of 6 */
            .setup-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            /* Quick paste toolbar: stack vertically */
            .quick-paste-bar {
                flex-direction: column;
                align-items: stretch;
            }
            
            /* Toast: full width */
            #toastContainer {
                left: 1rem;
                right: 1rem;
                width: auto;
            }
            
            .toast {
                max-width: none;
            }
            
            /* Touch targets: ensure all interactive elements meet 44x44px minimum */
            button, 
            .btn,
            .tab,
            [role="button"] {
                min-height: 44px;
                min-width: 44px;
            }
            
            input,
            select {
                min-height: 44px;
                font-size: 16px;  /* Prevents iOS zoom */
            }
            
            /* Overview grid: horizontal scroll within container */
            .overview-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .overview-container .overview-grid {
                min-width: max-content;
            }
        }
        
        /* Tablet adjustments */
        @media (min-width: 641px) and (max-width: 1024px) {
            .control-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .setup-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }
        
        /* Prevent text selection on UI elements (all viewports) */
        .btn,
        .tab,
        .toolbar {
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Improve tap feedback */
        .btn:active,
        .tab:active {
            opacity: 0.7;
        }
        
        /* Fix iOS momentum scrolling */
        .modal-content,
        .overview-scroll,
        .nav-tabs {
            -webkit-overflow-scrolling: touch;
        }
        
        /* Safe area insets for notched devices */
        @supports (padding: max(0px)) {
            .header {
                padding-top: max(0.5rem, env(safe-area-inset-top));
            }
            
            .app-footer {
                padding-bottom: max(0.5rem, env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <div id="toastContainer" class="toast-container"></div>
    
    <!-- Tooltip element (single global instance) -->
    <div id="tooltip" class="tooltip" role="tooltip" aria-hidden="true">
        <div class="tooltip-content"></div>
        <div class="tooltip-arrow"></div>
    </div>
    
    <!-- Info Panel element (single global instance) -->
    <div id="infoPanel" class="info-panel" style="display: none;">
        <div class="info-panel-header">
            <span class="info-panel-title"></span>
            <button class="info-panel-close" aria-label="Close">&times;</button>
        </div>
        <div class="info-panel-content"></div>
    </div>
    
    <header class="header">
        <div class="logo">UC4 <span>SysEx Editor</span></div>
        <div class="view-toggle">
            <button class="view-btn active" id="focusedViewBtn" onclick="setView('focused')">Focused</button>
            <button class="view-btn" id="overviewBtn" onclick="setView('overview')">Overview</button>
        </div>
        <div class="file-actions">
            <input type="file" id="sysexInput" accept=".syx" class="hidden-input">
            <input type="file" id="jsonInput" accept=".json" class="hidden-input">
            <div class="import-dropdown" id="importDropdown">
                <button class="btn import-dropdown-btn" onclick="toggleImportDropdown(event)">Import</button>
                <div class="import-dropdown-menu">
                    <div class="import-dropdown-item" onclick="document.getElementById('sysexInput').click(); closeImportDropdown();">Import SysEx</div>
                    <div class="import-dropdown-item" id="importJsonItem" onclick="document.getElementById('jsonInput').click(); closeImportDropdown();">Import JSON</div>
                    <div class="import-dropdown-divider"></div>
                    <div class="import-dropdown-item" id="browseLibraryItem" onclick="openLibraryModal(); closeImportDropdown();">Browse Library...</div>
                </div>
            </div>
            <button class="btn" id="exportBtn" onclick="exportSysEx()" disabled>Export SysEx</button>
            <button class="btn" id="exportJsonBtn" onclick="exportJSON()" disabled>Export JSON</button>
            <span class="btn-divider"></span>
            <button class="btn" id="undoBtn" onclick="undo()" disabled title="Undo (Ctrl+Z)">â†¶ Undo</button>
            <button class="btn" id="redoBtn" onclick="redo()" disabled title="Redo (Ctrl+Y)">â†· Redo</button>
            <button class="btn" id="resetBtn" onclick="confirmReset()" title="Reset to imported SysEx or defaults">âŸ² Reset</button>
            <span class="btn-divider"></span>
            <a href="UC4_EDITOR_GUIDE.html" class="btn help-link" target="_blank" title="Usage Guide">? Guide</a>
        </div>
    </header>
    
    <nav class="nav-bar">
        <div class="nav-section">
            <span class="nav-label">Setup</span>
            <div class="select-wrapper">
                <select id="setupSelect" onchange="selectSetup(this.value)" disabled>
                    <option value="">--</option>
                </select>
            </div>
            <span id="librarySourceBadge" class="library-source-badge" style="display: none;"></span>
            <button class="btn" id="manageSetupsBtn" onclick="openSetupManager()" disabled>Setup Manager</button>
            <button class="btn" id="libraryBtn" onclick="openLibraryModal()" disabled>Library</button>
        </div>
        
        <div class="nav-section">
            <label class="link-groups-toggle" title="Change both groups together">
                <input type="checkbox" id="linkGroupsCheckbox" onchange="toggleLinkGroups(this.checked)">
                <span class="link-icon">ðŸ”—</span>
                <span class="nav-label">Link</span>
            </label>
        </div>
        
        <div class="nav-section">
            <span class="nav-label">Encoder Grp</span>
            <div class="group-tabs" id="encoderGroupTabs">
                <!-- Generated by JS -->
            </div>
            <div class="group-name-display" id="encoderGroupName" onclick="showGroupNameEditor(currentSetup, encoderGroup)" title="Click to edit group name">----</div>
        </div>
        
        <div class="nav-section">
            <span class="nav-label">Fader/Btn Grp</span>
            <div class="group-tabs" id="faderGroupTabs">
                <!-- Generated by JS -->
            </div>
            <div class="group-name-display" id="faderGroupName" onclick="showGroupNameEditor(currentSetup, faderGroup)" title="Click to edit group name">----</div>
        </div>
    </nav>
    
    <main class="main-content" id="mainContent">
        <div class="no-data">
            <h2>No SysEx Data Loaded</h2>
            <p>Import a UC4 SysEx dump to begin editing.</p>
            <p>Expected file size: 100,640 bytes (all 18 setups)</p>
        </div>
    </main>
    
    <footer class="app-footer">
        <span class="version-label">UC4 SysEx Editor v<span id="versionDisplay">1.2.0</span></span>
        <span class="footer-sep">|</span>
        <a href="https://github.com/thegdyne/uc4-sysex-editor" target="_blank" rel="noopener">GitHub</a>
    </footer>
    
    <footer class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">No data loaded</span>
        </div>
        <div>
            <span id="fileInfo">--</span>
        </div>
    </footer>

    <script>
        // ============================================================
        // UC4 SysEx Editor - Core Logic
        // ============================================================
        
        // State
        let rawBuffer = null;
        let originalBuffer = null;  // Stores the imported SysEx for reset
        let sectionIndex = null;
        let currentSetup = 0;
        let encoderGroup = 0;
        let faderGroup = 0;
        let currentView = 'focused';
        let isModified = false;
        let suppressModified = false;
        let dirtyBanks = new Set();
        
        // Setup Manager State
        let setupManagerOpen = false;
        let setupManagerSelection = new Set();  // Set of selected setup indices (0-17)
        const setupLabels = new Map();  // Map<setupIdx, string>
        const librarySourceMap = new Map();  // Map<setupIdx, configName> - tracks which setups came from library
        const differsFromFactoryCache = new Map();  // Map<setupIdx, boolean>
        let dirtySinceLoad = false;
        
        // Preview Mode State
        let previewBuffer = null;
        let previewMode = false;
        let previewEntry = null;  // Library entry being previewed
        let previewConfigData = null;  // Parsed config data for import
        const previewLabels = new Map();  // Same convention as setupLabels
        let prePreviewState = null;  // Saved UI state before preview
        
        // Factory Ableton Setup Detection
        // These hashes identify factory SE17/SE18 (Ableton configs) by their snapshot content
        // Generated from factory_default.syx - if a loaded setup matches, auto-label "Ableton"
        const ABLETON_SETUP_HASHES = {
            16: null,  // SE17 hash - will be computed on first factory load
            17: null   // SE18 hash - will be computed on first factory load
        };
        let abletonHashesInitialized = false;
        
        // Simple string hash (djb2 algorithm)
        function hashString(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i);
                hash = hash >>> 0;  // Convert to unsigned 32-bit
            }
            return hash.toString(16);
        }
        
        // Hash a setup snapshot for comparison
        function hashSetupSnapshot(snapshot) {
            return hashString(JSON.stringify(snapshot));
        }
        
        // Check if setup matches factory Ableton config and auto-label if so
        function checkAndApplyAbletonLabel(setupIdx) {
            if (!abletonHashesInitialized) return;
            
            const snapshot = captureSetupSnapshot(setupIdx);
            const hash = hashSetupSnapshot(snapshot);
            
            // Check against both Ableton setup hashes (SE17 and SE18)
            if (hash === ABLETON_SETUP_HASHES[16] || hash === ABLETON_SETUP_HASHES[17]) {
                setupLabels.set(setupIdx, 'Ableton');
            } else {
                // Clear label if it no longer matches (e.g., after edit)
                if (setupLabels.get(setupIdx) === 'Ableton') {
                    setupLabels.delete(setupIdx);
                }
            }
        }
        
        // Check all 18 setups for Ableton labels
        function checkAllAbletonLabels() {
            for (let i = 0; i < 18; i++) {
                checkAndApplyAbletonLabel(i);
            }
        }
        
        // Initialize Ableton hashes from factory templates (called once on factory load)
        function initAbletonHashes() {
            if (abletonHashesInitialized || !FACTORY_TEMPLATES) return;
            
            ABLETON_SETUP_HASHES[16] = hashSetupSnapshot(FACTORY_TEMPLATES[16]);
            ABLETON_SETUP_HASHES[17] = hashSetupSnapshot(FACTORY_TEMPLATES[17]);
            abletonHashesInitialized = true;
        }
        
        // Factory Templates - populated from factory_default.syx at init
        // Each setup has unique channel and CC assignments
        let FACTORY_TEMPLATES = null;  // Array(18) of setup snapshots (JSON-domain)
        
        // Undo/Redo State
        const undoStack = [];
        const redoStack = [];
        const MAX_UNDO = 100;
        const COALESCE_WINDOW = 1000; // 1 second
        
        // Session Persistence State
        const STORAGE_KEY = 'uc4-editor-session';
        const SESSION_VERSION = 1;
        const AUTO_SAVE_DELAY = 2000; // 2 seconds
        let autoSaveTimer = null;
        
        // Version Constants (for Library compatibility)
        const CURRENT_EDITOR_VERSION = '1.2.0';
        const SUPPORTED_SCHEMA_VERSION = '1.0.0';
        
        // Setup Library State
        const LIBRARY_BASE_URL = 'library';  // Relative path for GitHub Pages
        const LIBRARY_FETCH_TIMEOUT = 10000; // 10 seconds
        let libraryModalOpen = false;
        let libraryState = {
            index: null,
            searchText: '',
            deviceFilter: '',
            tagFilters: [],
            scrollPosition: 0
        };
        const libraryCache = {
            index: null,
            configs: new Map()  // key: `${id}:${contentHash}` -> { json, text, hashVerified, fetchedAt }
        };
        
        // Conflict Detection State
        const CONFLICT_REBUILD_DELAY = 200; // 200ms
        let conflictRebuildTimer = null;
        let conflicts = { concurrent: new Map(), mutuallyExclusive: new Map() };
        let conflictsByControl = new Map(); // Quick lookup: "type-group-index" -> [conflict keys]
        
        // Conflict filter state
        let showConcurrentConflicts = true;
        let showMutuallyExclusiveConflicts = false;
        
        // Copy/Paste State
        let clipboard = null;
        let selection = {
            mode: 'none', // 'none' | 'single' | 'row' | 'column'
            controlType: null,
            group: null,
            index: null
        };
        
        // Quick Paste State (v1.0)
        const quickPaste = {
            mode: 'off',           // 'off' | 'copy' | 'paste'
            scope: 'cell',         // 'cell' | 'column' | 'row'
            source: null,          // { controlType, group, index, data, lockedScope, count }
            chMultiplier: 0,       // Channel offset multiplier (-8 to +8)
            ccMultiplier: 0,       // CC offset multiplier (-8 to +8)
            pasteCount: 0,         // Total pastes this session
            doubleClickToastShown: false
        };
        
        // Link Groups State
        let linkGroups = false;
        
        // Focused View Inline Group Selector Constants
        const LINK_CANONICAL_DOMAIN = 'encoder';  // Which domain is canonical when linkGroups toggles ON
        const STICKY_HEADER_OFFSET_PX = 0;        // Adjust if nav becomes sticky
        let pendingFocusedAnchorKey = null;       // For "last click wins" scroll anchoring
        
        // Maps section keys to their group domain
        const SECTION_DOMAIN = {
            faders: 'fader',
            fader9: 'fader',
            green: 'fader',
            encoders: 'encoder',
            push: 'encoder'
        };
        
        // Parameters that affect conflict detection
        const CONFLICT_PARAMS = new Set([
            'channel', 'type', 'cc', 'note', 'typeNibble', 
            'upper', 'lower', 'mode', 'min', 'max'
        ]);
        
        // Constants
        const EXPECTED_SIZE = 100640;
        const NUM_SETUPS = 18;
        const NUM_GROUPS = 8;
        
        // ============================================================
        // Debug Configuration
        // ============================================================
        const DEBUG = false;  // Set to true for development
        const DEBUG_FLAGS = {
            groupNames: false,    // Verbose group name read logging
            addressing: false,    // SysEx address resolution logging
            validation: false,    // Import/export validation details
            actions: false        // Action log entries
        };

        function logDebug(category, ...args) {
            if (!DEBUG) return;
            if (category && DEBUG_FLAGS[category] === false) return;
            console.log(`[DEBUG${category ? ':' + category : ''}]`, ...args); // WRAPPER
        }

        function warnDebug(category, ...args) {
            if (!DEBUG) return;
            if (category && DEBUG_FLAGS[category] === false) return;
            console.log(`[DEBUG:warn${category ? ':' + category : ''}]`, ...args); // WRAPPER
        }
        
        // ============================================================
        // Error Handling Infrastructure
        // ============================================================
        
        const ErrorCode = {
            // File errors (1xx)
            FILE_READ_FAILED: 'E101',
            FILE_INVALID_FORMAT: 'E102',  // Reserved - not emitted in v1.x
            FILE_TOO_SMALL: 'E103',
            FILE_TOO_LARGE: 'E104',       // Reserved - not emitted in v1.x
            
            // SysEx errors (2xx)
            SYSEX_MISSING_START: 'E201',
            SYSEX_MISSING_END: 'E202',
            SYSEX_WRONG_LENGTH: 'E203',
            SYSEX_INVALID_HEADER: 'E204', // Reserved - not emitted in v1.x
            SYSEX_CHECKSUM_FAILED: 'E205', // Reserved - not emitted in v1.x
            
            // JSON errors (3xx)
            JSON_PARSE_FAILED: 'E301',
            JSON_MISSING_FORMAT: 'E302',
            JSON_INVALID_FORMAT: 'E303',
            JSON_SCHEMA_MISMATCH: 'E304',
            JSON_MISSING_GROUPS: 'E305',
            JSON_INVALID_STRUCTURE: 'E306',
            
            // Library errors (4xx)
            LIBRARY_FETCH_FAILED: 'E401',
            LIBRARY_INDEX_INVALID: 'E402',
            LIBRARY_CONFIG_INVALID: 'E403',
            LIBRARY_HASH_MISMATCH: 'E404',
            LIBRARY_VERSION_UNSUPPORTED: 'E405',
            
            // Runtime errors (5xx)
            STORAGE_FULL: 'E501',
            STORAGE_UNAVAILABLE: 'E502',
            CLIPBOARD_FAILED: 'E503',
            
            // Internal errors (9xx)
            INTERNAL_ERROR: 'E901',
            ASSERTION_FAILED: 'E902'
        };
        
        const Action = {
            LOAD_SYSEX: 'LOAD_SYSEX',
            LOAD_JSON: 'LOAD_JSON',
            EXPORT_SYSEX: 'EXPORT_SYSEX',
            EXPORT_JSON: 'EXPORT_JSON',
            CHANGE_SETUP: 'CHANGE_SETUP',
            CHANGE_GROUP: 'CHANGE_GROUP',
            EDIT_VALUE: 'EDIT_VALUE',
            COPY: 'COPY',
            PASTE: 'PASTE',
            UNDO: 'UNDO',
            REDO: 'REDO',
            RESET_SETUP: 'RESET_SETUP',
            LIBRARY_BROWSE: 'LIBRARY_BROWSE',
            LIBRARY_IMPORT: 'LIBRARY_IMPORT',
            SESSION_RESTORE: 'SESSION_RESTORE',
            SESSION_SAVE: 'SESSION_SAVE',
            FACTORY_LOADED: 'FACTORY_LOADED',
            FACTORY_SKIPPED: 'FACTORY_SKIPPED',
            ERROR_SHOWN: 'ERROR_SHOWN',
            ERROR_UNCAUGHT: 'ERROR_UNCAUGHT'
        };
        
        // Action log ring buffer
        const ACTION_LOG_SIZE = 50;
        const actionLog = [];
        
        function logAction(action, details = {}) {
            // Hardened: action logging must never throw (UI error paths depend on this)
            try {
                const entry = {
                    ts: Date.now(),
                    action,
                    ...details
                };
                actionLog.push(entry);
                if (actionLog.length > ACTION_LOG_SIZE) {
                    actionLog.shift();
                }
                try { logDebug('actions', action, details); } catch {}
            } catch {}
        }
        
        // Error tracking
        let lastError = null;
        const errorLog = [];
        const ERROR_LOG_SIZE = 10;
        
        function makeErr(code, userMessage, detail = null) {
            return {
                code,
                userMessage,
                detail,
                ts: Date.now()
            };
        }
        
        // Records error to log only (no action logging)
        function recordError(errObj) {
            lastError = errObj;
            errorLog.push(errObj);
            if (errorLog.length > ERROR_LOG_SIZE) errorLog.shift();
        }
        
        // Records error AND logs the ERROR_SHOWN action (use from showError only)
        function recordAndLogErrorShown(errObj) {
            recordError(errObj);
            try {
                logAction(Action.ERROR_SHOWN, { code: errObj.code, message: errObj.userMessage });
            } catch {}  // Avoid error-while-reporting-error spiral
        }
        
        // Last-resort error recording - absolutely cannot throw (for use in catch blocks of error handlers)
        function recordErrorLastResort(errObj) {
            try { lastError = errObj; } catch {}
            try { 
                errorLog.push(errObj); 
                if (errorLog.length > ERROR_LOG_SIZE) errorLog.shift(); 
            } catch {}
            // No logAction() call - that could throw
        }
        
        // ============================================================
        // Diagnostics Collection
        // ============================================================
        
        function collectDiagnostics() {
            // Defensive: wrap in try/catch since this is called from error UI
            try {
                return {
                    editor: {
                        version: CURRENT_EDITOR_VERSION,
                        schemaVersion: (typeof SUPPORTED_SCHEMA_VERSION !== 'undefined' ? SUPPORTED_SCHEMA_VERSION : 'unknown'),
                        url: window.location.href,
                        timestamp: new Date().toISOString()
                    },
                    browser: {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        cookiesEnabled: navigator.cookieEnabled,
                        localStorage: (() => {
                            try {
                                localStorage.setItem('__test__', '1');
                                localStorage.removeItem('__test__');
                                return 'available';
                            } catch {
                                return 'unavailable';
                            }
                        })()
                    },
                    state: {
                        view: typeof currentView !== 'undefined' ? currentView : 'unknown',
                        setup: typeof currentSetup !== 'undefined' ? currentSetup : -1,
                        encoderGroup: typeof encoderGroup !== 'undefined' ? encoderGroup : -1,
                        faderGroup: typeof faderGroup !== 'undefined' ? faderGroup : -1,
                        hasData: typeof rawBuffer !== 'undefined' && rawBuffer !== null,
                        dataSize: (typeof rawBuffer !== 'undefined' && rawBuffer) ? rawBuffer.length : 0,
                        undoStackSize: (Array.isArray(undoStack) ? undoStack.length : 0),
                        redoStackSize: (Array.isArray(redoStack) ? redoStack.length : 0),
                        isPreviewMode: (typeof previewMode !== 'undefined' ? !!previewMode :
                                       (typeof previewState !== 'undefined' ? !!previewState : false))
                    },
                    actions: (Array.isArray(actionLog) ? actionLog.slice(-20) : []),
                    errors: (Array.isArray(errorLog) ? errorLog.slice() : []),
                    lastError: lastError
                };
            } catch (e) {
                // Fallback if state collection fails
                return {
                    editor: { version: CURRENT_EDITOR_VERSION, error: 'Failed to collect full diagnostics' },
                    browser: { userAgent: navigator.userAgent },
                    state: { error: e.message },
                    actions: (Array.isArray(actionLog) ? actionLog.slice(-20) : []),
                    errors: (Array.isArray(errorLog) ? errorLog.slice() : []),
                    lastError: lastError
                };
            }
        }
        
        function formatDiagnosticsForCopy(diag) {
            const last = diag.lastError;
            const state = diag.state || {};
            
            // Format index values: -1 or missing -> 'unknown', otherwise 1-based
            const fmtIdx = (v) => (typeof v === 'number' && v >= 0) ? String(v + 1) : 'unknown';
            
            // Format timestamp: handle missing/invalid gracefully
            const fmtTime = (ts) => {
                const d = new Date(ts);
                return isNaN(d.getTime()) ? '--:--:--' : d.toISOString().slice(11, 19);
            };
            
            return `UC4 Editor Diagnostics
========================
Version: ${diag.editor?.version ?? 'unknown'}
Time: ${diag.editor?.timestamp ?? new Date().toISOString()}
URL: ${diag.editor?.url ?? window.location.href}

Browser: ${diag.browser?.userAgent ?? 'unknown'}
Storage: ${diag.browser?.localStorage ?? 'unknown'}

State:
  View: ${state.view ?? 'unknown'}
  Setup: ${fmtIdx(state.setup)}
  Encoder Group: ${fmtIdx(state.encoderGroup)}
  Fader Group: ${fmtIdx(state.faderGroup)}
  Data loaded: ${state.hasData ?? false} (${state.dataSize ?? 0} bytes)
  Undo/Redo: ${state.undoStackSize ?? 0}/${state.redoStackSize ?? 0}
  Preview mode: ${state.isPreviewMode ?? false}
${state.error ? `  Collection error: ${state.error}\n` : ''}
Recent Actions:
${(diag.actions || []).map(a => `  ${fmtTime(a.ts)} ${a.action ?? 'UNKNOWN'}`).join('\n') || '  (none)'}

${last ? `Last Error:
  Code: ${last.code}
  Message: ${last.userMessage}
  Detail: ${JSON.stringify(last.detail ?? null)}
` : ''}`;
        }
        
        // ============================================================
        // Clipboard with Fallback
        // ============================================================
        
        async function copyText(text) {
            // 1) Modern clipboard API (preferred)
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (_) {}

            // 2) Fallback: hidden textarea + execCommand (for file:// and iOS)
            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.setAttribute('readonly', '');
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                ta.style.top = '0';
                document.body.appendChild(ta);
                ta.focus();  // Required for iOS Safari
                ta.select();
                ta.setSelectionRange(0, ta.value.length);  // iOS Safari compatibility
                const ok = document.execCommand('copy');
                ta.remove();
                return ok;
            } catch (_) {
                return false;
            }
        }
        
        // ============================================================
        // Utility Functions
        // ============================================================
        
        function escapeHtml(str) {
            try {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            } catch {
                // Fallback if DOM manipulation fails
                return String(str).replace(/[&<>"']/g, c => ({
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
                }[c]));
            }
        }
        
        // ============================================================
        // SysEx Validation
        // ============================================================
        
        // Strict allow-list of valid UC4 dump lengths
        // Add more only when verified against actual firmware dumps
        const UC4_EXPECTED_LENGTHS = [100640];
        
        /**
         * Validate SysEx data structure
         * @param {Uint8Array} bytes - Raw SysEx bytes
         * @returns {{ valid: boolean, code?: string, message?: string, detail?: object }}
         * 
         * Invariant: If valid === false, code and message MUST be present.
         */
        function validateSyx(bytes) {
            // Check we have data (empty file is a size issue, not a read failure)
            if (!bytes || bytes.length === 0) {
                return {
                    valid: false,
                    code: ErrorCode.FILE_TOO_SMALL,
                    message: 'Empty file (0 bytes)'
                };
            }
            
            // Check minimum size for sanity (fast fail on obviously invalid files)
            if (bytes.length < 16) {
                return {
                    valid: false,
                    code: ErrorCode.FILE_TOO_SMALL,
                    message: `File too small (${bytes.length} bytes)`
                };
            }
            
            // Check SysEx framing
            if (bytes[0] !== 0xF0) {
                return {
                    valid: false,
                    code: ErrorCode.SYSEX_MISSING_START,
                    message: 'Invalid file: missing SysEx start byte (0xF0)'
                };
            }
            
            if (bytes[bytes.length - 1] !== 0xF7) {
                return {
                    valid: false,
                    code: ErrorCode.SYSEX_MISSING_END,
                    message: 'Invalid file: missing SysEx end byte (0xF7)'
                };
            }
            
            // Strict length check against allow-list
            if (!UC4_EXPECTED_LENGTHS.includes(bytes.length)) {
                return {
                    valid: false,
                    code: ErrorCode.SYSEX_WRONG_LENGTH,
                    message: `Unexpected SysEx length (${bytes.length} bytes). Expected ${UC4_EXPECTED_LENGTHS.join(' or ')}`,
                    detail: { actual: bytes.length, expected: UC4_EXPECTED_LENGTHS.slice() }
                };
            }
            
            return {
                valid: true,
                detail: { size: bytes.length }
            };
        }
        
        // ============================================================
        // Global Error Handlers
        // ============================================================
        
        // Re-entrancy guard to prevent infinite recursion if showError itself throws
        let inGlobalErrorHandler = false;
        
        window.addEventListener('error', (e) => {
            if (inGlobalErrorHandler) {
                // Last resort fallback - showError is broken
                console.error('Error in error handler:', e.message);
                return;
            }
            
            inGlobalErrorHandler = true;
            try {
                try { logAction(Action.ERROR_UNCAUGHT, { message: e.message }); } catch {}
                
                try {
                    showError(
                        ErrorCode.INTERNAL_ERROR,
                        'Unexpected error occurred',
                        {
                            message: e.message,
                            filename: e.filename,
                            lineno: e.lineno,
                            colno: e.colno,
                            stack: e.error?.stack
                        }
                    );
                } catch (err2) {
                    // showError failed - use hardened fallback that cannot throw
                    const errObj = makeErr(ErrorCode.INTERNAL_ERROR, 'Unexpected error occurred', {
                        original: e.message,
                        handlerError: String(err2)
                    });
                    recordErrorLastResort(errObj);
                    console.error('showError failed:', err2);
                }
            } finally {
                inGlobalErrorHandler = false;
            }
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            if (inGlobalErrorHandler) {
                console.error('Error in rejection handler:', e.reason);
                return;
            }
            
            inGlobalErrorHandler = true;
            try {
                const reason = e.reason?.message ?? String(e.reason);
                try { logAction(Action.ERROR_UNCAUGHT, { message: reason }); } catch {}
                
                try {
                    showError(
                        ErrorCode.INTERNAL_ERROR,
                        'Unexpected error occurred',
                        { reason }
                    );
                } catch (err2) {
                    // showError failed - use hardened fallback that cannot throw
                    const errObj = makeErr(ErrorCode.INTERNAL_ERROR, 'Unexpected error occurred', {
                        original: reason,
                        handlerError: String(err2)
                    });
                    recordErrorLastResort(errObj);
                    console.error('showError failed:', err2);
                }
            } finally {
                inGlobalErrorHandler = false;
            }
        });
        
        // Section IDs
        const SECTIONS = {
            ENCODER_CHAN_TYPE: 0x1C,
            ENCODER_ACC_DISP: 0x1D,
            PUSH_CHAN_TYPE: 0x1D,
            PUSH_CC: 0x1D,
            PUSH_LOWER: 0x1D,
            PUSH_UPPER: 0x1E,
            PUSH_MODE: 0x1E,
            GREEN_CHAN_TYPE: 0x1E,
            GREEN_CC: 0x1E,
            GREEN_LOWER: 0x1F,
            GREEN_UPPER: 0x1F,
            GREEN_MODE: 0x1F,
            FADER_CHAN_TYPE: 0x1F,
            FADER_CC: 0x20,
            FADER_MIN: 0x20,
            FADER_MAX: 0x20,
            FADER_MODE: 0x20,
            FADER9: 0x17,
            GROUP_NAMES: 0x14
        };
        
        const BANKS = {
            ENC_CHAN_TYPE: 0x00,
            ENC_CC: 0x40,
            ENC_MIN: 0x80,
            ENC_MAX: 0xC0,
            ENC_ACC_DISP: 0x00,
            PUSH_CHAN_TYPE: 0x40,
            PUSH_CC: 0x80,
            PUSH_LOWER: 0xC0,
            PUSH_UPPER: 0x00,
            PUSH_MODE: 0x40,
            GREEN_CHAN_TYPE: 0x80,
            GREEN_CC: 0xC0,
            GREEN_LOWER: 0x00,
            GREEN_UPPER: 0x40,
            GREEN_MODE: 0x80,
            FADER_CHAN_TYPE: 0xC0,
            FADER_CC: 0x00,
            FADER_MIN: 0x40,
            FADER_MAX: 0x80,
            FADER_MODE: 0xC0,
            FADER9: 0x00,
            GROUP_NAMES: 0x80
        };
        
        // ============================================================
        // Group Name Character Mapping (Single Source of Truth)
        // Per UC4_GROUP_NAME_EDITING_SPEC_v2
        // ============================================================
        
        // Single source of truth - value to glyph (32-element array, indices 0-31)
        // GLYPH_TABLE: Hardware-verified via SysEx dumps (2024-01-14)
        // Canonical range 0-31, verified positions marked with âœ“
        // Factory Ableton: Snd1=[27,22,13,1], trAC=[28,26,10,12], GLOb=[16,20,23,11]
        // Hardware tests: H1=17, H2/h=30, n_big=21(U), n_small=22(n), Q_9like=25(q)
        const GLYPH_TABLE = {
            0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9',  // âœ“ all
            10: 'A', 11: 'b', 12: 'C', 13: 'd', 14: 'E', 15: 'F', 16: 'G', 17: 'H',  // âœ“ A,b,C,d,G,H
            18: 'I', 19: 'J', 20: 'L', 21: 'U', 22: 'n', 23: 'O', 24: 'P', 25: 'q',  // âœ“ L,U,n,O,P,q
            26: 'r', 27: 'S', 28: 't', 29: 'Y', 30: 'h', 31: '?'  // âœ“ r,S,t,h,Y; 31 displays as Y on hardware (unknown/duplicate)
        };
        
        // Non-canonical glyphs (outside 0-31 range, used in some presets)
        const NON_CANONICAL_GLYPHS = {
            33: '-',  // dash (verified: glyph_dash.syx)
            34: '_',  // underscore/lowbar (verified: glyph_lowbar.syx)
            35: '|',  // segment: top-left
            36: '||',  // segment: two top verticals
            37: '=',  // segment: two bottom horizontals
            38: ' '   // space variant (verified: glyph_blank.syx, Ableton RAC_/PAn_)
        };
        
        // Invariant check (run once at startup)
        for (let i = 0; i < 32; i++) {
            if (!(i in GLYPH_TABLE)) {
                throw new Error(`GLYPH_TABLE missing entry for value ${i}`);
            }
        }
        
        // Derived: glyph to value (built from GLYPH_TABLE + NON_CANONICAL_GLYPHS)
        const VALUE_TABLE = {};
        for (const [val, glyph] of Object.entries(GLYPH_TABLE)) {
            VALUE_TABLE[glyph] = parseInt(val);
        }
        // Override space to use 38 (hardware verified: UC4 displays Y for value 31, space for 38)
        // Factory Ableton presets use 38 for trailing spaces in names like "rAC ", "PAn "
        VALUE_TABLE[' '] = 38;
        VALUE_TABLE['-'] = 33;
        VALUE_TABLE['_'] = 34;
        
        // Input normalization: user input -> display glyph
        const INPUT_NORMALIZE = {
            // Lowercase that map to lowercase glyphs (7-seg limitation)
            'B': 'b', 'b': 'b',
            'D': 'd', 'd': 'd',
            'N': 'n', 'n': 'n',
            'T': 't', 't': 't',
            'R': 'r', 'r': 'r',
            'Q': 'q', 'q': 'q',  // q looks like 9 on 7-seg
            // Lowercase h maps to position 30 (distinct from H at 17)
            'h': 'h',
            'H': 'H',
            // Lowercase that map to uppercase glyphs
            'a': 'A', 'A': 'A',
            'c': 'C', 'C': 'C',
            'e': 'E', 'E': 'E',
            'f': 'F', 'F': 'F',
            'g': 'G', 'G': 'G',
            'i': 'I', 'I': 'I',
            'j': 'J', 'J': 'J',
            'l': 'L', 'L': 'L',
            'o': 'O', 'O': 'O',
            'p': 'P', 'P': 'P',
            's': 'S', 'S': 'S',
            'u': 'U', 'U': 'U',
            'y': 'Y', 'Y': 'Y',
            // Letters impossible on 7-seg, mapped to closest visual equivalent
            'V': 'U', 'v': 'U',  // V looks like U on 7-seg
            'W': 'U', 'w': 'U',  // W has no equivalent, U is closest
            'M': 'n', 'm': 'n',  // M approximated as n
            'K': 'H', 'k': 'H',  // K approximated as H
            'X': 'H', 'x': 'H',  // X approximated as H
            'Z': '2', 'z': '2',  // Z looks like 2 on 7-seg (classic trick)
            // Direct mappings
            '0': '0', '1': '1', '2': '2', '3': '3', '4': '4',
            '5': '5', '6': '6', '7': '7', '8': '8', '9': '9',
            '-': '-', '_': '_', ' ': ' '
        };
        
        function normalizeInputChar(char) {
            return INPUT_NORMALIZE[char] ?? null;  // null = invalid
        }
        
        function encodeGlyph(glyph) {
            return VALUE_TABLE[glyph] ?? null;  // null = not in table
        }
        
        function decodeGroupNameByte(val) {
            // UC4 glyph codes are NOT ASCII - they're indices into the 7-seg character set
            // Base set: 0-31, Extended set: 33-38 (verified from hardware)
            if (val >= 0 && val <= 31) {
                return { glyph: GLYPH_TABLE[val], canonical: true };
            } else if (val in NON_CANONICAL_GLYPHS) {
                return { glyph: NON_CANONICAL_GLYPHS[val], canonical: false };
            } else {
                // Unknown glyph code - show replacement character, NOT ASCII
                return { glyph: '\uFFFD', canonical: false };
            }
        }
        
        // Type definitions
        const ENCODER_TYPES = ['CCr1', 'CCr2', 'CCAb', 'PrGC', 'CCAh', 'Pbnd', 'AFtt'];
        const FADER_TYPES = ['CCAb', 'PrGC', 'Pbnd', 'AFtt'];
        const BUTTON_TYPES = {0x00: 'OFF', 0x10: 'Note', 0x20: 'CC', 0x30: 'PrGC', 0x40: 'AFtt'};
        const BUTTON_TYPE_VALUES = [0x00, 0x10, 0x20, 0x30, 0x40];
        const ACC_MODES = ['Acc0', 'Acc1', 'Acc2', 'Acc3'];
        const DISPLAY_MODES = ['OFF', 'Std', 'bPoL'];
        const BUTTON_DISPLAY_MODES = ['OFF', 'Std'];
        const GREEN_DISPLAY_MODES = ['OFF', 'Std', 'EXt'];
        const BUTTON_MODES = ['Momentary', 'Toggle'];
        const FADER_MODES = ['Jump', 'Snap'];
        
        // ============================================================
        // Tooltip Content (per UC4_FOCUSED_TOOLTIPS_SPEC_v6)
        // ============================================================
        
        const TOOLTIPS = {
            // Parameter labels - keyed by controlType.paramName
            labels: {
                'encoder.chan': "MIDI channel (1-16). Controls which channel receives encoder messages.",
                'encoder.cc': "Controller number (0-127). The MIDI CC number sent when encoder is turned. For CCAh mode, also occupies CC+32 for the LSB.",
                'encoder.type': "Message type sent when encoder is turned.",
                'encoder.acc': "Acceleration sensitivity. Higher values = faster response to quick turns.",
                'encoder.disp': "Display mode. How values appear on the UC4's 7-segment display.",
                'encoder.min': "Minimum output value (0-127). Encoder won't send values below this.",
                'encoder.max': "Maximum output value (0-127). Encoder won't send values above this.",
                
                'fader.chan': "MIDI channel (1-16). Controls which channel receives fader messages.",
                'fader.cc': "Controller number (0-127). The MIDI CC number sent when fader is moved.",
                'fader.type': "Message type sent when fader is moved.",
                'fader.mode': "Pickup behaviour. How the fader responds when position doesn't match current value.",
                'fader.disp': "Display mode. How values appear on the UC4's 7-segment display.",
                'fader.min': "Value sent at bottom position (0-127). Fader travel maps to Minâ†’Max range.",
                'fader.max': "Value sent at top position (0-127). Set Min > Max to invert fader direction.",
                
                'fader9.chan': "MIDI channel (1-16). Controls which channel receives expression pedal messages.",
                'fader9.cc': "Controller number (0-127). Typically CC 11 (Expression) or CC 7 (Volume).",
                'fader9.mode': "Pickup behaviour. Jump sends immediately; Snap waits to catch current value.",
                'fader9.min': "Value sent at heel position (0-127).",
                'fader9.max': "Value sent at toe position (0-127). Set Min > Max to invert pedal direction.",
                
                'push.chan': "MIDI channel (1-16). Controls which channel receives button messages.",
                'push.note': "Note or CC number (0-127). The MIDI note/CC sent when button is pressed.",
                'push.type': "Message type sent when button is pressed/released.",
                'push.mode': "Button behaviour. Momentary sends on press/release; Toggle latches on/off.",
                'push.lo': "Lower/release value (0-127). Sent on release (Momentary) or when toggled off.",
                'push.hi': "Upper/press value (0-127). Sent on press (Momentary) or when toggled on.",
                
                'green.chan': "MIDI channel (1-16). Controls which channel receives button messages.",
                'green.note': "Note or CC number (0-127). Also used for LED feedback on same number.",
                'green.type': "Message type sent when button is pressed/released.",
                'green.mode': "Button behaviour. Momentary sends on press/release; Toggle latches on/off.",
                'green.led': "LED illumination mode. Controls when the green button lights up.",
                'green.lo': "Lower/release value (0-127). Sent on release (Momentary) or when toggled off.",
                'green.hi': "Upper/press value (0-127). Sent on press (Momentary) or when toggled on."
            },
            
            // Dropdown options - keyed by optionGroup.optionValue
            options: {
                // Encoder types
                'encoderType.CCr1': "Relative mode 1. Sends 1 for clockwise, 127 for counter-clockwise. Best for Ableton Live, Bitwig. Endless rotation.",
                'encoderType.CCr2': "Relative mode 2. Sends 65 for clockwise, 63 for counter-clockwise. Alternative relative format. Endless rotation.",
                'encoderType.CCAb': "Absolute 7-bit CC. Standard MIDI CC (0-127). Value jumps to match encoder position. Factory default.",
                'encoderType.PrGC': "Program Change. Sends MIDI program change (0-127 internally, some instruments display 1-128). Turn to increment/decrement.",
                'encoderType.CCAh': "Absolute 14-bit high-resolution CC. Uses CC N (MSB) and CC N+32 (LSB) for 16384 steps. CC must be 0-31. Best for sensitive parameters.",
                'encoderType.Pbnd': "Pitch Bend. Sends 14-bit Pitch Bend message on the selected MIDI channel (-8192 to +8191). No CC number needed.",
                'encoderType.AFtt': "Aftertouch (Channel Pressure). Sends channel pressure (0-127). Use for expression control.",
                
                // Fader types
                'faderType.CCAb': "Absolute 7-bit CC. Standard MIDI CC (0-127). Factory default. Most common choice.",
                'faderType.PrGC': "Program Change. Sends MIDI program change (0-127). Fader position selects program.",
                'faderType.Pbnd': "Pitch Bend. Sends 14-bit Pitch Bend message on the selected MIDI channel. Full range mapped to fader travel. No CC number needed.",
                'faderType.AFtt': "Aftertouch (Channel Pressure). Sends channel pressure. Fader controls expression amount.",
                
                // Acceleration (shared global group)
                'acc.0': "No acceleration. 1:1 response regardless of turn speed. Most precise, slowest to traverse full range.",
                'acc.1': "Low acceleration. Slight speed boost for faster turns. Good balance of precision and speed.",
                'acc.2': "Medium acceleration. Moderate speed boost. Faster traversal with some precision trade-off.",
                'acc.3': "Maximum acceleration. Fastest response to quick turns. Best for quickly sweeping values. Factory default.",
                
                // Display modes (shared global group)
                'display.OFF': "Display disabled. 7-segment shows nothing when this control is active.",
                'display.Std': "Standard display. Shows current value 0-127 on the 7-segment. Factory default.",
                'display.bPoL': "Bipolar display. Shows value as Â±63, centered at 64. Good for pan or bipolar parameters.",
                
                // Fader modes (shared by faders 1-8 and fader 9)
                'faderMode.Jump': "Immediate response. Sends current position when moved. May cause value jumps.",
                'faderMode.Snap': "Pickup mode. Only sends after position catches current value. Prevents jumps.",
                
                // Button types (shared by push and green buttons)
                'buttonType.OFF': "Button disabled. No MIDI message sent when pressed.",
                'buttonType.Note': "Note On/Off. Sends Note On (Hi velocity) on press, Note Off (Lo) on release. Factory default. Best for triggering clips/samples in DAWs.",
                'buttonType.CC': "Control Change. Sends CC with Hi value on press, Lo on release. Good for momentary effects.",
                'buttonType.PrGC': "Program Change. Sends program change (0-127) on press. Lo value typically ignored.",
                'buttonType.AFtt': "Aftertouch. Sends channel pressure Hi on press, Lo on release.",
                
                // Button modes (shared by push and green buttons)
                'buttonMode.Momentary': "Gate mode. Hi on press, Lo on release. Active only while held.",
                'buttonMode.Toggle': "Latch mode. First press sends Hi, next press sends Lo. Alternates each press.",
                
                // Green LED modes
                'greenLed.OFF': "LED always off. Button never illuminates.",
                'greenLed.Std': "Standard. LED reflects button state AND responds to incoming MIDI feedback. Factory default.",
                'greenLed.EXt': "External only. LED controlled only by incoming MIDI. Button presses don't change LED. Best for DAW sync."
            }
        };
        
        // Option group to panel title mapping
        const OPTION_GROUP_TITLES = {
            'encoderType': 'Encoder Type Options',
            'faderType': 'Fader Type Options',
            'acc': 'Acceleration Options',
            'display': 'Display Options',
            'faderMode': 'Fader Mode Options',
            'buttonType': 'Button Type Options',
            'buttonMode': 'Button Mode Options',
            'greenLed': 'LED Options'
        };
        
        // ============================================================
        // SysEx Parsing
        // ============================================================
        
        function decodeValue(buf, offset, idx) {
            const pos = offset + idx * 3;
            if (pos + 2 >= buf.length || buf[pos] !== 0x4D) return null;
            return ((buf[pos + 1] & 0x0F) << 4) | (buf[pos + 2] & 0x0F);
        }
        
        function encodeValue(buf, offset, idx, value) {
            const pos = offset + idx * 3;
            buf[pos] = 0x4D;
            buf[pos + 1] = 0x20 | ((value >> 4) & 0x0F);
            buf[pos + 2] = 0x10 | (value & 0x0F);
        }
        
        function buildIndex(buf) {
            // FIXED: Build flat index - each (secId, bank) appears once
            // Setup addressing is computed in getValue/setValue
            const index = {};
            
            for (let i = 0; i < buf.length - 10; i++) {
                if (buf[i] === 0x49 && (i === 0 || buf[i-1] !== 0x4D) && buf[i+3] === 0x4A) {
                    const secId = ((buf[i+1] & 0x0F) << 4) | (buf[i+2] & 0x0F);
                    const bank = ((buf[i+4] & 0x0F) << 4) | (buf[i+5] & 0x0F);
                    const dataOffset = i + 6;
                    
                    let pos = dataOffset;
                    while (pos < buf.length && buf[pos] === 0x4D) pos += 3;
                    const valueCount = (pos - dataOffset) / 3;
                    const checksumOffset = pos;
                    
                    if (!index[secId]) index[secId] = {};
                    index[secId][bank] = { dataOffset, valueCount, checksumOffset };
                }
            }
            
            return index;
        }
        
        // Compute actual section and bank for a given setupIdx
        // Different control types use different addressing schemes
        function computeActualLocation(setupIdx, secId, bank, valueIdx) {
            let actualSecId, actualBank, actualValueIdx;
            
            if (secId === 0x17) {
                // Fader9: 4 setups per section, bank encodes setup within section
                actualSecId = 0x17 + Math.floor(setupIdx / 4);
                actualBank = (setupIdx % 4) * 0x40;
                actualValueIdx = valueIdx;
            } else if (secId === 0x14 && bank === 0x80) {
                // Group Names: Complex storage pattern (empirically verified via hardware diff)
                // Section 0x14 (banks 0x80/0xC0 only): Setups 0-3 (2 per bank)
                // Section 0x15+ (all 4 banks): 8 setups per section (2 per bank)
                
                if (setupIdx < 4) {
                    // Setups 0-3: Section 0x14, banks 0x80/0xC0
                    actualSecId = 0x14;
                    const bankIdx = Math.floor(setupIdx / 2);  // 0 or 1
                    actualBank = 0x80 + bankIdx * 0x40;  // 0x80 or 0xC0
                    const valueOffset = (setupIdx % 2) * 32;
                    actualValueIdx = valueIdx + valueOffset;
                } else {
                    // Setups 4+: Section 0x15+, using all 4 banks (0x00, 0x40, 0x80, 0xC0)
                    const localSetup = setupIdx - 4;
                    actualSecId = 0x15 + Math.floor(localSetup / 8);
                    const localInSection = localSetup % 8;
                    const bankIdx = Math.floor(localInSection / 2);  // 0, 1, 2, or 3
                    actualBank = bankIdx * 0x40;  // 0x00, 0x40, 0x80, or 0xC0
                    const valueOffset = (localInSection % 2) * 32;
                    actualValueIdx = valueIdx + valueOffset;
                }
            } else {
                // All others (Encoder, Push, Green, Fader): stride-of-5 pattern
                actualSecId = secId + (setupIdx * 5);
                actualBank = bank;
                actualValueIdx = valueIdx;
            }
            
            return { actualSecId, actualBank, actualValueIdx };
        }
        
        function recalcBankChecksum(buf, dataStart) {
            let sum = 0;
            let pos = dataStart;
            
            while (pos < buf.length && buf[pos] === 0x4D) {
                sum += ((buf[pos + 1] & 0x0F) << 4) | (buf[pos + 2] & 0x0F);
                pos += 3;
            }
            
            sum = sum & 0xFFFF;
            
            if (pos + 5 < buf.length && buf[pos] === 0x4B && buf[pos + 3] === 0x4C) {
                buf[pos + 1] = 0x20 | ((sum >> 12) & 0x0F);
                buf[pos + 2] = 0x10 | ((sum >> 8) & 0x0F);
                buf[pos + 4] = 0x20 | ((sum >> 4) & 0x0F);
                buf[pos + 5] = 0x10 | (sum & 0x0F);
            }
        }
        
        // Buffer and label accessors for preview mode
        function getActiveBuffer() {
            return previewMode ? previewBuffer : rawBuffer;
        }
        
        function getActiveLabels() {
            return previewMode ? previewLabels : setupLabels;
        }
        
        function getValue(setupIdx, secId, bank, valueIdx) {
            if (!sectionIndex) return null;
            
            const loc = computeActualLocation(setupIdx, secId, bank, valueIdx);
            
            const sec = sectionIndex[loc.actualSecId];
            if (!sec) return null;
            const bnk = sec[loc.actualBank];
            if (!bnk) return null;
            return decodeValue(getActiveBuffer(), bnk.dataOffset, loc.actualValueIdx);
        }
        
        function setValue(setupIdx, secId, bank, valueIdx, value) {
            if (!sectionIndex) return;
            
            const loc = computeActualLocation(setupIdx, secId, bank, valueIdx);
            const sec = sectionIndex[loc.actualSecId];
            if (!sec) return;
            const bnk = sec[loc.actualBank];
            if (!bnk) return;
            
            encodeValue(rawBuffer, bnk.dataOffset, loc.actualValueIdx, value);
            dirtyBanks.add(`${setupIdx}-${loc.actualSecId}-${loc.actualBank}`);
            if (!suppressModified) markModified();
        }
        
        // ============================================================
        // Control Value Helpers
        // ============================================================
        
        function getEncoderData(setupIdx, group, enc) {
            const idx = group * 8 + enc;
            const chanType = getValue(setupIdx, 0x1C, 0x00, idx) || 0x20;
            const accDisp = getValue(setupIdx, 0x1D, 0x00, idx) || 0x31;
            
            return {
                channel: (chanType & 0x0F) + 1,
                type: (chanType >> 4) & 0x0F,
                cc: getValue(setupIdx, 0x1C, 0x40, idx) || 0,
                min: getValue(setupIdx, 0x1C, 0x80, idx) || 0,
                max: getValue(setupIdx, 0x1C, 0xC0, idx) || 127,
                acc: (accDisp >> 4) & 0x0F,
                display: accDisp & 0x0F
            };
        }
        
        function setEncoderData(setupIdx, group, enc, data) {
            const idx = group * 8 + enc;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            const accDisp = ((data.acc & 0x0F) << 4) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1C, 0x00, idx, chanType);
            setValue(setupIdx, 0x1C, 0x40, idx, data.cc);
            setValue(setupIdx, 0x1C, 0x80, idx, data.min);
            setValue(setupIdx, 0x1C, 0xC0, idx, data.max);
            setValue(setupIdx, 0x1D, 0x00, idx, accDisp);
        }
        
        function getPushData(setupIdx, group, btn) {
            const idx = group * 8 + btn;
            const chanType = getValue(setupIdx, 0x1D, 0x40, idx) || 0x10;
            const modeDisp = getValue(setupIdx, 0x1E, 0x40, idx) || 0x00;
            
            return {
                channel: (chanType & 0x0F) + 1,
                typeNibble: chanType & 0xF0,
                cc: getValue(setupIdx, 0x1D, 0x80, idx) || 0,
                lower: getValue(setupIdx, 0x1D, 0xC0, idx) || 0,
                upper: getValue(setupIdx, 0x1E, 0x00, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setPushData(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = (data.typeNibble & 0xF0) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1D, 0x40, idx, chanType);
            setValue(setupIdx, 0x1D, 0x80, idx, data.cc);
            setValue(setupIdx, 0x1D, 0xC0, idx, data.lower);
            setValue(setupIdx, 0x1E, 0x00, idx, data.upper);
            setValue(setupIdx, 0x1E, 0x40, idx, modeDisp);
        }
        
        function getGreenData(setupIdx, group, btn) {
            const idx = group * 8 + btn;
            const chanType = getValue(setupIdx, 0x1E, 0x80, idx) || 0x10;
            const modeDisp = getValue(setupIdx, 0x1F, 0x80, idx) || 0x01;
            
            return {
                channel: (chanType & 0x0F) + 1,
                typeNibble: chanType & 0xF0,
                cc: getValue(setupIdx, 0x1E, 0xC0, idx) || 64,
                lower: getValue(setupIdx, 0x1F, 0x00, idx) || 0,
                upper: getValue(setupIdx, 0x1F, 0x40, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setGreenData(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = (data.typeNibble & 0xF0) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1E, 0x80, idx, chanType);
            setValue(setupIdx, 0x1E, 0xC0, idx, data.cc);
            setValue(setupIdx, 0x1F, 0x00, idx, data.lower);
            setValue(setupIdx, 0x1F, 0x40, idx, data.upper);
            setValue(setupIdx, 0x1F, 0x80, idx, modeDisp);
        }
        
        function getFaderData(setupIdx, group, fader) {
            const idx = group * 8 + fader;
            const chanType = getValue(setupIdx, 0x1F, 0xC0, idx) || 0x00;
            const modeDisp = getValue(setupIdx, 0x20, 0xC0, idx) || 0x01;
            
            return {
                channel: (chanType & 0x0F) + 1,
                type: (chanType >> 4) & 0x0F,
                cc: getValue(setupIdx, 0x20, 0x00, idx) || 32,
                min: getValue(setupIdx, 0x20, 0x40, idx) || 0,
                max: getValue(setupIdx, 0x20, 0x80, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setFaderData(setupIdx, group, fader, data) {
            const idx = group * 8 + fader;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1F, 0xC0, idx, chanType);
            setValue(setupIdx, 0x20, 0x00, idx, data.cc);
            setValue(setupIdx, 0x20, 0x40, idx, data.min);
            setValue(setupIdx, 0x20, 0x80, idx, data.max);
            setValue(setupIdx, 0x20, 0xC0, idx, modeDisp);
        }
        
        function getFader9Data(setupIdx, group) {
            // Fader 9: 5 values per group in section 0x17 bank 0x00
            const baseIdx = group * 5;
            const modeVal = getValue(setupIdx, 0x17, 0x00, baseIdx + 4) || 1;
            
            return {
                channel: (getValue(setupIdx, 0x17, 0x00, baseIdx) || 0) + 1,
                cc: getValue(setupIdx, 0x17, 0x00, baseIdx + 1) || 112,
                min: getValue(setupIdx, 0x17, 0x00, baseIdx + 2) || 0,
                max: getValue(setupIdx, 0x17, 0x00, baseIdx + 3) || 127,
                mode: (modeVal & 0x10) ? 1 : 0
            };
        }
        
        function setFader9Data(setupIdx, group, data) {
            const baseIdx = group * 5;
            const modeVal = data.mode ? 0x11 : 0x01;
            
            setValue(setupIdx, 0x17, 0x00, baseIdx, (data.channel - 1) & 0x0F);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 1, data.cc);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 2, data.min);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 3, data.max);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 4, modeVal);
        }
        
        // ============================================================
        // Group Name Functions (per UC4_GROUP_NAME_EDITING_SPEC_v2)
        // ============================================================
        
        // Returns raw values + decoded string + warning flag
        function getGroupNameData(setupIdx, group) {
            // Group names are stored PER-SETUP in section 0x14 bank 0x80
            const baseIdx = group * 4;
            const values = [];
            const chars = [];
            let hasNonCanonical = false;
            
            // Debug: log computed addresses for problematic setups
            if (DEBUG && DEBUG_FLAGS.groupNames && setupIdx >= 8) {
                const loc = computeActualLocation(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, baseIdx);
                logDebug('groupNames', `Setup ${setupIdx + 1}, Group ${group + 1}: logical=(0x14, 0x80, ${baseIdx}) -> physical=(0x${loc.actualSecId.toString(16)}, 0x${loc.actualBank.toString(16)}, ${loc.actualValueIdx})`);
            }
            
            for (let i = 0; i < 4; i++) {
                const val = getValue(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, baseIdx + i);
                
                if (val === null) {
                    // Read failed - return null to indicate failure
                    if (DEBUG && DEBUG_FLAGS.groupNames && setupIdx >= 8) {
                        logDebug('groupNames', `Setup ${setupIdx + 1}, Group ${group + 1}, char ${i}: READ FAILED (null)`);
                    }
                    return null;
                }
                
                values.push(val);
                
                const decoded = decodeGroupNameByte(val);
                chars.push(decoded.glyph);
                if (!decoded.canonical) {
                    hasNonCanonical = true;
                }
            }
            
            // Debug: log raw values for problematic setups
            if (DEBUG && DEBUG_FLAGS.groupNames && setupIdx >= 8) {
                logDebug('groupNames', `Setup ${setupIdx + 1}, Group ${group + 1}: raw bytes=[${values.join(', ')}] (0x${values.map(v => v.toString(16).padStart(2, '0')).join(', 0x')}) -> "${chars.join('')}"`);
            }
            
            return {
                values: values,           // Raw bytes [v0, v1, v2, v3]
                display: chars.join(''),  // Decoded string for display
                hasNonCanonical: hasNonCanonical  // True if any bytes outside 0-31 range
            };
        }
        
        // Convenience wrapper for display-only contexts
        function getGroupName(setupIdx, group) {
            const data = getGroupNameData(setupIdx, group);
            if (data === null) {
                return `GrP${group + 1}`;  // Only fallback on complete read failure
            }
            return data.display;
        }
        
        // Debug function - call from console: debugGroupNames(setupIdx)
        function debugGroupNames(setupIdx) {
            logDebug('addressing', `=== Group Names for Setup ${setupIdx + 1} ===`);
            for (let g = 0; g < 8; g++) {
                const data = getGroupNameData(setupIdx, g);
                if (data === null) {
                    logDebug('addressing', `  Group ${g + 1}: READ FAILED`);
                } else {
                    logDebug('addressing', `  Group ${g + 1}: values=[${data.values.join(', ')}] display="${data.display}" nonCanonical=${data.hasNonCanonical}`);
                }
            }
            // Also show the computed location for first group
            const loc = computeActualLocation(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, 0);
            logDebug('addressing', `  Location: section=0x${loc.actualSecId.toString(16)}, bank=0x${loc.actualBank.toString(16)}, valueIdx=${loc.actualValueIdx}`);
        }
        
        // Debug function - call from console: debugEncoderAddressing()
        // Verifies that each setup reads from different sections
        function debugEncoderAddressing() {
            logDebug('addressing', '=== Encoder Address Mapping (first 6 setups) ===');
            logDebug('addressing', 'Encoder data uses stride-of-5: Setup N reads from section (0x1C + N*5)');
            for (let s = 0; s < 6; s++) {
                const loc = computeActualLocation(s, 0x1C, 0x00, 0);
                const exists = sectionIndex && sectionIndex[loc.actualSecId] && sectionIndex[loc.actualSecId][loc.actualBank];
                const enc0 = getValue(s, 0x1C, 0x00, 0);
                logDebug('addressing', `  Setup ${s+1}: actualSecId=0x${loc.actualSecId.toString(16)} ${exists ? 'âœ“' : 'âœ—'} enc[0,0] chanType=0x${(enc0 || 0).toString(16)}`);
            }
        }
        
        // Debug function - call from console: debugSectionIndex()
        // Shows all sections/banks present in the loaded SysEx
        function debugSectionIndex() {
            if (!sectionIndex) {
                logDebug('addressing', 'No SysEx loaded');
                return;
            }
            logDebug('addressing', '=== Section Index (what exists in SysEx) ===');
            const sections = Object.keys(sectionIndex).map(s => parseInt(s)).sort((a,b) => a-b);
            for (const secId of sections) {
                const banks = Object.keys(sectionIndex[secId]).map(b => parseInt(b)).sort((a,b) => a-b);
                for (const bank of banks) {
                    const info = sectionIndex[secId][bank];
                    logDebug('addressing', `  Section 0x${secId.toString(16).padStart(2,'0')} Bank 0x${bank.toString(16).padStart(2,'0')}: offset=${info.dataOffset}, values=${info.valueCount}`);
                }
            }
            logDebug('addressing', '');
            logDebug('addressing', '=== Group Name Address Mapping (all 18 setups) ===');
            for (let s = 0; s < 18; s++) {
                const loc = computeActualLocation(s, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, 0);
                const exists = sectionIndex[loc.actualSecId] && sectionIndex[loc.actualSecId][loc.actualBank];
                logDebug('addressing', `  Setup ${(s+1).toString().padStart(2)}: logical=(0x14, 0x80) â†’ physical=(0x${loc.actualSecId.toString(16)}, 0x${loc.actualBank.toString(16)}) ${exists ? 'âœ“ EXISTS' : 'âœ— MISSING'}`);
            }
        }
        
        // Debug function - call from console: debugAllGroupNames()
        // Shows all group names for all setups
        function debugAllGroupNames() {
            logDebug('addressing', '=== All Group Names (all 18 setups) ===');
            for (let s = 0; s < 18; s++) {
                const names = [];
                for (let g = 0; g < 8; g++) {
                    const data = getGroupNameData(s, g);
                    names.push(data ? `"${data.display}"` : 'NULL');
                }
                logDebug('addressing', `  Setup ${(s+1).toString().padStart(2)}: ${names.join(', ')}`);
            }
        }
        
        // Write 4 byte values to group name
        function setGroupName(setupIdx, group, values) {
            // values must be array of exactly 4 byte values
            if (!Array.isArray(values) || values.length !== 4) {
                console.error('Group name must be exactly 4 byte values');
                return false;
            }
            
            const baseIdx = group * 4;
            
            for (let i = 0; i < 4; i++) {
                const val = values[i];
                if (typeof val !== 'number' || val < 0 || val > 255) {
                    console.error(`Invalid byte value ${val} at position ${i}`);
                    return false;
                }
                setValue(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, baseIdx + i, val);
            }
            
            return true;
        }
        
        // Convert user input string to byte values
        function stringToGroupNameValues(input) {
            // Normalize and pad to 4 characters
            let normalized = '';
            for (const char of input.substring(0, 4)) {
                // Reject any character with codepoint > 127 (includes Unicode whitespace, NBSP, etc.)
                if (char.charCodeAt(0) > 127) {
                    return { error: `Invalid character: ${char} (non-ASCII)` };
                }
                const norm = normalizeInputChar(char);
                if (norm === null) {
                    return { error: `Invalid character: ${char}` };
                }
                normalized += norm;
            }
            
            // Pad with spaces
            while (normalized.length < 4) {
                normalized += ' ';
            }
            
            // Convert to values (Rule 5: Encoding Totality)
            const values = [];
            for (const glyph of normalized) {
                const val = encodeGlyph(glyph);
                if (val === null) {
                    // This should never happen if normalization is correct
                    return { error: `Internal error: glyph not encodable: ${glyph}` };
                }
                values.push(val);
            }
            
            return { values, display: normalized };
        }
        
        // Change group name with undo support (stores raw bytes)
        function changeGroupNameWithUndo(setupIdx, group, newValues) {
            const oldData = getGroupNameData(setupIdx, group);
            if (oldData === null) return false;
            
            const oldValues = oldData.values;
            
            // Check if actually changed (byte-based comparison)
            if (oldValues.every((v, i) => v === newValues[i])) {
                return false;
            }
            
            // Get display strings for description
            const oldDisplay = oldData.display;
            const newDisplay = newValues.map(v => decodeGroupNameByte(v).glyph).join('');
            
            // Record undo action with RAW BYTE VALUES (not strings)
            const action = {
                type: 'group-name',
                description: `Rename group ${group + 1}: "${oldDisplay}" â†’ "${newDisplay}"`,
                setupIdx,
                group,
                beforeValues: Array.from(oldValues),   // [v0, v1, v2, v3]
                afterValues: Array.from(newValues)    // [v0, v1, v2, v3]
            };
            
            recordUndo(action);
            setGroupName(setupIdx, group, newValues);
            markModified();
            
            return true;
        }
        
        // Render group name with warning badge for non-canonical bytes
        function renderGroupNameWithWarning(setupIdx, group) {
            const data = getGroupNameData(setupIdx, group);
            
            if (data === null) {
                return `<span class="group-name">GrP${group + 1}</span>`;
            }
            
            const displayText = data.display === '    ' ? '----' : escapeHtml(data.display);
            
            if (data.hasNonCanonical) {
                return `<span class="group-name has-warning" title="Contains non-standard codes; preserved unless overwritten">${displayText} âš </span>`;
            }
            
            return `<span class="group-name">${displayText}</span>`;
        }
        
        // HTML escape helper
        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
        
        // ============================================================
        // UI Rendering
        // ============================================================
        
        function initUI() {
            // Generate group tabs
            for (let i = 0; i < NUM_GROUPS; i++) {
                const encTab = document.createElement('button');
                encTab.className = 'group-tab' + (i === 0 ? ' active' : '');
                encTab.textContent = i + 1;
                encTab.onclick = () => selectEncoderGroup(i);
                document.getElementById('encoderGroupTabs').appendChild(encTab);
                
                const fadTab = document.createElement('button');
                fadTab.className = 'group-tab' + (i === 0 ? ' active' : '');
                fadTab.textContent = i + 1;
                fadTab.onclick = () => selectFaderGroup(i);
                document.getElementById('faderGroupTabs').appendChild(fadTab);
            }
            
            // Populate setup dropdown
            const setupSelect = document.getElementById('setupSelect');
            for (let i = 0; i < NUM_SETUPS; i++) {
                const opt = document.createElement('option');
                opt.value = i;
                if (i < 16) {
                    opt.textContent = `Setup ${i + 1}`;
                } else if (i === 16) {
                    opt.textContent = 'Setup 17 (Ableton 1-8)';
                } else {
                    opt.textContent = 'Setup 18 (Ableton 9-16)';
                }
                setupSelect.appendChild(opt);
            }
            
            // Set initial dropdown state (disabled until buffer loaded)
            updateImportDropdownState();
        }
        
        function renderFocusedView() {
            const main = document.getElementById('mainContent');
            main.innerHTML = '';
            
            // Helper to safely append sections (createSection may return null)
            const appendSection = (section, gridCreator) => {
                if (!section) return;
                if (gridCreator) {
                    const grid = gridCreator();
                    section.appendChild(grid);
                }
                main.appendChild(section);
            };
            
            // Faders section (uses fader group)
            const faderSection = createSection('Faders', 'faders', 'faders');
            appendSection(faderSection, () => {
                const grid = document.createElement('div');
                grid.className = 'control-grid';
                for (let i = 0; i < 8; i++) grid.appendChild(createFaderCard(i));
                return grid;
            });
            
            // Fader 9 section (uses fader group)
            const fader9Section = createSection('Fader 9', 'fader9', 'fader9');
            if (fader9Section) {
                fader9Section.appendChild(createFader9Card());
                main.appendChild(fader9Section);
            }
            
            // Green Buttons section (uses fader group)
            const greenSection = createSection('Green Buttons', 'green', 'green');
            appendSection(greenSection, () => {
                const grid = document.createElement('div');
                grid.className = 'control-grid';
                for (let i = 0; i < 8; i++) grid.appendChild(createGreenCard(i));
                return grid;
            });
            
            // Encoders section (uses encoder group)
            const encSection = createSection('Encoders', 'encoders', 'encoders');
            appendSection(encSection, () => {
                const grid = document.createElement('div');
                grid.className = 'control-grid';
                for (let i = 0; i < 8; i++) grid.appendChild(createEncoderCard(i));
                return grid;
            });
            
            // Push Buttons section (uses encoder group)
            const pushSection = createSection('Push Buttons', 'push', 'push');
            appendSection(pushSection, () => {
                const grid = document.createElement('div');
                grid.className = 'control-grid';
                for (let i = 0; i < 8; i++) grid.appendChild(createPushCard(i));
                return grid;
            });
        }
        
        /**
         * Creates a section with inline group selector for Focused View.
         * @param {string} title - Section title (e.g., "Encoders")
         * @param {string} className - CSS class for styling (e.g., "encoders")
         * @param {string} sectionKey - Stable key for data-section attribute
         */
        function createSection(title, className, sectionKey) {
            const section = document.createElement('section');
            section.className = 'control-section';
            section.dataset.section = sectionKey;  // For scroll anchoring
            
            // Derive domain from sectionKey mapping
            const domain = SECTION_DOMAIN[sectionKey];
            if (!domain) {
                console.error(`Unknown sectionKey: ${sectionKey}`);
                return null;
            }
            section.dataset.domain = domain;
            
            // Derive active group from current state
            const activeGroup = domain === 'encoder' ? encoderGroup : faderGroup;
            
            const header = document.createElement('div');
            header.className = 'focused-section-header';
            
            const h2 = document.createElement('h2');
            h2.className = 'section-title ' + className;
            h2.textContent = title;
            header.appendChild(h2);
            
            // Inline group selector
            const selectorContainer = document.createElement('div');
            selectorContainer.className = `focused-inline-group-selector ${domain}-domain`;
            selectorContainer.dataset.domain = domain;
            selectorContainer.setAttribute('aria-label', 
                domain === 'encoder' ? 'Encoder group selector' : 'Fader group selector');
            
            // Group name badge (clickable to edit)
            const nameBadge = document.createElement('span');
            nameBadge.className = 'group-name-badge';
            nameBadge.textContent = getGroupName(currentSetup, activeGroup);
            nameBadge.title = 'Click to edit group name';
            nameBadge.onclick = () => {
                // Derive group at click time to avoid stale closure
                const currentActiveGroup = domain === 'encoder' ? encoderGroup : faderGroup;
                showGroupNameEditor(currentSetup, currentActiveGroup);
            };
            selectorContainer.appendChild(nameBadge);
            
            // Group tabs
            const tabs = document.createElement('div');
            tabs.className = 'selector-tabs';
            tabs.setAttribute('role', 'group');
            tabs.setAttribute('aria-label', 'Select group');
            
            for (let i = 0; i < 8; i++) {
                const tab = document.createElement('button');
                tab.type = 'button';
                tab.className = 'selector-tab' + (i === activeGroup ? ' active' : '');
                tab.dataset.group = i;
                tab.textContent = i + 1;
                tab.title = `Group ${i + 1}: ${getGroupName(currentSetup, i)}`;
                tab.setAttribute('aria-pressed', String(i === activeGroup));
                tabs.appendChild(tab);
            }
            
            // Attach click handler to tabs container (event delegation)
            tabs.addEventListener('click', (e) => {
                const tab = e.target.closest('.selector-tab');
                if (!tab) return;
                
                const groupIndex = parseInt(tab.dataset.group, 10);
                const clickedSectionKey = tab.closest('section')?.dataset.section;
                if (!clickedSectionKey) return;
                handleFocusedGroupChange(domain, groupIndex, clickedSectionKey);
            });
            
            selectorContainer.appendChild(tabs);
            header.appendChild(selectorContainer);
            
            section.appendChild(header);
            return section;
        }
        
        /**
         * Handles group changes from inline selectors in Focused View.
         * Preserves scroll position across full re-render.
         */
        function handleFocusedGroupChange(domain, groupIndex, sectionKey) {
            // Early exit if already on this group
            const currentGroup = domain === 'encoder' ? encoderGroup : faderGroup;
            if (groupIndex === currentGroup && (!linkGroups || encoderGroup === faderGroup)) {
                return;
            }
            
            // Capture scroll position before re-render
            const scrollY = window.scrollY;
            
            // Use existing group selection functions (they handle linkGroups and trigger re-render)
            if (domain === 'encoder') {
                selectEncoderGroup(groupIndex);
            } else {
                selectFaderGroup(groupIndex);
            }
            
            // Restore scroll position after render
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollY);
            });
        }
        
        function createEncoderCard(idx) {
            const data = getEncoderData(currentSetup, encoderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card encoder';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Encoder ${idx + 1}</span>
                    <span class="control-index">E${encoderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.chan">Chan</span>
                    <div class="param-input">
                        <select data-param="channel" onchange="updateEncoder(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.cc">CC</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updateEncoder(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="encoderType">Type</span>
                    <div class="param-input">
                        <select data-option-group="encoderType" onchange="updateEncoder(${idx}, 'type', this.value)">
                            ${ENCODER_TYPES.map((t, i) => 
                                `<option value="${i}" ${data.type === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="acc">Acc</span>
                    <div class="param-input">
                        <select data-option-group="acc" onchange="updateEncoder(${idx}, 'acc', this.value)">
                            ${ACC_MODES.map((t, i) => 
                                `<option value="${i}" ${data.acc === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="display">Disp</span>
                    <div class="param-input">
                        <select data-option-group="display" onchange="updateEncoder(${idx}, 'display', this.value)">
                            ${DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.min">Min</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.min}"
                            onchange="updateEncoder(${idx}, 'min', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.max">Max</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.max}"
                            onchange="updateEncoder(${idx}, 'max', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createPushCard(idx) {
            const data = getPushData(currentSetup, encoderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card push';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Push ${idx + 1}</span>
                    <span class="control-index">P${encoderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.chan">Chan</span>
                    <div class="param-input">
                        <select onchange="updatePush(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.note">Note</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updatePush(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonType">Type</span>
                    <div class="param-input">
                        <select data-option-group="buttonType" onchange="updatePush(${idx}, 'typeNibble', this.value)">
                            ${BUTTON_TYPE_VALUES.map(v => 
                                `<option value="${v}" ${data.typeNibble === v ? 'selected' : ''}>${BUTTON_TYPES[v]}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonMode">Mode</span>
                    <div class="param-input">
                        <select data-option-group="buttonMode" onchange="updatePush(${idx}, 'mode', this.value)">
                            ${BUTTON_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.lo">Lo</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.lower}"
                            onchange="updatePush(${idx}, 'lower', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.hi">Hi</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.upper}"
                            onchange="updatePush(${idx}, 'upper', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createGreenCard(idx) {
            const data = getGreenData(currentSetup, faderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card green';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Button ${idx + 1}</span>
                    <span class="control-index">B${faderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.chan">Chan</span>
                    <div class="param-input">
                        <select onchange="updateGreen(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.note">Note</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updateGreen(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonType">Type</span>
                    <div class="param-input">
                        <select data-option-group="buttonType" onchange="updateGreen(${idx}, 'typeNibble', this.value)">
                            ${BUTTON_TYPE_VALUES.map(v => 
                                `<option value="${v}" ${data.typeNibble === v ? 'selected' : ''}>${BUTTON_TYPES[v]}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonMode">Mode</span>
                    <div class="param-input">
                        <select data-option-group="buttonMode" onchange="updateGreen(${idx}, 'mode', this.value)">
                            ${BUTTON_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="greenLed">LED</span>
                    <div class="param-input">
                        <select data-option-group="greenLed" onchange="updateGreen(${idx}, 'display', this.value)">
                            ${GREEN_DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.lo">Lo</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.lower}"
                            onchange="updateGreen(${idx}, 'lower', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.hi">Hi</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.upper}"
                            onchange="updateGreen(${idx}, 'upper', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createFaderCard(idx) {
            const data = getFaderData(currentSetup, faderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card fader';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Fader ${idx + 1}</span>
                    <span class="control-index">F${faderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.chan">Chan</span>
                    <div class="param-input">
                        <select onchange="updateFader(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.cc">CC</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updateFader(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="faderType">Type</span>
                    <div class="param-input">
                        <select data-option-group="faderType" onchange="updateFader(${idx}, 'type', this.value)">
                            ${FADER_TYPES.map((t, i) => 
                                `<option value="${i}" ${data.type === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="faderMode">Mode</span>
                    <div class="param-input">
                        <select data-option-group="faderMode" onchange="updateFader(${idx}, 'mode', this.value)">
                            ${FADER_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="display">Disp</span>
                    <div class="param-input">
                        <select data-option-group="display" onchange="updateFader(${idx}, 'display', this.value)">
                            ${DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.min">Min</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.min}"
                            onchange="updateFader(${idx}, 'min', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.max">Max</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.max}"
                            onchange="updateFader(${idx}, 'max', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createFader9Card() {
            const data = getFader9Data(currentSetup, faderGroup);
            const card = document.createElement('div');
            card.className = 'fader9-card';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Fader 9</span>
                    <span class="control-index">F${faderGroup + 1}.9</span>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.75rem;">
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.chan">Chan</span>
                        <div class="param-input">
                            <select onchange="updateFader9('channel', this.value)">
                                ${Array.from({length: 16}, (_, i) => 
                                    `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.cc">CC</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.cc}"
                                onchange="updateFader9('cc', this.value)">
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-options" data-info-group="faderMode">Mode</span>
                        <div class="param-input">
                            <select data-option-group="faderMode" onchange="updateFader9('mode', this.value)">
                                ${FADER_MODES.map((t, i) => 
                                    `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.min">Min</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.min}"
                                onchange="updateFader9('min', this.value)">
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.max">Max</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.max}"
                                onchange="updateFader9('max', this.value)">
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function renderOverview() {
            const main = document.getElementById('mainContent');
            main.innerHTML = '';
            
            const container = document.createElement('div');
            container.className = 'overview-container';
            
            // Quick Paste Toolbar (guarded for safety)
            if (typeof createQuickPasteToolbar === 'function') {
                container.appendChild(createQuickPasteToolbar());
            }
            
            // Tab bar
            const tabs = document.createElement('div');
            tabs.className = 'overview-tabs';
            tabs.innerHTML = `
                <button class="overview-tab ${overviewTab === 'all' ? 'active' : ''}" onclick="setOverviewTab('all')">All</button>
                <button class="overview-tab ${overviewTab === 'faders' ? 'active' : ''}" onclick="setOverviewTab('faders')">Faders</button>
                <button class="overview-tab ${overviewTab === 'green' ? 'active' : ''}" onclick="setOverviewTab('green')">Green Buttons</button>
                <button class="overview-tab ${overviewTab === 'encoders' ? 'active' : ''}" onclick="setOverviewTab('encoders')">Encoders</button>
                <button class="overview-tab ${overviewTab === 'push' ? 'active' : ''}" onclick="setOverviewTab('push')">Push Buttons</button>
            `;
            container.appendChild(tabs);
            
            // Conflict filter chips
            const filters = document.createElement('div');
            filters.className = 'conflict-filters';
            filters.innerHTML = `
                <span class="conflict-filters-label">Conflicts:</span>
                <div class="filter-chip ${showConcurrentConflicts ? 'active' : ''}" onclick="toggleConcurrentFilter()">
                    <span class="checkmark">${showConcurrentConflicts ? 'âœ“' : ''}</span>
                    Concurrent
                    <span class="count" id="concurrentCount">${conflicts.concurrent.size}</span>
                </div>
                <div class="filter-chip ${showMutuallyExclusiveConflicts ? 'active dim' : ''}" onclick="toggleMEFilter()">
                    <span class="checkmark">${showMutuallyExclusiveConflicts ? 'âœ“' : ''}</span>
                    Mutually-Exclusive
                    <span class="count" id="meCount">${conflicts.mutuallyExclusive.size}</span>
                </div>
            `;
            container.appendChild(filters);
            
            // Grid based on active tab
            const grid = document.createElement('div');
            grid.className = 'overview-grid';
            
            switch (overviewTab) {
                case 'all':
                    // Show all control types stacked: Faders 1-8, Fader 9, Green, Encoders, Push
                    grid.appendChild(createOverviewSection('Faders 1-8', createFaderOverviewTable(), 'faders'));
                    grid.appendChild(createOverviewSection('Fader 9', createFader9OverviewTable(), 'fader9'));
                    grid.appendChild(createOverviewSection('Green Buttons', createButtonOverviewTable('green', getGreenData, 'B'), 'green'));
                    grid.appendChild(createOverviewSection('Encoders', createEncoderOverviewTable(), 'encoders'));
                    grid.appendChild(createOverviewSection('Push Buttons', createButtonOverviewTable('push', getPushData, 'P'), 'push'));
                    break;
                case 'encoders':
                    grid.appendChild(createEncoderOverviewTable());
                    break;
                case 'push':
                    grid.appendChild(createButtonOverviewTable('push', getPushData, 'P'));
                    break;
                case 'green':
                    grid.appendChild(createButtonOverviewTable('green', getGreenData, 'B'));
                    break;
                case 'faders':
                    grid.appendChild(createOverviewSection('Faders 1-8', createFaderOverviewTable(), 'faders'));
                    grid.appendChild(createOverviewSection('Fader 9', createFader9OverviewTable(), 'fader9'));
                    break;
            }
            
            container.appendChild(grid);
            
            // Conflict panel (show only if there are conflicts to display)
            const visibleConflicts = [];
            if (showConcurrentConflicts) {
                for (const [key, entry] of conflicts.concurrent) {
                    visibleConflicts.push({ key, entry, type: 'concurrent' });
                }
            }
            if (showMutuallyExclusiveConflicts) {
                for (const [key, entry] of conflicts.mutuallyExclusive) {
                    visibleConflicts.push({ key, entry, type: 'me' });
                }
            }
            
            if (visibleConflicts.length > 0) {
                const panel = document.createElement('div');
                panel.className = 'conflict-panel';
                panel.innerHTML = `
                    <div class="conflict-panel-header">
                        <span>âš  ${visibleConflicts.length} Conflict${visibleConflicts.length !== 1 ? 's' : ''}</span>
                    </div>
                `;
                
                for (const { key, entry, type } of visibleConflicts.slice(0, 20)) {
                    const item = document.createElement('div');
                    item.className = `conflict-item ${type === 'me' ? 'dim' : ''}`;
                    const refsStr = entry.refs.map(formatControlRef).join(', ');
                    item.innerHTML = `
                        <span class="warning-icon">âš  </span>
                        <span class="conflict-key">${formatConflictKey(key)}:</span>
                        <span class="conflict-refs">${refsStr}</span>
                    `;
                    panel.appendChild(item);
                }
                
                if (visibleConflicts.length > 20) {
                    const more = document.createElement('div');
                    more.className = 'conflict-item';
                    more.innerHTML = `<span class="conflict-refs">...and ${visibleConflicts.length - 20} more</span>`;
                    panel.appendChild(more);
                }
                
                container.appendChild(panel);
            }
            
            main.appendChild(container);
            
            // Update cursor classes on all tables (guarded for safety)
            if (typeof updateOverviewTableCursor === 'function') {
                updateOverviewTableCursor();
            }
        }
        
        // Overview state
        let overviewTab = 'all';
        
        function setOverviewTab(tab) {
            overviewTab = tab;
            renderOverview();
        }
        
        // MIDI Channel Helpers
        function chDisp(ch0) { return (ch0 | 0) + 1; }
        
        function formatEncoderCell(data) {
            const typeMap = {
                0: 'r1', 1: 'r2', 2: 'CC', 3: 'PC', 4: 'Hi', 5: 'PB', 6: 'AT'
            };
            const type = typeMap[data.type] || '??';
            const ch = chDisp(data.channel - 1);  // data.channel is already 1-based
            
            // Program Change: show range
            if (data.type === 3) {
                const lo = Math.min(data.min, data.max);
                const hi = Math.max(data.min, data.max);
                return `${ch}:PC ${lo}-${hi}`;
            }
            
            // Pitch bend and aftertouch have no CC number
            if (data.type === 5 || data.type === 6) {
                return `${ch}:${type}`;
            }
            
            return `${ch}:${type} ${data.cc}`;
        }
        
        function formatFaderCell(data) {
            const typeMap = { 0: 'CC', 1: 'PC', 2: 'PB', 3: 'AT' };
            const type = typeMap[data.type] || '??';
            const ch = chDisp(data.channel - 1);
            
            // Program Change: show range
            if (data.type === 1) {
                const lo = Math.min(data.min, data.max);
                const hi = Math.max(data.min, data.max);
                return `${ch}:PC ${lo}-${hi}`;
            }
            
            // Pitch bend and aftertouch have no CC number
            if (data.type === 2 || data.type === 3) {
                return `${ch}:${type}`;
            }
            
            return `${ch}:${type} ${data.cc}`;
        }
        
        function formatButtonCell(data) {
            if (data.typeNibble === 0x00) return '--';
            
            const typeMap = { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' };
            const type = typeMap[data.typeNibble] || '??';
            const ch = chDisp(data.channel - 1);
            const mode = data.mode ? 'T' : 'M';
            
            if (data.typeNibble === 0x40) {
                return `${ch}:${type} [${mode}]`;
            }
            
            return `${ch}:${type} ${data.cc} [${mode}]`;
        }
        
        function createOverviewSection(title, table, colorClass = '') {
            const section = document.createElement('div');
            section.className = 'overview-section';
            
            const header = document.createElement('h3');
            header.className = 'overview-section-title' + (colorClass ? ' ' + colorClass : '');
            header.textContent = title;
            section.appendChild(header);
            
            section.appendChild(table);
            return section;
        }
        
        function createEncoderOverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row (clickable to edit)
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<td onclick="showGroupNameEditor(${currentSetup}, ${g})" title="Click to edit">${renderGroupNameWithWarning(currentSetup, g)}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Data rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">Enc ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getEncoderData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = 'encoder';
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType('encoder', g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === 'encoder' && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    // Check if this cell is QP source
                    if (isQuickPasteSource('encoder', g, i)) {
                        cell.classList.add('qp-source');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatEncoderCell(data)}</div>`;
                    cell.onclick = () => { 
                        if (!handleQuickPasteCellClick('encoder', g, i)) {
                            setSelection('encoder', g, i); 
                        }
                    };
                    cell.ondblclick = () => {
                        if (!handleQuickPasteDoubleClick('encoder', g, i)) {
                            jumpToFocusedView('encoder', g, i);
                        }
                    };
                    cell.onmouseenter = () => handleOverviewMouseEnter('encoder', g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, 'encoder', g, i);
                    cell.title = createEncoderTooltip(data, g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        function createButtonOverviewTable(type, getData, prefix) {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row (clickable to edit)
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<td onclick="showGroupNameEditor(${currentSetup}, ${g})" title="Click to edit">${renderGroupNameWithWarning(currentSetup, g)}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Data rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">${prefix} ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = type;
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType(type, g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === type && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    // Check if this cell is QP source
                    if (isQuickPasteSource(type, g, i)) {
                        cell.classList.add('qp-source');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatButtonCell(data)}</div>`;
                    cell.onclick = () => { 
                        if (!handleQuickPasteCellClick(type, g, i)) {
                            setSelection(type, g, i); 
                        }
                    };
                    cell.ondblclick = () => {
                        if (!handleQuickPasteDoubleClick(type, g, i)) {
                            jumpToFocusedView(type, g, i);
                        }
                    };
                    cell.onmouseenter = () => handleOverviewMouseEnter(type, g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, type, g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        function createFaderOverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row (clickable to edit)
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<td onclick="showGroupNameEditor(${currentSetup}, ${g})" title="Click to edit">${renderGroupNameWithWarning(currentSetup, g)}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Fader 1-8 rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">Fad ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getFaderData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = 'fader';
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType('fader', g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === 'fader' && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    // Check if this cell is QP source
                    if (isQuickPasteSource('fader', g, i)) {
                        cell.classList.add('qp-source');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatFaderCell(data)}</div>`;
                    cell.onclick = () => { 
                        if (!handleQuickPasteCellClick('fader', g, i)) {
                            setSelection('fader', g, i); 
                        }
                    };
                    cell.ondblclick = () => {
                        if (!handleQuickPasteDoubleClick('fader', g, i)) {
                            jumpToFocusedView('fader', g, i);
                        }
                    };
                    cell.onmouseenter = () => handleOverviewMouseEnter('fader', g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, 'fader', g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        // Fader 9 separate table
        function createFader9OverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th></th>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerRow.innerHTML += `<th class="group-header">Group ${g + 1}<br><span class="group-name">${name}</span></th>`;
            }
            table.appendChild(headerRow);
            
            // Fader 9 row
            const f9row = document.createElement('tr');
            f9row.innerHTML = `<th class="row-header">Fad 9</th>`;
            
            for (let g = 0; g < 8; g++) {
                const data = getFader9Data(currentSetup, g);
                const cell = document.createElement('td');
                
                // Add data attributes for keyboard navigation
                cell.dataset.type = 'fader9';
                cell.dataset.group = g;
                cell.dataset.index = 0;
                
                // Check for conflicts
                const conflictType = getControlConflictType('fader9', g, 0);
                if (conflictType === 'concurrent') {
                    cell.className = 'conflict';
                } else if (conflictType === 'mutuallyExclusive') {
                    cell.className = 'conflict-dim';
                }
                
                // Check if this cell is selected
                if (selection.mode !== 'none' && 
                    selection.controlType === 'fader9' && 
                    selection.group === g) {
                    cell.classList.add('selected');
                }
                
                // Check if this cell is QP source
                if (isQuickPasteSource('fader9', g, 0)) {
                    cell.classList.add('qp-source');
                }
                
                // Fader 9 only has CC type
                const ch = chDisp(data.channel - 1);
                const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                cell.innerHTML = `<div class="overview-cell">${warningIcon}${ch}:CC ${data.cc}</div>`;
                cell.onclick = () => { 
                    if (!handleQuickPasteCellClick('fader9', g, 0)) {
                        setSelection('fader9', g, 0); 
                    }
                };
                cell.ondblclick = () => {
                    if (!handleQuickPasteDoubleClick('fader9', g, 0)) {
                        jumpToFocusedView('fader9', g, 0);
                    }
                };
                cell.onmouseenter = () => handleOverviewMouseEnter('fader9', g, 0);
                cell.oncontextmenu = (e) => showContextMenu(e, 'fader9', g, 0);
                f9row.appendChild(cell);
            }
            
            table.appendChild(f9row);
            
            return table;
        }
        
        function createEncoderTooltip(data, group, index) {
            const types = ['CCr1', 'CCr2', 'CCAb', 'PrGC', 'CCAh', 'Pbnd', 'AFtt'];
            const accs = ['Acc0', 'Acc1', 'Acc2', 'Acc3'];
            const disps = ['OFF', 'Std', 'bPoL'];
            
            return `Encoder ${index + 1}, Group ${group + 1}
Channel: ${data.channel}
Type: ${types[data.type] || '?'}
CC#: ${data.cc}
Min: ${data.min}, Max: ${data.max}
Acc: ${accs[data.acc] || '?'}, Display: ${disps[data.display] || '?'}`;
        }
        
        function jumpToFocusedView(type, group, index) {
            // Switch to the appropriate group
            if (type === 'encoder' || type === 'push') {
                selectEncoderGroup(group);
            } else {
                selectFaderGroup(group);
            }
            
            // Switch to focused view
            setView('focused');
            
            // Scroll to the control (after view renders)
            setTimeout(() => {
                const cards = document.querySelectorAll('.control-card');
                // Find the right card based on type and index
                // This is approximate - we'd need better selectors in production
            }, 100);
        }
        
        // ============================================================
        // Update Functions (with undo support)
        // ============================================================
        
        function updateEncoder(idx, param, value) {
            const data = getEncoderData(currentSetup, encoderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return; // No change
            
            data[param] = after;
            setEncoderData(currentSetup, encoderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'encoder',
                setupIdx: currentSetup,
                group: encoderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updatePush(idx, param, value) {
            const data = getPushData(currentSetup, encoderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setPushData(currentSetup, encoderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'push',
                setupIdx: currentSetup,
                group: encoderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateGreen(idx, param, value) {
            const data = getGreenData(currentSetup, faderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setGreenData(currentSetup, faderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'green',
                setupIdx: currentSetup,
                group: faderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateFader(idx, param, value) {
            const data = getFaderData(currentSetup, faderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setFaderData(currentSetup, faderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'fader',
                setupIdx: currentSetup,
                group: faderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateFader9(param, value) {
            const data = getFader9Data(currentSetup, faderGroup);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setFader9Data(currentSetup, faderGroup, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'fader9',
                setupIdx: currentSetup,
                group: faderGroup,
                index: 0,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        // ============================================================
        // Navigation
        // ============================================================
        
        function selectSetup(idx) {
            currentSetup = parseInt(idx);
            updateGroupNames();
            updateLibrarySourceBadge();
            // Rebuild conflict map for new setup
            rebuildConflictMap();
            renderCurrentView();
        }
        
        function updateLibrarySourceBadge() {
            const badge = document.getElementById('librarySourceBadge');
            if (!badge) return;
            
            const configName = librarySourceMap.get(currentSetup);
            if (configName) {
                badge.textContent = configName;
                badge.style.display = 'inline-flex';
            } else {
                badge.style.display = 'none';
            }
        }
        
        function toggleLinkGroups(checked) {
            linkGroups = checked;
            // If linking and groups are different, sync fader to encoder
            if (linkGroups && encoderGroup !== faderGroup) {
                faderGroup = encoderGroup;
                updateGroupTabs('faderGroupTabs', faderGroup);
                document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, faderGroup);
                renderCurrentView();
            }
        }
        
        function selectEncoderGroup(idx, fromLink = false) {
            encoderGroup = idx;
            updateGroupTabs('encoderGroupTabs', idx);
            document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, idx);
            
            // If linked and not already called from fader, update fader too
            if (linkGroups && !fromLink) {
                faderGroup = idx;
                updateGroupTabs('faderGroupTabs', idx);
                document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, idx);
            }
            
            renderCurrentView();
        }
        
        function selectFaderGroup(idx, fromLink = false) {
            faderGroup = idx;
            updateGroupTabs('faderGroupTabs', idx);
            document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, idx);
            
            // If linked and not already called from encoder, update encoder too
            if (linkGroups && !fromLink) {
                encoderGroup = idx;
                updateGroupTabs('encoderGroupTabs', idx);
                document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, idx);
            }
            
            renderCurrentView();
        }
        
        function updateGroupTabs(containerId, activeIdx) {
            const tabs = document.getElementById(containerId).querySelectorAll('.group-tab');
            tabs.forEach((tab, i) => {
                tab.classList.toggle('active', i === activeIdx);
            });
        }
        
        function updateGroupNames() {
            document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, encoderGroup);
            document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, faderGroup);
        }
        
        function setView(view) {
            currentView = view;
            document.getElementById('focusedViewBtn').classList.toggle('active', view === 'focused');
            document.getElementById('overviewBtn').classList.toggle('active', view === 'overview');
            
            // Clear selection when leaving overview
            if (view === 'focused') {
                clearSelection();
            }
            
            renderCurrentView();
        }
        
        function renderCurrentView() {
            if (!rawBuffer) return;
            if (currentView === 'focused') {
                renderFocusedView();
            } else {
                renderOverview();
            }
        }
        
        // ============================================================
        // File Operations
        // ============================================================
        
        document.getElementById('sysexInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const buffer = await file.arrayBuffer();
                const bytes = new Uint8Array(buffer);
                
                // Log the load attempt
                logAction(Action.LOAD_SYSEX, { filename: file.name, bytes: bytes.length });
                
                // Validate using unified function
                const validation = validateSyx(bytes);
                if (!validation.valid) {
                    showError(validation.code, validation.message, validation.detail);
                    return;
                }
                
                rawBuffer = bytes;
                sectionIndex = buildIndex(rawBuffer);
                
                // Initialize factory templates from this SysEx
                initFactoryTemplates();
                
                // Store original for reset
                originalBuffer = new Uint8Array(rawBuffer);
                
                // Clear previous session - new import is clean slate
                clearSession();
                
                // Clear undo/redo stacks
                undoStack.length = 0;
                redoStack.length = 0;
                updateUndoRedoUI();
                
                // Enable UI
                document.getElementById('setupSelect').disabled = false;
                document.getElementById('setupSelect').value = '0';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('exportJsonBtn').disabled = false;
                document.getElementById('manageSetupsBtn').disabled = false;
                document.getElementById('libraryBtn').disabled = false;
                updateImportDropdownState();
                updateLibrarySourceBadge();
                
                currentSetup = 0;
                encoderGroup = 0;
                faderGroup = 0;
                isModified = false;
                dirtyBanks.clear();
                
                // Clear setup labels on fresh import
                setupLabels.clear();
                librarySourceMap.clear();
                differsFromFactoryCache.clear();
                
                // Auto-label setups that match factory Ableton configs
                checkAllAbletonLabels();
                
                updateGroupTabs('encoderGroupTabs', 0);
                updateGroupTabs('faderGroupTabs', 0);
                updateGroupNames();
                updateStatus('loaded', `Loaded: ${file.name}`);
                document.getElementById('fileInfo').textContent = `${file.name} (${rawBuffer.length.toLocaleString()} bytes)`;
                
                // Build initial conflict map
                rebuildConflictMap();
                
                // Refresh all setup-related UI
                const allSetups = Array.from({ length: 18 }, (_, i) => i);
                afterSetupStateMutation(allSetups);
                
                renderFocusedView();
            } catch (err) {
                showError(ErrorCode.FILE_READ_FAILED, 'Error loading file: ' + err.message);
            }
            
            e.target.value = '';
        });
        
        function exportSysEx() {
            if (!rawBuffer) return;
            
            promptFilename('uc4_edited.syx', 'Export SysEx', (filename) => {
                // Recalculate all dirty checksums
                // dirtyBanks contains "${setupIdx}-${actualSecId}-${actualBank}"
                for (const key of dirtyBanks) {
                    const [, secId, bank] = key.split('-').map(Number);
                    const sec = sectionIndex[secId];
                    if (sec && sec[bank]) {
                        recalcBankChecksum(rawBuffer, sec[bank].dataOffset);
                    }
                }
                dirtyBanks.clear();
                
                const blob = new Blob([rawBuffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Clear session - user saved their work
                clearSession();
                isModified = false;
                updateStatus('loaded', 'Exported successfully');
                showToast('SysEx exported', 'success');
            });
        }
        
        function exportJSON() {
            if (!rawBuffer) return;
            
            promptFilename('uc4_config.json', 'Export JSON', (filename) => {
                // Build setupLabels object from Map
                const labelsObj = {};
                for (const [idx, label] of setupLabels) {
                    labelsObj[idx.toString()] = label;
                }
                
                const data = {
                    format: 'uc4-editor',
                    version: '1.1',
                    exported: new Date().toISOString(),
                    setupLabels: Object.keys(labelsObj).length > 0 ? labelsObj : undefined,
                    setups: []
                };
                
                for (let s = 0; s < NUM_SETUPS; s++) {
                    const setup = {
                        index: s,
                        groups: []
                    };
                    
                    for (let g = 0; g < NUM_GROUPS; g++) {
                        const group = {
                            index: g,
                            name: getGroupName(s, g),
                            encoders: [],
                            pushButtons: [],
                            greenButtons: [],
                            faders: [],
                            fader9: getFader9Data(s, g)
                        };
                        
                        for (let i = 0; i < 8; i++) {
                            group.encoders.push(getEncoderData(s, g, i));
                            group.pushButtons.push(getPushData(s, g, i));
                            group.greenButtons.push(getGreenData(s, g, i));
                            group.faders.push(getFaderData(s, g, i));
                        }
                        
                        setup.groups.push(group);
                    }
                    
                    data.setups.push(setup);
                }
                
                // Clean up undefined setupLabels
                if (!data.setupLabels) delete data.setupLabels;
                
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast('JSON exported', 'success');
            });
        }
        
        document.getElementById('jsonInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!rawBuffer) {
                alert('Please import a SysEx file first to use as a base.');
                e.target.value = '';
                return;
            }
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (data.format !== 'uc4-editor') {
                    alert('Invalid JSON format. Expected UC4 Editor export.');
                    return;
                }
                
                // Import setup labels if present (v1.1+)
                if (data.setupLabels && typeof data.setupLabels === 'object') {
                    setupLabels.clear();
                    librarySourceMap.clear();
                    for (const [key, value] of Object.entries(data.setupLabels)) {
                        const idx = parseInt(key, 10);
                        if (!isNaN(idx) && idx >= 0 && idx < 18 && typeof value === 'string') {
                            // Sanitize label (max 12 chars, valid chars only)
                            const sanitized = value.slice(0, 12).replace(/[^a-zA-Z0-9 \-_]/g, '');
                            if (sanitized) {
                                setupLabels.set(idx, sanitized);
                            }
                        }
                    }
                }
                
                // Apply JSON data to buffer
                for (const setup of data.setups) {
                    for (const group of setup.groups) {
                        for (let i = 0; i < 8; i++) {
                            if (group.encoders[i]) setEncoderData(setup.index, group.index, i, group.encoders[i]);
                            if (group.pushButtons[i]) setPushData(setup.index, group.index, i, group.pushButtons[i]);
                            if (group.greenButtons[i]) setGreenData(setup.index, group.index, i, group.greenButtons[i]);
                            if (group.faders[i]) setFaderData(setup.index, group.index, i, group.faders[i]);
                        }
                        if (group.fader9) setFader9Data(setup.index, group.index, group.fader9);
                        
                        // Import group name if present (Phase 3b per spec)
                        if (group.name && typeof group.name === 'string') {
                            const result = stringToGroupNameValues(group.name);
                            if (result.error) {
                                // Detailed error message per spec requirements
                                console.warn(
                                    `JSON Import Error: Setup ${setup.index + 1}, Group ${group.index + 1}: ` +
                                    `${result.error} in name "${group.name}"`
                                );
                                // Don't fail entire import, just skip this name
                            } else {
                                setGroupName(setup.index, group.index, result.values);
                            }
                        }
                    }
                }
                
                // Invalidate all diff caches after import
                differsFromFactoryCache.clear();
                dirtySinceLoad = true;
                
                updateStatus('modified', 'JSON imported - changes pending');
                updateGroupNames();
                updateSetupDropdownLabels();
                renderCurrentView();
            } catch (err) {
                alert('Error loading JSON: ' + err.message);
                console.error(err);
            }
            
            e.target.value = '';
        });
        
        // ============================================================
        // Status
        // ============================================================
        
        function markModified() {
            isModified = true;
            updateStatus('modified', 'Modified - remember to export');
            scheduleAutoSave();
        }
        
        function updateStatus(state, text) {
            const dot = document.getElementById('statusDot');
            const txt = document.getElementById('statusText');
            
            dot.className = 'status-dot ' + state;
            txt.textContent = text;
        }
        
        // ============================================================
        // Toast Notifications
        // ============================================================
        
        function showToast(message, type = 'info', options = {}) {
            const { errorCode, showDiagnostics = false } = options;
            // Note: detail is captured in lastError via showError() and included in copied diagnostics.
            // It is intentionally not displayed in the toast UI.
            
            // Normalize message to string (could be Error object, etc.)
            const safeMsg = (typeof message === 'string') ? message : String(message);
            
            const container = document.getElementById('toastContainer');
            if (!container) {
                // Fallback if DOM not ready
                console.error('Toast container missing:', safeMsg);
                return;
            }
            
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            
            // Build content - include error code in display for easy reporting
            const isErrorWithDiag = showDiagnostics && type === 'error';
            const displayMessage = errorCode ? `[${errorCode}] ${safeMsg}` : safeMsg;
            
            let html = `<span class="toast-message">${escapeHtml(displayMessage)}</span>`;
            
            if (isErrorWithDiag) {
                html += `<button class="toast-copy-btn" aria-label="Copy diagnostics" title="Copy diagnostics">[copy]</button>`;
                html += `<button class="toast-close-btn" aria-label="Dismiss error" title="Dismiss">X</button>`;
            }
            
            toast.innerHTML = html;
            
            // Copy diagnostics handler
            if (isErrorWithDiag) {
                const copyBtn = toast.querySelector('.toast-copy-btn');
                const closeBtn = toast.querySelector('.toast-close-btn');
                
                if (copyBtn) copyBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const diag = collectDiagnostics();
                    
                    const ok = await copyText(formatDiagnosticsForCopy(diag));
                    
                    // Always log copy attempt (success or failure)
                    logAction(Action.COPY, { target: 'diagnostics', ok });
                    
                    copyBtn.textContent = ok ? 'OK' : 'X';
                    
                    // Re-enable after 1.5s so user can copy again if needed
                    setTimeout(() => { copyBtn.textContent = '[copy]'; }, 1500);
                });
                
                if (closeBtn) closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toast.remove();
                });
            }
            
            container.appendChild(toast);
            
            // Error toasts with diagnostics are persistent (user must dismiss)
            // Other toasts auto-dismiss after 3 seconds
            if (!isErrorWithDiag) {
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }
        }
        
        // Convenience wrapper for errors
        function showError(code, message, detail = null) {
            const errObj = makeErr(code, message, detail);
            recordAndLogErrorShown(errObj);  // Single place for recording + logging
            showToast(message, 'error', { 
                errorCode: code, 
                showDiagnostics: true 
            });
        }
        
        // ============================================================
        // Filename Prompt Dialog
        // ============================================================
        
        function promptFilename(defaultName, title, onConfirm) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'filenameModal';
            
            // Extract extension from default name
            const lastDot = defaultName.lastIndexOf('.');
            const ext = lastDot > 0 ? defaultName.slice(lastDot) : '';
            const baseName = lastDot > 0 ? defaultName.slice(0, lastDot) : defaultName;
            
            overlay.innerHTML = `
                <div class="filename-dialog">
                    <h3>${title}</h3>
                    <div class="filename-input-row">
                        <input type="text" id="filenameInput" value="${baseName}" spellcheck="false">
                        <span class="filename-ext">${ext}</span>
                    </div>
                    <div class="filename-actions">
                        <button class="btn" id="filenameCancelBtn">Cancel</button>
                        <button class="btn primary" id="filenameConfirmBtn">Export</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            const input = document.getElementById('filenameInput');
            const confirmBtn = document.getElementById('filenameConfirmBtn');
            const cancelBtn = document.getElementById('filenameCancelBtn');
            
            // Select the base name for easy editing
            input.focus();
            input.select();
            
            function close() {
                overlay.remove();
            }
            
            function confirm() {
                let filename = input.value.trim();
                if (!filename) filename = baseName;
                // Sanitize filename
                filename = filename.replace(/[\/\\:*?"<>|]/g, '-').replace(/[\x00-\x1F]/g, '');
                close();
                onConfirm(filename + ext);
            }
            
            confirmBtn.onclick = confirm;
            cancelBtn.onclick = close;
            
            overlay.onclick = (e) => {
                if (e.target === overlay) close();
            };
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    confirm();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    close();
                }
            });
        }
        
        // ============================================================
        // Group Name Editor Modal (per UC4_GROUP_NAME_EDITING_SPEC_v2)
        // ============================================================
        
        function showGroupNameEditor(setupIdx, group) {
            const data = getGroupNameData(setupIdx, group);
            const currentDisplay = data ? data.display : `GrP${group + 1}`;
            const hasNonCanonical = data?.hasNonCanonical || false;
            const originalValues = data?.values || null;  // Store for comparison
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay';
            dialog.id = 'groupNameModal';
            dialog.dataset.originalValues = JSON.stringify(originalValues);  // Stash for save comparison
            dialog.dataset.setupIdx = setupIdx;
            dialog.dataset.group = group;
            
            // Trim trailing spaces for input field (trim-right view)
            const inputValue = currentDisplay.replace(/\s+$/, '');
            
            dialog.innerHTML = `
                <div class="modal-dialog group-name-dialog">
                    <h3>Edit Group ${group + 1} Name</h3>
                    <p class="info">Setup ${setupIdx + 1}</p>
                    
                    ${hasNonCanonical ? '<p class="warning">âš  Contains non-standard codes; editor will preserve them unless you overwrite the name.</p>' : ''}
                    
                    <input type="text" 
                           id="groupNameInput" 
                           value="${escapeHtml(inputValue)}"
                           maxlength="4"
                           autocomplete="off"
                           spellcheck="false">
                    
                    <p class="preview">UC4 will show: <span id="groupNamePreview">${escapeHtml(currentDisplay).replace(/ /g, 'Â·')}</span></p>
                    
                    <p class="hint">Valid: 0-9 A b C d E F G H I J L n O t P S r U Y - _ space</p>
                    <p class="error" id="groupNameError"></p>
                    
                    <div class="modal-actions">
                        <button class="btn" onclick="closeGroupNameDialog()">Cancel</button>
                        <button class="btn btn-primary" id="groupNameSaveBtn" onclick="saveGroupNameFromDialog()">Save</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            const input = document.getElementById('groupNameInput');
            input.focus();
            input.select();
            
            // Live validation
            input.addEventListener('input', validateGroupNameInput);
            
            // Keyboard shortcuts
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !document.getElementById('groupNameSaveBtn').disabled) {
                    saveGroupNameFromDialog();
                } else if (e.key === 'Escape') {
                    closeGroupNameDialog();
                }
            });
            
            // Click outside to close
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    closeGroupNameDialog();
                }
            });
            
            validateGroupNameInput();
        }
        
        function validateGroupNameInput() {
            const input = document.getElementById('groupNameInput');
            const preview = document.getElementById('groupNamePreview');
            const error = document.getElementById('groupNameError');
            const saveBtn = document.getElementById('groupNameSaveBtn');
            
            const result = stringToGroupNameValues(input.value);
            
            if (result.error) {
                error.textContent = result.error;
                saveBtn.disabled = true;
                preview.textContent = '----';
            } else {
                error.textContent = '';
                saveBtn.disabled = false;
                // Show what UC4 will actually display (Â· for spaces)
                preview.textContent = result.display.replace(/ /g, 'Â·');
            }
        }
        
        function saveGroupNameFromDialog() {
            const modal = document.getElementById('groupNameModal');
            const input = document.getElementById('groupNameInput');
            const setupIdx = parseInt(modal.dataset.setupIdx);
            const group = parseInt(modal.dataset.group);
            const originalValues = JSON.parse(modal.dataset.originalValues);
            
            const result = stringToGroupNameValues(input.value);
            
            if (result.error) {
                showToast(result.error, 'error');
                return;
            }
            
            // Handle read failure case (Rule 7: Read failure handling)
            if (originalValues === null) {
                // Re-read to see if it's still failing
                const reread = getGroupNameData(setupIdx, group);
                if (reread === null) {
                    showToast('Cannot save: unable to read group name bytes', 'error');
                    return;
                }
                // Read succeeded now, proceed with comparison against fresh data
                const currentValues = reread.values;
                const bytesChanged = result.values.some((v, i) => v !== currentValues[i]);
                if (!bytesChanged) {
                    closeGroupNameDialog();
                    return;
                }
                // Apply with fresh originalValues for undo
                changeGroupNameWithUndo(setupIdx, group, result.values);
            } else {
                // BYTE-BASED COMPARISON: Check if values actually changed
                const newValues = result.values;
                const bytesChanged = newValues.some((v, i) => v !== originalValues[i]);
                
                if (!bytesChanged) {
                    // No-op: bytes unchanged, just close without undo action
                    closeGroupNameDialog();
                    return;
                }
                
                // Bytes changed: apply with undo
                changeGroupNameWithUndo(setupIdx, group, result.values);
            }
            
            closeGroupNameDialog();
            
            // Update all UI locations
            renderCurrentView();
            updateGroupNameDisplays();
            
            showToast(`Group ${group + 1} renamed`, 'success');
        }
        
        function closeGroupNameDialog() {
            const modal = document.getElementById('groupNameModal');
            if (modal) {
                modal.remove();
            }
            // Note: Cancel does NOT write any bytes (R9 compliance)
        }
        
        // Update group name displays in focused view nav
        function updateGroupNameDisplays() {
            const encoderGroupNameEl = document.getElementById('encoderGroupName');
            const faderGroupNameEl = document.getElementById('faderGroupName');
            
            if (encoderGroupNameEl) {
                encoderGroupNameEl.textContent = getGroupName(currentSetup, encoderGroup);
            }
            if (faderGroupNameEl) {
                faderGroupNameEl.textContent = getGroupName(currentSetup, faderGroup);
            }
        }
        
        // ============================================================
        // Undo/Redo System
        // ============================================================
        
        function recordUndo(action) {
            if (!action.description) {
                action.description = generateDescription(action);
            }
            action.timestamp = Date.now();
            
            undoStack.push(action);
            
            // Clear redo stack (new action invalidates redo history)
            redoStack.length = 0;
            
            // Trim if over limit
            while (undoStack.length > MAX_UNDO) {
                undoStack.shift();
            }
            
            updateUndoRedoUI();
        }
        
        function recordUndoCoalesced(action) {
            const last = undoStack[undoStack.length - 1];
            
            // Check if we should coalesce with previous action
            if (last && 
                last.type === 'value' &&
                action.type === 'value' &&
                last.controlType === action.controlType &&
                last.setupIdx === action.setupIdx &&
                last.group === action.group &&
                last.index === action.index &&
                last.param === action.param &&
                (Date.now() - last.timestamp) < COALESCE_WINDOW) {
                
                // Update the existing action's 'after' value
                last.after = action.after;
                last.timestamp = Date.now();
                // Keep original 'before' value
                return;
            }
            
            // Otherwise record as new action
            recordUndo(action);
        }
        
        function generateDescription(action) {
            const formatControlName = (type, group, index) => {
                const g = group + 1;
                const i = index + 1;
                switch (type) {
                    case 'encoder': return `Encoder G${g}.${i}`;
                    case 'push': return `Push G${g}.${i}`;
                    case 'green': return `Green G${g}.${i}`;
                    case 'fader': return `Fader G${g}.${i}`;
                    case 'fader9': return `Fader9 G${g}`;
                    default: return `${type} G${g}.${i}`;
                }
            };
            
            switch (action.type) {
                case 'value':
                    return `Change ${formatControlName(action.controlType, action.group, action.index)} ${action.param}`;
                case 'control':
                    return `Update ${formatControlName(action.controlType, action.group, action.index)}`;
                case 'batch':
                    return action.description || 'Batch operation';
                default:
                    return 'Unknown action';
            }
        }
        
        function undo() {
            if (previewMode) {
                showToast('Undo not available in preview', 'info');
                return;
            }
            if (undoStack.length === 0) return;
            
            const action = undoStack.pop();
            
            // Apply reverse
            applyAction(action, true);
            
            redoStack.push(action);
            updateUndoRedoUI();
            renderCurrentView();
        }
        
        function redo() {
            if (previewMode) {
                showToast('Redo not available in preview', 'info');
                return;
            }
            if (redoStack.length === 0) return;
            
            const action = redoStack.pop();
            
            // Apply forward
            applyAction(action, false);
            
            undoStack.push(action);
            updateUndoRedoUI();
            renderCurrentView();
        }
        
        function confirmReset() {
            const hasOriginal = originalBuffer !== null;
            const message = hasOriginal 
                ? 'Reset all changes back to the imported SysEx?\n\nThis will discard all modifications.'
                : 'Load default UC4 configuration?\n\nNo SysEx was imported, so this will load factory defaults.';
            
            if (confirm(message)) {
                performReset();
            }
        }
        
        function performReset() {
            if (originalBuffer) {
                // Reset to imported SysEx
                rawBuffer = new Uint8Array(originalBuffer);
                sectionIndex = buildIndex(rawBuffer);
                
                // Re-initialize factory templates
                initFactoryTemplates();
            } else {
                // Load default - create a basic UC4 config
                // For now, just show a message since we don't have a default template
                showToast('No SysEx imported - import a SysEx file first', 'warning');
                return;
            }
            
            // Clear undo/redo stacks
            undoStack.length = 0;
            redoStack.length = 0;
            updateUndoRedoUI();
            
            // Reset state
            isModified = false;
            dirtyBanks.clear();
            
            // Clear Quick Paste source
            quickPaste.source = null;
            quickPaste.pasteCount = 0;
            
            // Clear setup labels (reset clears everything)
            setupLabels.clear();
            librarySourceMap.clear();
            differsFromFactoryCache.clear();
            
            // Auto-label setups that match factory Ableton configs
            checkAllAbletonLabels();
            
            // Rebuild conflict map
            rebuildConflictMap();
            
            // Refresh all setup-related UI
            const allSetups = Array.from({ length: 18 }, (_, i) => i);
            afterSetupStateMutation(allSetups);
            
            // Re-render
            renderCurrentView();
            updateStatus('loaded', 'Reset to imported SysEx');
            showToast('Reset to imported SysEx', 'success');
        }
        
        function applyAction(action, reverse) {
            suppressModified = true;
            try {
                switch (action.type) {
                    case 'value': {
                        const value = reverse ? action.before : action.after;
                        applyValueChange(action, value);
                        break;
                    }
                        
                    case 'control': {
                        const data = reverse ? action.before : action.after;
                        setControlDataSilent(action.controlType, action.setupIdx, action.group, action.index, data);
                        break;
                    }
                        
                    case 'batch': {
                        for (const subAction of action.actions) {
                            const subData = reverse ? subAction.before : subAction.after;
                            setControlDataSilent(subAction.controlType, subAction.setupIdx, subAction.group, subAction.index, subData);
                        }
                        break;
                    }
                    
                    case 'group-name': {
                        const values = reverse ? action.beforeValues : action.afterValues;
                        setGroupName(action.setupIdx, action.group, values);
                        break;
                    }
                    
                    // Setup Manager actions
                    case 'setup-copy': {
                        const snapshots = reverse ? action.beforeSnapshots : action.afterSnapshots;
                        const labels = reverse ? action.labelsBefore : action.labelsAfter;
                        for (const idx of action.destIndices) {
                            restoreSetupSnapshot(idx, snapshots[idx]);
                            if (labels[idx]) {
                                setupLabels.set(idx, labels[idx]);
                            } else {
                                setupLabels.delete(idx);
                            }
                        }
                        invalidateDiffCache(action.destIndices);
                        afterSetupStateMutation(action.destIndices);
                        break;
                    }
                    
                    case 'setup-swap': {
                        const snapshots = reverse ? action.beforeSnapshots : action.afterSnapshots;
                        const labels = reverse ? action.labelsBefore : action.labelsAfter;
                        restoreSetupSnapshot(action.idxA, snapshots[action.idxA]);
                        restoreSetupSnapshot(action.idxB, snapshots[action.idxB]);
                        if (labels[action.idxA]) {
                            setupLabels.set(action.idxA, labels[action.idxA]);
                        } else {
                            setupLabels.delete(action.idxA);
                        }
                        if (labels[action.idxB]) {
                            setupLabels.set(action.idxB, labels[action.idxB]);
                        } else {
                            setupLabels.delete(action.idxB);
                        }
                        invalidateDiffCache([action.idxA, action.idxB]);
                        afterSetupStateMutation([action.idxA, action.idxB]);
                        break;
                    }
                    
                    case 'setup-reset-factory': {
                        const snapshots = reverse ? action.beforeSnapshots : action.afterSnapshots;
                        const labels = reverse ? action.labelsBefore : action.labelsAfter;
                        for (const idx of action.indices) {
                            restoreSetupSnapshot(idx, snapshots[idx]);
                            if (labels[idx]) {
                                setupLabels.set(idx, labels[idx]);
                            } else {
                                setupLabels.delete(idx);
                            }
                        }
                        invalidateDiffCache(action.indices);
                        afterSetupStateMutation(action.indices);
                        break;
                    }
                    
                    case 'setup-import': {
                        const snapshot = reverse ? action.beforeSnapshot : action.afterSnapshot;
                        const label = reverse ? action.labelBefore : action.labelAfter;
                        restoreSetupSnapshot(action.targetIdx, snapshot);
                        if (label) {
                            setupLabels.set(action.targetIdx, label);
                        } else {
                            setupLabels.delete(action.targetIdx);
                        }
                        invalidateDiffCache([action.targetIdx]);
                        afterSetupStateMutation([action.targetIdx]);
                        break;
                    }
                    
                    case 'library-import': {
                        const snapshots = reverse ? action.beforeSnapshots : action.afterSnapshots;
                        for (const item of snapshots) {
                            restoreSetupSnapshot(item.index, item.snapshot);
                            if (item.label) {
                                setupLabels.set(item.index, item.label);
                            } else {
                                setupLabels.delete(item.index);
                            }
                        }
                        invalidateDiffCache(action.affectedSlots);
                        afterSetupStateMutation(action.affectedSlots);
                        break;
                    }
                    
                    case 'setup-label': {
                        const label = reverse ? action.labelBefore : action.labelAfter;
                        if (label) {
                            setupLabels.set(action.idx, label);
                        } else {
                            setupLabels.delete(action.idx);
                        }
                        afterSetupStateMutation([action.idx]);
                        break;
                    }
                }
            } finally {
                suppressModified = false;
            }
            
            // After any change
            markModified();
            
            // Only rebuild conflicts if action affects routing params
            if (actionAffectsConflicts(action)) {
                scheduleConflictRebuild();
            }
        }
        
        function applyValueChange(action, value) {
            const getData = getControlDataByType(action.controlType);
            const setData = setControlDataByType(action.controlType);
            
            if (!getData || !setData) return;
            
            const data = getData(action.setupIdx, action.group, action.index);
            data[action.param] = value;
            setData(action.setupIdx, action.group, action.index, data);
        }
        
        function getControlDataByType(type) {
            switch (type) {
                case 'encoder': return getEncoderData;
                case 'push': return getPushData;
                case 'green': return getGreenData;
                case 'fader': return getFaderData;
                case 'fader9': return (s, g, i) => getFader9Data(s, g);
                default: return null;
            }
        }
        
        function setControlDataByType(type) {
            switch (type) {
                case 'encoder': return setEncoderData;
                case 'push': return setPushData;
                case 'green': return setGreenData;
                case 'fader': return setFaderData;
                case 'fader9': return (s, g, i, d) => setFader9Data(s, g, d);
                default: return null;
            }
        }
        
        // Silent setters that don't trigger markModified (for undo/redo)
        function setControlDataSilent(type, setupIdx, group, index, data) {
            const setData = setControlDataByType(type);
            if (!setData) return;

            suppressModified = true;
            try {
                setData(setupIdx, group, index, data);
            } finally {
                suppressModified = false;
            }
        }
        
        function actionAffectsConflicts(action) {
            if (action.type === 'value') {
                return CONFLICT_PARAMS.has(action.param);
            }
            // control and batch actions are conservative - always rebuild
            return true;
        }
        
        function updateUndoRedoUI() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            // Disable in preview mode
            if (previewMode) {
                undoBtn.disabled = true;
                redoBtn.disabled = true;
                undoBtn.title = 'Undo not available in preview';
                redoBtn.title = 'Redo not available in preview';
                return;
            }
            
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            
            // Update tooltips
            if (undoStack.length > 0) {
                undoBtn.title = `Undo: ${undoStack[undoStack.length - 1].description}`;
            } else {
                undoBtn.title = 'Undo (Ctrl+Z)';
            }
            
            if (redoStack.length > 0) {
                redoBtn.title = `Redo: ${redoStack[redoStack.length - 1].description}`;
            } else {
                redoBtn.title = 'Redo (Ctrl+Y)';
            }
        }
        
        // ============================================================
        // Session Persistence
        // ============================================================
        
        function scheduleAutoSave() {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
                saveSession();
            }, AUTO_SAVE_DELAY);
        }
        
        function saveSession() {
            if (!rawBuffer) return;
            
            try {
                const sessionData = {
                    version: SESSION_VERSION,
                    timestamp: Date.now(),
                    buffer: Array.from(rawBuffer),
                    uiState: {
                        currentSetup,
                        encoderGroup,
                        faderGroup,
                        currentView
                    },
                    dirtyBanks: Array.from(dirtyBanks)
                };
                
                localStorage.setItem(STORAGE_KEY, JSON.stringify(sessionData));
            } catch (e) {
                console.warn('Session save failed:', e);
                if (e.name === 'QuotaExceededError') {
                    showToast('Autosave failed (storage full)', 'error');
                }
            }
        }
        
        function loadSession() {
            try {
                const json = localStorage.getItem(STORAGE_KEY);
                if (!json) return null;
                
                const session = JSON.parse(json);
                
                // Version check
                if (session.version !== SESSION_VERSION) {
                    console.warn('Session version mismatch, discarding');
                    clearSession();
                    return null;
                }
                
                // Convert array to Uint8Array for validation
                if (!session.buffer || !Array.isArray(session.buffer)) {
                    console.warn('Invalid session buffer, discarding');
                    clearSession();
                    return null;
                }
                
                const bytes = new Uint8Array(session.buffer);
                const validation = validateSyx(bytes);
                if (!validation.valid) {
                    console.warn(`Session buffer validation failed: ${validation.message}`);
                    clearSession();
                    return null;
                }
                
                return session;
            } catch (e) {
                console.error('Failed to parse session:', e);
                clearSession();
                return null;
            }
        }
        
        function clearSession() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (e) {
                console.warn('Failed to clear session:', e);
            }
        }
        
        function restoreSession(session) {
            rawBuffer = new Uint8Array(session.buffer);
            sectionIndex = buildIndex(rawBuffer);
            
            // Initialize factory templates from restored SysEx
            initFactoryTemplates();
            
            // Allow Reset to function after restore
            originalBuffer = new Uint8Array(rawBuffer);
            
            // Restore UI state
            currentSetup = session.uiState.currentSetup || 0;
            encoderGroup = session.uiState.encoderGroup || 0;
            faderGroup = session.uiState.faderGroup || 0;
            currentView = session.uiState.currentView || 'focused';
            
            // Restore dirty banks
            dirtyBanks = new Set(session.dirtyBanks || []);
            isModified = dirtyBanks.size > 0;
            
            // Enable UI
            document.getElementById('setupSelect').disabled = false;
            document.getElementById('setupSelect').value = currentSetup.toString();
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('exportJsonBtn').disabled = false;
            document.getElementById('manageSetupsBtn').disabled = false;
            document.getElementById('libraryBtn').disabled = false;
            
            updateGroupTabs('encoderGroupTabs', encoderGroup);
            updateGroupTabs('faderGroupTabs', faderGroup);
            updateGroupNames();
            
            // Build conflict map for restored setup
            rebuildConflictMap();
            
            setView(currentView);
            
            if (isModified) {
                updateStatus('modified', 'Session restored - changes pending');
            } else {
                updateStatus('loaded', 'Session restored');
            }
            
            document.getElementById('fileInfo').textContent = `Restored session (${rawBuffer.length.toLocaleString()} bytes)`;
            
            showToast('Session restored', 'success');
        }
        
        function formatTimeSince(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            const days = Math.floor(hours / 24);
            return `${days} day${days > 1 ? 's' : ''} ago`;
        }
        
        function showRestoreDialog(timeSince, session) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                
                const dirtyCount = session.dirtyBanks ? session.dirtyBanks.length : 0;
                const setupInfo = session.uiState ? `Setup ${(session.uiState.currentSetup || 0) + 1}` : 'Unknown setup';
                
                overlay.innerHTML = `
                    <div class="modal-dialog">
                        <h3>Restore Previous Session?</h3>
                        <p>Found unsaved changes from ${timeSince}.</p>
                        <div class="info">
                            ${setupInfo}<br>
                            ${dirtyCount} modified bank${dirtyCount !== 1 ? 's' : ''}
                        </div>
                        <label>
                            <input type="checkbox" id="skipRestoreCheck">
                            Don't ask again this session
                        </label>
                        <div class="modal-actions">
                            <button class="btn" id="discardBtn">Discard & Load Factory</button>
                            <button class="btn btn-primary" id="restoreBtn">Restore Session</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                document.getElementById('restoreBtn').onclick = () => {
                    overlay.remove();
                    resolve('restore');
                };
                
                document.getElementById('discardBtn').onclick = () => {
                    const skipCheck = document.getElementById('skipRestoreCheck').checked;
                    overlay.remove();
                    if (skipCheck) {
                        resolve('discard-permanently');
                    } else {
                        resolve('discard');
                    }
                };
            });
        }
        
        // ============================================================
        // Conflict Detection
        // ============================================================
        
        function scheduleConflictRebuild() {
            clearTimeout(conflictRebuildTimer);
            conflictRebuildTimer = setTimeout(() => {
                rebuildConflictMap();
                updateConflictUI();
            }, CONFLICT_REBUILD_DELAY);
        }
        
        function rebuildConflictMap() {
            if (!rawBuffer) return;
            
            const result = buildConflictMap(currentSetup);
            conflicts = result;
            
            // Build reverse lookup for quick cell highlighting
            conflictsByControl.clear();
            
            for (const [key, entry] of conflicts.concurrent) {
                for (const ref of entry.refs) {
                    const controlKey = `${ref.type}-${ref.group}-${ref.index}`;
                    if (!conflictsByControl.has(controlKey)) {
                        conflictsByControl.set(controlKey, { concurrent: [], mutuallyExclusive: [] });
                    }
                    conflictsByControl.get(controlKey).concurrent.push(key);
                }
            }
            
            for (const [key, entry] of conflicts.mutuallyExclusive) {
                for (const ref of entry.refs) {
                    const controlKey = `${ref.type}-${ref.group}-${ref.index}`;
                    if (!conflictsByControl.has(controlKey)) {
                        conflictsByControl.set(controlKey, { concurrent: [], mutuallyExclusive: [] });
                    }
                    conflictsByControl.get(controlKey).mutuallyExclusive.push(key);
                }
            }
        }
        
        function buildConflictMap(setupIdx) {
            const assignments = new Map(); // conflictKey -> [controlRef, ...]
            
            // Collect all assignments
            for (let group = 0; group < 8; group++) {
                // Encoders
                for (let i = 0; i < 8; i++) {
                    const data = getEncoderData(setupIdx, group, i);
                    const keys = getEncoderConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'encoder', group, index: i,
                            groupSelector: 'encoder',
                            subtype: ['r1', 'r2', 'CC', 'PC', 'Hi', 'PB', 'AT'][data.type] || 'CC'
                        });
                    }
                }
                
                // Push buttons (same group selector as encoders)
                for (let i = 0; i < 8; i++) {
                    const data = getPushData(setupIdx, group, i);
                    const keys = getButtonConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'push', group, index: i,
                            groupSelector: 'encoder',
                            subtype: { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' }[data.typeNibble] || '?'
                        });
                    }
                }
                
                // Green buttons (fader/button group selector)
                for (let i = 0; i < 8; i++) {
                    const data = getGreenData(setupIdx, group, i);
                    const keys = getButtonConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'green', group, index: i,
                            groupSelector: 'fader',
                            subtype: { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' }[data.typeNibble] || '?'
                        });
                    }
                }
                
                // Faders 1-8
                for (let i = 0; i < 8; i++) {
                    const data = getFaderData(setupIdx, group, i);
                    const keys = getFaderConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'fader', group, index: i,
                            groupSelector: 'fader',
                            subtype: ['CC', 'PC', 'PB', 'AT'][data.type] || 'CC'
                        });
                    }
                }
                
                // Fader 9
                const f9data = getFader9Data(setupIdx, group);
                const f9key = `${f9data.channel}-cc-${f9data.cc}`;
                if (!assignments.has(f9key)) assignments.set(f9key, []);
                assignments.get(f9key).push({
                    type: 'fader9', group, index: 0,
                    groupSelector: 'fader',
                    subtype: 'CC'
                });
            }
            
            // Build key-centric conflict structure
            const result = {
                concurrent: new Map(),
                mutuallyExclusive: new Map()
            };
            
            for (const [key, refs] of assignments) {
                if (refs.length < 2) continue;
                
                // Check if ANY pair in this key is concurrent
                let hasConcurrent = false;
                for (let i = 0; i < refs.length && !hasConcurrent; i++) {
                    for (let j = i + 1; j < refs.length && !hasConcurrent; j++) {
                        if (isConcurrentConflict(refs[i], refs[j])) {
                            hasConcurrent = true;
                        }
                    }
                }
                
                // Whole key goes into one bucket
                if (hasConcurrent) {
                    result.concurrent.set(key, { key, refs });
                } else {
                    result.mutuallyExclusive.set(key, { key, refs });
                }
            }
            
            return result;
        }
        
        function isConcurrentConflict(a, b) {
            // Different selector domains = can be active simultaneously = concurrent
            if (a.groupSelector !== b.groupSelector) {
                return true;
            }
            // Same selector domain + same group = concurrent (both active when that group selected)
            // Same selector domain + different groups = mutually exclusive
            return a.group === b.group;
        }
        
        function getEncoderConflictKeys(data) {
            const ch = data.channel; // Already 1-based from getEncoderData
            switch (data.type) {
                case 0: // CCr1
                case 1: // CCr2
                case 2: // CCAb
                    return [`${ch}-cc-${data.cc}`];
                case 3: { // PrGC - encoder sweeps a program range
                    const lo = Math.max(0, Math.min(127, data.min | 0));
                    const hi = Math.max(0, Math.min(127, data.max | 0));
                    const a = Math.min(lo, hi), b = Math.max(lo, hi);
                    const keys = [];
                    for (let p = a; p <= b; p++) keys.push(`${ch}-pc-${p}`);
                    return keys;
                }
                case 4: // CCAh (14-bit) - occupies CC and CC+32
                    if (data.cc < 0 || data.cc > 31) return [];
                    return [`${ch}-cc-${data.cc}`, `${ch}-cc-${data.cc + 32}`];
                case 5: // Pbnd
                    return [`${ch}-pb-null`];
                case 6: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getButtonConflictKeys(data) {
            if (data.typeNibble === 0x00) return []; // OFF
            const ch = data.channel; // Already 1-based
            switch (data.typeNibble) {
                case 0x10: // Note
                    return [`${ch}-note-${data.cc}`];
                case 0x20: // CC
                    return [`${ch}-cc-${data.cc}`];
                case 0x30: // PrGC - button sends upper on press, lower on release
                    const keys = [`${ch}-pc-${data.upper}`];
                    if (data.lower !== data.upper) {
                        keys.push(`${ch}-pc-${data.lower}`);
                    }
                    return keys;
                case 0x40: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getFaderConflictKeys(data) {
            const ch = data.channel; // Already 1-based
            switch (data.type) {
                case 0: // CCAb
                    return [`${ch}-cc-${data.cc}`];
                case 1: { // PrGC - fader sweeps a program range
                    const lo = Math.max(0, Math.min(127, data.min | 0));
                    const hi = Math.max(0, Math.min(127, data.max | 0));
                    const a = Math.min(lo, hi), b = Math.max(lo, hi);
                    const keys = [];
                    for (let p = a; p <= b; p++) keys.push(`${ch}-pc-${p}`);
                    return keys;
                }
                case 2: // Pbnd
                    return [`${ch}-pb-null`];
                case 3: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getControlConflictType(type, group, index) {
            const controlKey = `${type}-${group}-${index}`;
            const conflicts = conflictsByControl.get(controlKey);
            if (!conflicts) return null;
            
            if (showConcurrentConflicts && conflicts.concurrent.length > 0) {
                return 'concurrent';
            }
            if (showMutuallyExclusiveConflicts && conflicts.mutuallyExclusive.length > 0) {
                return 'mutuallyExclusive';
            }
            return null;
        }
        
        function formatConflictKey(key) {
            // Parse key like "1-cc-64" or "2-pb-null"
            const parts = key.split('-');
            const ch = parts[0];
            const type = parts[1];
            const num = parts[2];
            
            const typeNames = {
                'cc': 'CC',
                'note': 'Note',
                'pc': 'PC',
                'pb': 'PB',
                'at': 'AT'
            };
            
            if (num === 'null') {
                return `Ch${ch} ${typeNames[type] || type}`;
            }
            return `Ch${ch} ${typeNames[type] || type} ${num}`;
        }
        
        function formatControlRef(ref) {
            const typeNames = {
                'encoder': 'Enc',
                'push': 'Push',
                'green': 'Grn',
                'fader': 'Fad',
                'fader9': 'F9'
            };
            const name = typeNames[ref.type] || ref.type;
            return `${name} G${ref.group + 1}.${ref.index + 1} (${ref.subtype})`;
        }
        
        function updateConflictUI() {
            // Update filter chip counts
            updateConflictFilterCounts();
            
            // Re-render overview if in that view
            if (currentView === 'overview') {
                renderOverview();
            }
        }
        
        function updateConflictFilterCounts() {
            const concurrentCount = document.getElementById('concurrentCount');
            const meCount = document.getElementById('meCount');
            
            if (concurrentCount) {
                concurrentCount.textContent = conflicts.concurrent.size;
            }
            if (meCount) {
                meCount.textContent = conflicts.mutuallyExclusive.size;
            }
        }
        
        function toggleConcurrentFilter() {
            showConcurrentConflicts = !showConcurrentConflicts;
            updateConflictUI();
        }
        
        function toggleMEFilter() {
            showMutuallyExclusiveConflicts = !showMutuallyExclusiveConflicts;
            updateConflictUI();
        }
        
        // ============================================================
        // Copy/Paste Operations
        // ============================================================
        
        // Generic control data accessors
        function getControlData(controlType, setupIdx, group, index) {
            switch (controlType) {
                case 'encoder': return getEncoderData(setupIdx, group, index);
                case 'push': return getPushData(setupIdx, group, index);
                case 'green': return getGreenData(setupIdx, group, index);
                case 'fader': return getFaderData(setupIdx, group, index);
                case 'fader9': return getFader9Data(setupIdx, group);
                default: return null;
            }
        }
        
        function setControlData(controlType, setupIdx, group, index, data) {
            switch (controlType) {
                case 'encoder': return setEncoderData(setupIdx, group, index, data);
                case 'push': return setPushData(setupIdx, group, index, data);
                case 'green': return setGreenData(setupIdx, group, index, data);
                case 'fader': return setFaderData(setupIdx, group, index, data);
                case 'fader9': return setFader9Data(setupIdx, group, data);
            }
        }
        
        function formatControlName(controlType, group, index) {
            const typeNames = {
                'encoder': 'Enc',
                'push': 'Push',
                'green': 'Grn',
                'fader': 'Fad',
                'fader9': 'Fad9'
            };
            const name = typeNames[controlType] || controlType;
            if (controlType === 'fader9') {
                return `${name} G${group + 1}`;
            }
            return `${name} G${group + 1}.${index + 1}`;
        }
        
        // Copy operations
        function copyControl(controlType, setupIdx, group, index) {
            const data = getControlData(controlType, setupIdx, group, index);
            if (!data) return;
            
            clipboard = {
                type: 'control',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: group,
                sourceIndex: index,
                data: { ...data }
            };
            showToast(`Copied ${formatControlName(controlType, group, index)}`);
        }
        
        function copyRow(controlType, setupIdx, index) {
            const data = [];
            for (let g = 0; g < 8; g++) {
                data.push({ ...getControlData(controlType, setupIdx, g, index) });
            }
            clipboard = {
                type: 'row',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: null,
                sourceIndex: index,
                data
            };
            const typeName = { encoder: 'Enc', push: 'Push', green: 'Grn', fader: 'Fad', fader9: 'Fad9' }[controlType];
            showToast(`Copied ${typeName} ${index + 1} row (all groups)`);
        }
        
        function copyColumn(controlType, setupIdx, group) {
            const count = controlType === 'fader9' ? 1 : 8;
            const data = [];
            for (let i = 0; i < count; i++) {
                data.push({ ...getControlData(controlType, setupIdx, group, i) });
            }
            clipboard = {
                type: 'column',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: group,
                sourceIndex: null,
                data
            };
            const typeName = { encoder: 'Encoders', push: 'Push Btns', green: 'Green Btns', fader: 'Faders', fader9: 'Fader 9' }[controlType];
            showToast(`Copied Group ${group + 1} ${typeName}`);
        }
        
        // Check paste compatibility
        function canPaste(clip, targetControlType) {
            if (!clip) return false;
            // Must be same control type
            return clip.controlType === targetControlType;
        }
        
        // Apply offset with wrap/clamp
        function applyOffset(value, delta, min, max, wrapMode) {
            const v = value + delta;
            if (wrapMode === 'wrap') {
                const range = max - min + 1;
                return min + (((v - min) % range) + range) % range;
            } else {
                return Math.max(min, Math.min(max, v)); // clamp
            }
        }
        
        // Transform copied data with options
        function transformControlData(data, options) {
            let newData = { ...data };
            
            // Apply channel offset (channel is 1-based: 1-16)
            if (options.channelOffset && options.channelOffset !== 0) {
                const newCh = applyOffset(newData.channel, options.channelOffset, 1, 16, options.wrapMode);
                newData.channel = newCh;
            }
            
            // Apply CC/number offset
            if (options.numberOffset && options.numberOffset !== 0) {
                if (newData.cc !== undefined) {
                    newData.cc = applyOffset(newData.cc, options.numberOffset, 0, 127, options.wrapMode);
                }
            }
            
            return newData;
        }
        
        // Paste to single control
        function pasteToControl(controlType, setupIdx, group, index, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const before = getControlData(controlType, setupIdx, group, index);
            let sourceData;
            
            if (clipboard.type === 'control') {
                sourceData = clipboard.data;
            } else if (clipboard.type === 'row') {
                sourceData = clipboard.data[group]; // Use data for this group
            } else if (clipboard.type === 'column') {
                sourceData = clipboard.data[index]; // Use data for this index
            } else {
                showToast('Unsupported clipboard type for single paste', 'warning');
                return;
            }
            
            const newData = transformControlData(sourceData, options, 0);
            setControlData(controlType, setupIdx, group, index, newData);
            
            recordUndo({
                type: 'control',
                description: `Paste to ${formatControlName(controlType, group, index)}`,
                controlType,
                setupIdx,
                group,
                index,
                before,
                after: newData
            });
            
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to ${formatControlName(controlType, group, index)}`);
        }
        
        // Paste row to all groups
        function pasteRowToGroups(controlType, setupIdx, index, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const batch = { type: 'batch', description: `Paste row ${index + 1}`, actions: [] };
            
            for (let g = 0; g < 8; g++) {
                const before = getControlData(controlType, setupIdx, g, index);
                let sourceData;
                
                if (clipboard.type === 'control') {
                    sourceData = clipboard.data;
                } else if (clipboard.type === 'row') {
                    sourceData = clipboard.data[g];
                } else if (clipboard.type === 'column') {
                    sourceData = clipboard.data[0]; // Use first item for all
                }
                
                const newData = transformControlData(sourceData, options, g);
                setControlData(controlType, setupIdx, g, index, newData);
                
                batch.actions.push({
                    type: 'control',
                    controlType,
                    setupIdx,
                    group: g,
                    index,
                    before,
                    after: newData
                });
            }
            
            recordUndo(batch);
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to row ${index + 1} (all groups)`);
        }
        
        // Paste column to group
        function pasteColumnToGroup(controlType, setupIdx, group, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const count = controlType === 'fader9' ? 1 : 8;
            const batch = { type: 'batch', description: `Paste to Group ${group + 1}`, actions: [] };
            
            for (let i = 0; i < count; i++) {
                const before = getControlData(controlType, setupIdx, group, i);
                let sourceData;
                
                if (clipboard.type === 'control') {
                    sourceData = clipboard.data;
                } else if (clipboard.type === 'row') {
                    sourceData = clipboard.data[0]; // Use first group's data
                } else if (clipboard.type === 'column') {
                    sourceData = clipboard.data[i];
                }
                
                const newData = transformControlData(sourceData, options, i);
                setControlData(controlType, setupIdx, group, i, newData);
                
                batch.actions.push({
                    type: 'control',
                    controlType,
                    setupIdx,
                    group,
                    index: i,
                    before,
                    after: newData
                });
            }
            
            recordUndo(batch);
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to Group ${group + 1}`);
        }
        
        // Set selection (for overview click/keyboard)
        function setSelection(controlType, group, index) {
            // Clear previous selection highlight
            clearSelectionHighlight();
            
            selection = {
                mode: 'single',
                controlType,
                group,
                index
            };
            
            // Apply new selection highlight
            updateSelectionHighlight();
        }
        
        // Clear selection
        function clearSelection() {
            clearSelectionHighlight();
            selection = { mode: 'none', controlType: null, group: null, index: null };
        }
        
        // Update visual highlight for current selection
        function updateSelectionHighlight() {
            if (selection.mode === 'none' || currentView !== 'overview') return;
            
            const cell = getOverviewCell(selection.controlType, selection.group, selection.index);
            if (cell) {
                cell.classList.add('selected');
                cell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        }
        
        // Clear visual highlight
        function clearSelectionHighlight() {
            const selected = document.querySelectorAll('.overview-table td.selected');
            selected.forEach(cell => cell.classList.remove('selected'));
        }
        
        // Get cell element by control type, group, index
        function getOverviewCell(controlType, group, index) {
            // Search all overview tables (Fader 9 is now in its own table)
            const tables = document.querySelectorAll('.overview-table');
            for (const table of tables) {
                const cell = table.querySelector(`td[data-type="${controlType}"][data-group="${group}"][data-index="${index}"]`);
                if (cell) return cell;
            }
            return null;
        }
        
        // Get max index for control type
        function getMaxIndex(controlType) {
            return controlType === 'fader9' ? 0 : 7;
        }
        
        // Check if cell is part of Quick Paste source
        function isQuickPasteSource(controlType, group, index) {
            if (!quickPaste.source || quickPaste.source.controlType !== controlType) return false;
            
            const scope = quickPaste.source.lockedScope;
            const srcGroup = quickPaste.source.group;
            const srcIndex = quickPaste.source.index;
            
            if (scope === 'cell') {
                return group === srcGroup && index === srcIndex;
            } else if (scope === 'column') {
                return group === srcGroup;
            } else if (scope === 'row') {
                return index === srcIndex;
            }
            return false;
        }
        
        // Keyboard navigation
        function moveSelection(direction) {
            if (currentView !== 'overview') return;
            
            // If no selection, start at 0,0 with appropriate control type
            if (selection.mode === 'none') {
                let startType = 'encoder';
                if (overviewTab === 'push') startType = 'push';
                else if (overviewTab === 'green') startType = 'green';
                else if (overviewTab === 'faders') startType = 'fader';
                // 'all' and 'encoders' both start with encoder
                setSelection(startType, 0, 0);
                return;
            }
            
            let { controlType, group, index } = selection;
            const maxIndex = getMaxIndex(controlType);
            
            // Define control type order for 'all' tab navigation
            const allTypeOrder = ['encoder', 'push', 'green', 'fader', 'fader9'];
            
            switch (direction) {
                case 'left':
                    group = Math.max(0, group - 1);
                    break;
                case 'right':
                    group = Math.min(7, group + 1);
                    break;
                case 'up':
                    if (index > 0) {
                        index--;
                    } else if (overviewTab === 'all') {
                        // Move to previous control type section
                        const currentTypeIdx = allTypeOrder.indexOf(controlType);
                        if (currentTypeIdx > 0) {
                            controlType = allTypeOrder[currentTypeIdx - 1];
                            index = getMaxIndex(controlType);
                        }
                    } else if (controlType === 'fader9') {
                        // Move from fader9 row to fader row 8
                        controlType = 'fader';
                        index = 7;
                    }
                    break;
                case 'down':
                    if (index < maxIndex) {
                        index++;
                    } else if (overviewTab === 'all') {
                        // Move to next control type section
                        const currentTypeIdx = allTypeOrder.indexOf(controlType);
                        if (currentTypeIdx < allTypeOrder.length - 1) {
                            controlType = allTypeOrder[currentTypeIdx + 1];
                            index = 0;
                        }
                    } else if (controlType === 'fader' && overviewTab === 'faders') {
                        // Move from fader row 8 to fader9 row
                        controlType = 'fader9';
                        index = 0;
                    }
                    break;
            }
            
            setSelection(controlType, group, index);
        }
        
        // Handle Enter key - jump to focused view
        function handleEnterKey() {
            if (currentView === 'overview' && selection.mode !== 'none') {
                jumpToFocusedView(selection.controlType, selection.group, selection.index);
            }
        }
        
        // Context menu
        let contextMenu = null;
        
        function showContextMenu(e, controlType, group, index) {
            e.preventDefault();
            hideContextMenu();
            
            setSelection(controlType, group, index);
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.innerHTML = `
                <div class="context-menu-item" onclick="copyControl('${controlType}', ${currentSetup}, ${group}, ${index}); hideContextMenu();">
                    Copy Control
                </div>
                <div class="context-menu-item" onclick="copyRow('${controlType}', ${currentSetup}, ${index}); hideContextMenu();">
                    Copy Row (${controlType === 'fader9' ? 'Fad9' : (index + 1)} ÃƒÆ’Ã†â€™â”‚ 8 groups)
                </div>
                <div class="context-menu-item" onclick="copyColumn('${controlType}', ${currentSetup}, ${group}); hideContextMenu();">
                    Copy Column (Group ${group + 1})
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item ${!clipboard || !canPaste(clipboard, controlType) ? 'disabled' : ''}" 
                     onclick="${clipboard && canPaste(clipboard, controlType) ? `pasteToControl('${controlType}', ${currentSetup}, ${group}, ${index}); hideContextMenu();` : ''}">
                    Paste
                </div>
                <div class="context-menu-item ${!clipboard || !canPaste(clipboard, controlType) ? 'disabled' : ''}" 
                     onclick="${clipboard && canPaste(clipboard, controlType) ? `showPasteSpecialDialog('${controlType}', ${group}, ${index}); hideContextMenu();` : ''}">
                    Paste Special...
                </div>
            `;
            
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            
            document.body.appendChild(menu);
            contextMenu = menu;
            
            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 0);
        }
        
        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }
        
        // Paste Special Dialog
        function showPasteSpecialDialog(controlType, group, index) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const sourceInfo = clipboard.type === 'control' 
                ? formatControlName(clipboard.controlType, clipboard.sourceGroup, clipboard.sourceIndex)
                : clipboard.type === 'row'
                    ? `Row ${clipboard.sourceIndex + 1} (8 groups)`
                    : `Group ${clipboard.sourceGroup + 1} column`;
            
            overlay.innerHTML = `
                <div class="modal-dialog paste-special-dialog">
                    <h3>Paste Special</h3>
                    <p class="paste-source">Source: ${sourceInfo}</p>
                    
                    <div class="paste-section">
                        <label class="paste-section-label">Paste to:</label>
                        <div class="paste-targets">
                            <label><input type="radio" name="pasteTarget" value="single" checked> Current cell</label>
                            <label><input type="radio" name="pasteTarget" value="row"> Entire row (all groups)</label>
                            <label><input type="radio" name="pasteTarget" value="column"> Entire column (Group ${group + 1})</label>
                        </div>
                    </div>
                    
                    <div class="paste-section">
                        <label class="paste-section-label">Transforms:</label>
                        <div class="paste-transforms">
                            <div class="transform-row">
                                <label>Channel offset:</label>
                                <input type="number" id="channelOffset" value="0" min="-15" max="15">
                            </div>
                            <div class="transform-row">
                                <label>CC/Number offset:</label>
                                <input type="number" id="numberOffset" value="0" min="-127" max="127">
                            </div>
                            <div class="transform-row">
                                <label>
                                    <input type="checkbox" id="autoIncrement"> Auto-increment CC by:
                                </label>
                                <input type="number" id="incrementBy" value="1" min="1" max="127" style="width: 60px;">
                            </div>
                            <div class="transform-row">
                                <label>Out-of-range:</label>
                                <select id="wrapMode">
                                    <option value="clamp">Clamp to limits</option>
                                    <option value="wrap">Wrap around</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-buttons">
                        <button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        <button class="btn btn-primary" onclick="executePasteSpecial('${controlType}', ${group}, ${index}); this.closest('.modal-overlay').remove();">Paste</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        function executePasteSpecial(controlType, group, index) {
            const target = document.querySelector('input[name="pasteTarget"]:checked').value;
            const options = {
                channelOffset: parseInt(document.getElementById('channelOffset').value) || 0,
                numberOffset: parseInt(document.getElementById('numberOffset').value) || 0,
                autoIncrement: document.getElementById('autoIncrement').checked,
                incrementBy: parseInt(document.getElementById('incrementBy').value) || 1,
                wrapMode: document.getElementById('wrapMode').value
            };
            
            switch (target) {
                case 'single':
                    pasteToControl(controlType, currentSetup, group, index, options);
                    break;
                case 'row':
                    pasteRowToGroups(controlType, currentSetup, index, options);
                    break;
                case 'column':
                    pasteColumnToGroup(controlType, currentSetup, group, options);
                    break;
            }
        }
        
        // Keyboard copy/paste for current selection or focused view
        function handleCopy() {
            if (currentView === 'focused') {
                // In focused view, copy the currently visible encoders (first one as default)
                // This is a simple approach - could be enhanced with actual selection
                copyControl('encoder', currentSetup, encoderGroup, 0);
            } else if (selection.mode !== 'none') {
                copyControl(selection.controlType, currentSetup, selection.group, selection.index);
            } else {
                showToast('Nothing selected to copy', 'warning');
            }
        }
        
        function handlePaste() {
            if (!clipboard) {
                showToast('Nothing to paste', 'warning');
                return;
            }
            
            if (currentView === 'focused') {
                // Paste to current encoder group, first encoder
                if (canPaste(clipboard, 'encoder')) {
                    pasteToControl('encoder', currentSetup, encoderGroup, 0);
                } else {
                    showToast('Clipboard contents not compatible with encoders', 'warning');
                }
            } else if (selection.mode !== 'none') {
                pasteToControl(selection.controlType, currentSetup, selection.group, selection.index);
            } else {
                showToast('Nothing selected to paste to', 'warning');
            }
        }
        
        // ============================================================
        // Quick Paste System (v1.0)
        // ============================================================
        
        function createQuickPasteToolbar() {
            const toolbar = document.createElement('div');
            toolbar.id = 'quickPasteToolbar';
            toolbar.className = `quick-paste-toolbar ${quickPaste.mode === 'off' ? 'collapsed' : ''}`;
            
            const isExpanded = quickPaste.mode !== 'off';
            const hasSource = quickPaste.source !== null;
            
            // Build channel multiplier options (-8 to +8, default 1)
            let chOptions = '';
            for (let i = -8; i <= 8; i++) {
                const label = i === 0 ? '0' : (i > 0 ? `+${i}` : `${i}`);
                chOptions += `<option value="${i}" ${quickPaste.chMultiplier === i ? 'selected' : ''}>${label}</option>`;
            }
            
            // Build CC multiplier options (-8 to +8, default 1)
            let ccOptions = '';
            for (let i = -8; i <= 8; i++) {
                const label = i === 0 ? '0' : (i > 0 ? `+${i}` : `${i}`);
                ccOptions += `<option value="${i}" ${quickPaste.ccMultiplier === i ? 'selected' : ''}>${label}</option>`;
            }
            
            // Source display
            let sourceText = 'No source';
            if (hasSource) {
                const s = quickPaste.source;
                const scopeNames = { cell: 'Cell', column: 'Column', row: 'Row' };
                const typeNames = { encoder: 'Enc', push: 'Push', green: 'Grn', fader: 'Fad', fader9: 'F9' };
                const typeName = typeNames[s.controlType] || s.controlType;
                
                if (s.lockedScope === 'cell') {
                    sourceText = `${typeName} G${s.group + 1}.${s.index + 1}`;
                } else if (s.lockedScope === 'column') {
                    sourceText = `${typeName} Column G${s.group + 1} (${s.count})`;
                } else if (s.lockedScope === 'row') {
                    sourceText = `${typeName} Row ${s.index + 1} (${s.count})`;
                }
            }
            
            // Status text
            let statusText = '';
            if (quickPaste.mode === 'off') {
                statusText = 'Press Q to start Quick Paste';
            } else if (quickPaste.mode === 'copy') {
                statusText = hasSource ? 'Click cell to copy new source, or switch to Paste' : 'Click a cell to set source';
            } else if (quickPaste.mode === 'paste') {
                statusText = hasSource ? `Click to paste â€¢ ${quickPaste.pasteCount} pasted` : 'Switch to Copy mode first';
            }
            
            toolbar.innerHTML = `
                <div class="qp-section">
                    <span class="qp-label">Mode</span>
                    <div class="qp-mode-buttons">
                        <button class="qp-mode-btn ${quickPaste.mode === 'off' ? 'active' : ''}" data-mode="off" onclick="setQuickPasteMode('off')">Off</button>
                        <button class="qp-mode-btn ${quickPaste.mode === 'copy' ? 'active' : ''}" data-mode="copy" onclick="setQuickPasteMode('copy')">Copy</button>
                        <button class="qp-mode-btn ${quickPaste.mode === 'paste' ? 'active' : ''}" data-mode="paste" onclick="setQuickPasteMode('paste')">Paste</button>
                    </div>
                </div>
                
                <div class="qp-expanded-content qp-section">
                    <span class="qp-label">Scope</span>
                    <div class="qp-scope-btns">
                        <button class="qp-scope-btn ${quickPaste.scope === 'cell' ? 'active' : ''}" 
                                onclick="setQuickPasteScope('cell')" title="Single cell [1]">Cell</button>
                        <button class="qp-scope-btn ${quickPaste.scope === 'column' ? 'active' : ''}" 
                                onclick="setQuickPasteScope('column')" title="Entire column/group [2]">Column</button>
                        <button class="qp-scope-btn ${quickPaste.scope === 'row' ? 'active' : ''}" 
                                onclick="setQuickPasteScope('row')" title="Entire row [3]">Row</button>
                    </div>
                </div>
                
                <div class="qp-expanded-content qp-section">
                    <span class="qp-label">Source</span>
                    <div class="qp-source-display ${hasSource ? 'has-source' : ''}">${sourceText}</div>
                </div>
                
                <div class="qp-expanded-content qp-section qp-ch-section">
                    <span class="qp-label">Ch</span>
                    <select id="qpChMult" onchange="setQuickPasteChMult(this.value)" title="Channel offset = group diff * this value">${chOptions}</select>
                </div>
                
                <div class="qp-expanded-content qp-section qp-ch-section">
                    <span class="qp-label">CC</span>
                    <select id="qpCCMult" onchange="setQuickPasteCCMult(this.value)" title="CC offset = group diff * this value">${ccOptions}</select>
                </div>
                
                <div class="qp-expanded-content qp-actions">
                    <button class="qp-action-btn" onclick="clearQuickPasteSource()" ${!hasSource ? 'disabled' : ''}>Clear Source</button>
                </div>
                
                <div class="qp-expanded-content qp-status">${statusText}</div>
            `;
            
            return toolbar;
        }
        
        function setQuickPasteMode(mode) {
            const prevMode = quickPaste.mode;
            quickPaste.mode = mode;
            
            // Clear source when going to off mode
            if (mode === 'off') {
                quickPaste.source = null;
                quickPaste.pasteCount = 0;
            }
            
            // Clear hover highlight tracking when leaving paste mode
            if (prevMode === 'paste' && mode !== 'paste') {
                lastHoverKey = null;
                clearHoverHighlight();
            }
            
            // Collapse/expand toolbar
            const toolbar = document.getElementById('quickPasteToolbar');
            if (toolbar) {
                toolbar.classList.toggle('collapsed', mode === 'off');
            }
            
            // Update table cursor class
            updateOverviewTableCursor();
            
            // Re-render toolbar
            renderOverview();
        }
        
        function setQuickPasteScope(scope) {
            // If scope is changing and we have a source, clear it
            if (quickPaste.source && quickPaste.scope !== scope) {
                quickPaste.source = null;
                showToast(`Scope â†’ ${scope.charAt(0).toUpperCase() + scope.slice(1)} (source cleared)`, 'info');
            }
            
            quickPaste.scope = scope;
            renderOverview();
        }
        
        function setQuickPasteChMult(value) {
            quickPaste.chMultiplier = parseInt(value, 10);
        }
        
        function setQuickPasteCCMult(value) {
            quickPaste.ccMultiplier = parseInt(value, 10);
        }
        
        function clearQuickPasteSource() {
            quickPaste.source = null;
            quickPaste.pasteCount = 0;
            renderOverview();
        }
        
        
        function updateOverviewTableCursor() {
            const tables = document.querySelectorAll('.overview-table');
            tables.forEach(table => {
                table.classList.remove('qp-copy-mode', 'qp-paste-mode');
                if (quickPaste.mode === 'copy') {
                    table.classList.add('qp-copy-mode');
                } else if (quickPaste.mode === 'paste') {
                    table.classList.add('qp-paste-mode');
                }
            });
        }
        
        // Perform Quick Copy based on scope
        function performQuickCopy(controlType, group, index) {
            const scope = quickPaste.scope;
            const colCount = controlType === 'fader9' ? 1 : 8;
            
            let data;
            let count;
            
            if (scope === 'cell') {
                data = { ...getControlData(controlType, currentSetup, group, index) };
                count = 1;
            } else if (scope === 'column') {
                data = [];
                for (let i = 0; i < colCount; i++) {
                    data.push({ ...getControlData(controlType, currentSetup, group, i) });
                }
                count = colCount;
            } else if (scope === 'row') {
                data = [];
                for (let g = 0; g < 8; g++) {
                    data.push({ ...getControlData(controlType, currentSetup, g, index) });
                }
                count = 8;
            }
            
            quickPaste.source = {
                controlType,
                group,
                index,
                data,
                lockedScope: scope,
                count
            };
            
            quickPaste.pasteCount = 0;
            
            // Auto-switch to paste mode
            quickPaste.mode = 'paste';
            
            const scopeNames = { cell: 'Cell', column: 'Column', row: 'Row' };
            showToast(`Copied ${scopeNames[scope]} - ready to paste`, 'success');
            
            renderOverview();
        }
        
        // Perform Quick Paste based on locked scope
        function performQuickPaste(controlType, group, index) {
            if (!quickPaste.source) {
                showToast('No source to paste', 'warning');
                return;
            }
            
            // Same-type enforcement
            if (controlType !== quickPaste.source.controlType) {
                showToast(`Can't paste ${quickPaste.source.controlType} to ${controlType}`, 'error');
                return;
            }
            
            const scope = quickPaste.source.lockedScope;
            const colCount = controlType === 'fader9' ? 1 : 8;
            
            // Calculate offset based on group difference * multiplier
            const sourceGroup = quickPaste.source.group;
            const groupDiff = group - sourceGroup;
            
            const options = {
                channelOffset: groupDiff * quickPaste.chMultiplier,
                numberOffset: groupDiff * quickPaste.ccMultiplier,
                wrapMode: 'clamp'
            };
            
            // Record undo based on scope
            if (scope === 'cell') {
                // Single cell paste
                const before = getControlData(controlType, currentSetup, group, index);
                const newData = transformControlData(quickPaste.source.data, options);
                setControlData(controlType, currentSetup, group, index, newData);
                
                recordUndo({
                    type: 'control',
                    description: `Quick Paste to ${formatControlName(controlType, group, index)}`,
                    controlType,
                    setupIdx: currentSetup,
                    group,
                    index,
                    before,
                    after: newData
                });
                
                flashCell(controlType, group, index);
                
            } else if (scope === 'column') {
                // Column paste to target group
                const batch = { 
                    type: 'batch', 
                    description: `Quick Paste Column to G${group + 1}`, 
                    actions: [] 
                };
                
                for (let i = 0; i < colCount; i++) {
                    const before = getControlData(controlType, currentSetup, group, i);
                    const sourceData = quickPaste.source.data[i] || quickPaste.source.data[0];
                    const newData = transformControlData(sourceData, options);
                    setControlData(controlType, currentSetup, group, i, newData);
                    
                    batch.actions.push({
                        type: 'control',
                        controlType,
                        setupIdx: currentSetup,
                        group,
                        index: i,
                        before,
                        after: newData
                    });
                    
                    flashCell(controlType, group, i);
                }
                
                recordUndo(batch);
                
            } else if (scope === 'row') {
                // Row paste to all groups at target index
                // For row paste, offset is based on row difference (index), not group
                const sourceIndex = quickPaste.source.index;
                const rowDiff = index - sourceIndex;
                
                const rowOptions = {
                    channelOffset: rowDiff * quickPaste.chMultiplier,
                    numberOffset: rowDiff * quickPaste.ccMultiplier,
                    wrapMode: 'clamp'
                };
                
                const batch = { 
                    type: 'batch', 
                    description: `Quick Paste Row ${index + 1}`, 
                    actions: [] 
                };
                
                for (let g = 0; g < 8; g++) {
                    const before = getControlData(controlType, currentSetup, g, index);
                    const sourceData = quickPaste.source.data[g] || quickPaste.source.data[0];
                    const newData = transformControlData(sourceData, rowOptions);
                    setControlData(controlType, currentSetup, g, index, newData);
                    
                    batch.actions.push({
                        type: 'control',
                        controlType,
                        setupIdx: currentSetup,
                        group: g,
                        index,
                        before,
                        after: newData
                    });
                    
                    flashCell(controlType, g, index);
                }
                
                recordUndo(batch);
            }
            
            quickPaste.pasteCount++;
            
            markModified();
            scheduleConflictRebuild();
            renderOverview();
        }
        
        // Flash cell to indicate paste
        function flashCell(controlType, group, index) {
            const cell = getOverviewCell(controlType, group, index);
            if (cell) {
                cell.classList.add('just-pasted');
                setTimeout(() => cell.classList.remove('just-pasted'), 400);
            }
        }
        
        // Handle Quick Paste cell click
        function handleQuickPasteCellClick(controlType, group, index) {
            if (quickPaste.mode === 'copy') {
                performQuickCopy(controlType, group, index);
                return true;
            }
            
            if (quickPaste.mode === 'paste') {
                performQuickPaste(controlType, group, index);
                return true;
            }
            
            return false;
        }
        
        // Handle Quick Paste double-click (blocked in paste mode)
        function handleQuickPasteDoubleClick(controlType, group, index) {
            if (quickPaste.mode === 'paste') {
                if (!quickPaste.doubleClickToastShown) {
                    showToast('Double-click disabled in Paste mode', 'info');
                    quickPaste.doubleClickToastShown = true;
                }
                return true; // Block the action
            }
            
            if (quickPaste.mode === 'copy') {
                // Treat as single click
                performQuickCopy(controlType, group, index);
                return true;
            }
            
            return false;
        }
        
        // Hover highlighting for Quick Paste (column/row preview)
        let lastHoverKey = null;
        
        function handleOverviewMouseEnter(controlType, group, index) {
            // Only show hover highlight in paste mode with a source
            if (quickPaste.mode !== 'paste' || !quickPaste.source) return;
            
            // Only highlight compatible types
            if (controlType !== quickPaste.source.controlType) return;
            
            const scope = quickPaste.source.lockedScope;
            const key = `${controlType}-${group}-${index}-${scope}`;
            
            // Skip if same cell (avoid redundant DOM updates)
            if (key === lastHoverKey) return;
            lastHoverKey = key;
            
            clearHoverHighlight();
            
            const colCount = (controlType === 'fader9') ? 1 : 8;
            
            if (scope === 'column') {
                // Highlight all cells in this group's column
                for (let i = 0; i < colCount; i++) {
                    const cell = getOverviewCell(controlType, group, i);
                    if (cell) cell.classList.add('qp-column-hover');
                }
            } else if (scope === 'row') {
                // Highlight all cells across groups at this index
                for (let g = 0; g < 8; g++) {
                    const cell = getOverviewCell(controlType, g, index);
                    if (cell) cell.classList.add('qp-row-hover');
                }
            } else if (scope === 'cell') {
                // Highlight single target cell
                const cell = getOverviewCell(controlType, group, index);
                if (cell) cell.classList.add('qp-cell-hover');
            }
            // Cell scope uses default CSS hover, no extra highlighting needed
        }
        
        function handleOverviewMouseLeave(controlType, group, index) {
            // Clear highlight when leaving cells
            if (quickPaste.mode !== 'paste') return;
            
            // Small delay to prevent flicker when moving between cells
            setTimeout(() => {
                // Only clear if we haven't entered a new cell
                const currentKey = lastHoverKey;
                if (currentKey && currentKey.startsWith(`${controlType}-${group}-${index}-`)) {
                    // Still on same logical cell, might be between sub-elements
                }
            }, 10);
        }
        
        function clearHoverHighlight() {
            const highlighted = document.querySelectorAll('.qp-column-hover, .qp-row-hover, .qp-cell-hover');
            highlighted.forEach(cell => {
                cell.classList.remove('qp-column-hover', 'qp-row-hover', 'qp-cell-hover');
            });
        }
        
        // ============================================================
        // Tooltip System
        // ============================================================
        
        const tooltipState = {
            showTimer: null,
            hideTimer: null,
            fadeTimer: null,
            autoDismissTimer: null,
            currentLabel: null,
            hoverLabel: null,
            isTouch: false,
            touchDismissOverlay: null
        };
        
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = tooltip.querySelector('.tooltip-content');
        const tooltipArrow = tooltip.querySelector('.tooltip-arrow');
        
        // Detect touch device
        tooltipState.isTouch = ('ontouchstart' in window) || (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
        
        function getTooltipText(key) {
            return TOOLTIPS.labels[key] || null;
        }
        
        function showTooltip(labelEl, key, immediate = false) {
            const text = getTooltipText(key);
            if (!text) return;
            
            // Close any open info panel
            hideInfoPanel();
            
            // Clear any pending operations
            clearTooltipTimers();
            
            tooltipState.currentLabel = labelEl;
            
            const doShow = () => {
                // Set content first (for ARIA)
                tooltipContent.textContent = text;
                
                // Position tooltip
                positionTooltip(labelEl);
                
                // Set ARIA before showing
                tooltip.setAttribute('aria-hidden', 'false');
                
                // Show tooltip
                tooltip.classList.add('visible');
                
                // Touch auto-dismiss
                if (tooltipState.isTouch) {
                    tooltipState.autoDismissTimer = setTimeout(() => {
                        hideTooltip();
                    }, 5000);
                }
            };
            
            if (immediate) {
                doShow();
            } else {
                tooltipState.showTimer = setTimeout(doShow, 400);
            }
        }
        
        function hideTooltip(immediate = false) {
            clearTooltipTimers();
            
            const doHide = () => {
                // Remove visible class immediately
                tooltip.classList.remove('visible');
                
                // Wait for fade then set aria-hidden
                const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                const fadeTime = prefersReducedMotion ? 0 : 120;
                
                tooltipState.fadeTimer = setTimeout(() => {
                    tooltip.setAttribute('aria-hidden', 'true');
                    tooltipState.currentLabel = null;
                }, fadeTime);
            };
            
            if (immediate) {
                tooltip.classList.remove('visible');
                tooltip.setAttribute('aria-hidden', 'true');
                tooltipState.currentLabel = null;
                removeTouchDismissOverlay();
            } else {
                tooltipState.hideTimer = setTimeout(doHide, 100);
            }
        }
        
        function clearTooltipTimers() {
            if (tooltipState.showTimer) {
                clearTimeout(tooltipState.showTimer);
                tooltipState.showTimer = null;
            }
            if (tooltipState.hideTimer) {
                clearTimeout(tooltipState.hideTimer);
                tooltipState.hideTimer = null;
            }
            if (tooltipState.fadeTimer) {
                clearTimeout(tooltipState.fadeTimer);
                tooltipState.fadeTimer = null;
            }
            if (tooltipState.autoDismissTimer) {
                clearTimeout(tooltipState.autoDismissTimer);
                tooltipState.autoDismissTimer = null;
            }
        }
        
        function positionTooltip(labelEl) {
            const rect = labelEl.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const gap = 8;
            const padding = 16;
            
            // Measure tooltip
            tooltip.style.left = '0px';
            tooltip.style.top = '0px';
            tooltip.classList.remove('above', 'below');
            tooltip.classList.add('above'); // Default
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Calculate initial position (above, left-aligned)
            let left = rect.left;
            let top = rect.top - tooltipHeight - gap;
            let placement = 'above';
            
            // Check if fits above
            if (top < padding) {
                // Flip below
                top = rect.bottom + gap;
                placement = 'below';
            }
            
            // Right overflow
            if (left + tooltipWidth > viewportWidth - padding) {
                left = viewportWidth - padding - tooltipWidth;
            }
            
            // Left overflow
            if (left < padding) {
                left = padding;
            }
            
            // Apply position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.remove('above', 'below');
            tooltip.classList.add(placement);
            
            // Position arrow
            const triggerCenterX = rect.left + (rect.width / 2);
            let arrowX = triggerCenterX - left;
            
            // Clamp arrow to tooltip content (post-layout width)
            const contentWidth = tooltipContent.offsetWidth;
            const minArrowX = 16;
            const maxArrowX = contentWidth - 16;
            arrowX = Math.max(minArrowX, Math.min(arrowX, maxArrowX));
            
            tooltipArrow.style.left = (arrowX - 6) + 'px'; // Offset by half arrow width
        }
        
        // Mouse event handlers for labels
        function handleLabelMouseEnter(e) {
            if (tooltipState.isTouch) return;
            
            const label = e.target.closest('.has-tooltip');
            if (!label) return;
            
            const key = label.dataset.tooltipKey;
            if (!key) return;
            
            tooltipState.hoverLabel = label;
            
            // Cancel any pending hide
            if (tooltipState.hideTimer) {
                clearTimeout(tooltipState.hideTimer);
                tooltipState.hideTimer = null;
            }
            
            // If already showing this label, no action needed
            if (tooltipState.currentLabel === label && tooltip.classList.contains('visible')) {
                return;
            }
            
            showTooltip(label, key);
        }
        
        function handleLabelMouseLeave(e) {
            if (tooltipState.isTouch) return;
            
            const label = e.target.closest('.has-tooltip');
            if (!label) return;
            
            tooltipState.hoverLabel = null;
            hideTooltip();
        }
        
        // Touch handlers
        function handleLabelTouch(e) {
            if (!tooltipState.isTouch) return;
            
            const label = e.target.closest('.has-tooltip');
            if (!label) return;
            
            e.preventDefault();
            
            const key = label.dataset.tooltipKey;
            if (!key) return;
            
            // Toggle behavior
            if (tooltipState.currentLabel === label && tooltip.classList.contains('visible')) {
                hideTooltip(true);
                removeTouchDismissOverlay();
            } else {
                showTooltip(label, key, true);
                createTouchDismissOverlay();
            }
        }
        
        function createTouchDismissOverlay() {
            removeTouchDismissOverlay();
            
            const overlay = document.createElement('div');
            overlay.className = 'touch-dismiss-overlay';
            overlay.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                hideTooltip(true);
                removeTouchDismissOverlay();
            }, { passive: false });
            
            document.body.appendChild(overlay);
            tooltipState.touchDismissOverlay = overlay;
        }
        
        function removeTouchDismissOverlay() {
            if (tooltipState.touchDismissOverlay) {
                tooltipState.touchDismissOverlay.remove();
                tooltipState.touchDismissOverlay = null;
            }
        }
        
        // Scroll handler
        function handleScroll() {
            if (tooltip.classList.contains('visible')) {
                hideTooltip(true);
                removeTouchDismissOverlay();
            }
        }
        
        // ============================================================
        // Info Panel System
        // ============================================================
        
        const infoPanelState = {
            currentGroup: null,
            currentSelect: null,
            focusedIndex: 0
        };
        
        const infoPanel = document.getElementById('infoPanel');
        const infoPanelTitle = infoPanel.querySelector('.info-panel-title');
        const infoPanelContent = infoPanel.querySelector('.info-panel-content');
        const infoPanelClose = infoPanel.querySelector('.info-panel-close');
        
        function showInfoPanel(element) {
            const group = element.dataset.infoGroup;
            if (!group) return;
            
            // Find associated select in the same param-row
            const paramRow = element.closest('.param-row');
            const select = paramRow?.querySelector('select[data-option-group]');
            if (!select) return;
            
            // Close any tooltip
            hideTooltip(true);
            
            // Close any existing panel (single-panel rule)
            if (infoPanelState.currentGroup && infoPanelState.currentGroup !== group) {
                hideInfoPanel();
            }
            
            infoPanelState.currentGroup = group;
            infoPanelState.currentSelect = select;
            
            // Set title
            infoPanelTitle.textContent = OPTION_GROUP_TITLES[group] || 'Options';
            
            // Build options list from select
            buildInfoPanelOptions(select, group);
            
            // Position panel
            positionInfoPanel(element);
            
            // Show panel
            infoPanel.style.display = 'flex';
            
            // Focus panel for keyboard navigation
            infoPanel.focus();
        }
        
        function buildInfoPanelOptions(select, group) {
            infoPanelContent.innerHTML = '';
            
            const options = Array.from(select.options);
            const currentValue = select.value;
            
            options.forEach((opt, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'info-panel-option';
                optionEl.dataset.value = opt.value;
                optionEl.dataset.index = index;
                
                // Determine tooltip key based on group type
                let tooltipKey;
                const optText = opt.textContent.trim();
                
                // Map option text to tooltip key
                if (group === 'acc') {
                    tooltipKey = `acc.${index}`;
                } else if (group === 'display') {
                    tooltipKey = `display.${optText}`;
                } else if (group === 'faderMode') {
                    tooltipKey = `faderMode.${optText}`;
                } else if (group === 'buttonMode') {
                    tooltipKey = `buttonMode.${optText}`;
                } else {
                    tooltipKey = `${group}.${optText}`;
                }
                
                const description = TOOLTIPS.options[tooltipKey] || '';
                
                const isSelected = opt.value === currentValue;
                if (isSelected) {
                    infoPanelState.focusedIndex = index;
                    optionEl.classList.add('focused');
                }
                
                optionEl.innerHTML = `
                    <span class="info-panel-marker">${isSelected ? 'â–º' : ''}</span>
                    <div class="info-panel-option-content">
                        <div class="info-panel-option-name">${optText}</div>
                        <div class="info-panel-option-desc">${description}</div>
                    </div>
                `;
                
                optionEl.addEventListener('click', () => handleInfoPanelOptionClick(opt.value));
                
                infoPanelContent.appendChild(optionEl);
            });
        }
        
        function handleInfoPanelOptionClick(value) {
            if (!infoPanelState.currentSelect) return;
            
            const currentValue = infoPanelState.currentSelect.value;
            if (value === currentValue) return; // No-op if already selected
            
            // Update select value programmatically
            infoPanelState.currentSelect.value = value;
            
            // Trigger change event
            const event = new Event('change', { bubbles: true });
            infoPanelState.currentSelect.dispatchEvent(event);
            
            // Update markers in panel
            updateInfoPanelMarkers();
        }
        
        function updateInfoPanelMarkers() {
            if (!infoPanelState.currentSelect) return;
            
            const currentValue = infoPanelState.currentSelect.value;
            const options = infoPanelContent.querySelectorAll('.info-panel-option');
            
            options.forEach((opt, index) => {
                const marker = opt.querySelector('.info-panel-marker');
                const isSelected = opt.dataset.value === currentValue;
                marker.textContent = isSelected ? 'â–º' : '';
                
                if (isSelected) {
                    infoPanelState.focusedIndex = index;
                }
            });
        }
        
        function positionInfoPanel(button) {
            const rect = button.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const gap = 8;
            const padding = 16;
            
            // Reset position for measurement
            infoPanel.style.left = '0px';
            infoPanel.style.top = '0px';
            infoPanel.style.display = 'flex';
            
            const panelRect = infoPanel.getBoundingClientRect();
            const panelWidth = panelRect.width;
            const panelHeight = Math.min(panelRect.height, viewportHeight - 2 * padding);
            
            // Position to the right of the button
            let left = rect.right + gap;
            let top = rect.top;
            
            // Right overflow - position to the left instead
            if (left + panelWidth > viewportWidth - padding) {
                left = rect.left - panelWidth - gap;
            }
            
            // Left overflow
            if (left < padding) {
                left = padding;
            }
            
            // Bottom overflow
            if (top + panelHeight > viewportHeight - padding) {
                top = viewportHeight - padding - panelHeight;
            }
            
            // Top overflow
            if (top < padding) {
                top = padding;
            }
            
            infoPanel.style.left = left + 'px';
            infoPanel.style.top = top + 'px';
            infoPanel.style.maxHeight = (viewportHeight - 2 * padding) + 'px';
        }
        
        function hideInfoPanel() {
            infoPanel.style.display = 'none';
            infoPanelState.currentGroup = null;
            infoPanelState.currentSelect = null;
            infoPanelState.focusedIndex = 0;
        }
        
        function handleInfoPanelKeyDown(e) {
            if (infoPanel.style.display === 'none') return;
            
            const options = infoPanelContent.querySelectorAll('.info-panel-option');
            const numOptions = options.length;
            
            switch (e.key) {
                case 'Escape':
                    e.preventDefault();
                    hideInfoPanel();
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    e.stopPropagation();
                    infoPanelState.focusedIndex = (infoPanelState.focusedIndex + 1) % numOptions;
                    updateInfoPanelFocus();
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    e.stopPropagation();
                    infoPanelState.focusedIndex = (infoPanelState.focusedIndex - 1 + numOptions) % numOptions;
                    updateInfoPanelFocus();
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    const focusedOption = options[infoPanelState.focusedIndex];
                    if (focusedOption) {
                        handleInfoPanelOptionClick(focusedOption.dataset.value);
                    }
                    break;
            }
        }
        
        function updateInfoPanelFocus() {
            const options = infoPanelContent.querySelectorAll('.info-panel-option');
            options.forEach((opt, index) => {
                opt.classList.toggle('focused', index === infoPanelState.focusedIndex);
            });
            
            // Scroll focused option into view
            options[infoPanelState.focusedIndex]?.scrollIntoView({ block: 'nearest' });
        }
        
        // Watch for external select changes (sync marker)
        function watchSelectChanges() {
            document.addEventListener('change', (e) => {
                if (e.target === infoPanelState.currentSelect) {
                    updateInfoPanelMarkers();
                }
            });
        }
        
        // Initialize tooltip system
        function initTooltipSystem() {
            // Event delegation for mouse events on labels
            document.addEventListener('mouseenter', (e) => {
                if (e.target.classList?.contains('has-tooltip')) {
                    handleLabelMouseEnter(e);
                }
            }, true);
            
            document.addEventListener('mouseleave', (e) => {
                if (e.target.classList?.contains('has-tooltip')) {
                    handleLabelMouseLeave(e);
                }
            }, true);
            
            // Touch events on labels
            if (tooltipState.isTouch) {
                document.addEventListener('touchstart', (e) => {
                    if (e.target.classList?.contains('has-tooltip')) {
                        handleLabelTouch(e);
                    }
                }, { passive: false });
            }
            
            // Scroll dismiss
            window.addEventListener('scroll', handleScroll, true);
            
            // Click outside to dismiss (desktop) - safety net
            document.addEventListener('mousedown', (e) => {
                // Close info panel on click outside
                if (infoPanel.style.display !== 'none') {
                    if (!infoPanel.contains(e.target) && !e.target.closest('.has-options')) {
                        hideInfoPanel();
                    }
                }
            });
            
            // Options label clicks (opens info panel)
            document.addEventListener('click', (e) => {
                const optionsLabel = e.target.closest('.has-options');
                if (optionsLabel) {
                    e.preventDefault();
                    e.stopPropagation();
                    showInfoPanel(optionsLabel);
                }
            });
            
            // Info panel close button
            infoPanelClose.addEventListener('click', hideInfoPanel);
            
            // Info panel keyboard navigation
            document.addEventListener('keydown', handleInfoPanelKeyDown);
            
            // Watch for select changes
            watchSelectChanges();
        }
        
        // ============================================================
        // Keyboard Shortcuts
        // ============================================================
        
        document.addEventListener('keydown', (e) => {
            // Check if we're in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
            
            if (ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if (ctrlKey && e.key === 'z' && e.shiftKey) {
                e.preventDefault();
                redo();
            } else if (ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (ctrlKey && e.key === 'c' && !e.shiftKey && !e.altKey) {
                e.preventDefault();
                handleCopy();
            } else if (ctrlKey && e.key === 'v' && !e.shiftKey) {
                e.preventDefault();
                handlePaste();
            } else if (e.key === 'Escape') {
                // Quick Paste priority escape handling
                if (contextMenu) {
                    hideContextMenu();
                } else if (quickPaste.mode !== 'off') {
                    // Exit Quick Paste mode
                    setQuickPasteMode('off');
                    showToast('Quick Paste off', 'info');
                } else {
                    clearSelection();
                }
            } else if (e.key === 'q' || e.key === 'Q') {
                // Cycle Quick Paste modes: off -> copy -> paste -> off
                if (currentView === 'overview') {
                    e.preventDefault();
                    const modes = ['off', 'copy', 'paste'];
                    const currentIdx = modes.indexOf(quickPaste.mode);
                    const nextIdx = (currentIdx + 1) % modes.length;
                    setQuickPasteMode(modes[nextIdx]);
                }
            } else if ((e.key === '1' || e.key === '2' || e.key === '3') && !ctrlKey && !e.altKey) {
                // Quick Paste scope shortcuts (when in QP mode)
                if (currentView === 'overview' && quickPaste.mode !== 'off') {
                    e.preventDefault();
                    const scopes = { '1': 'cell', '2': 'column', '3': 'row' };
                    setQuickPasteScope(scopes[e.key]);
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveSelection('left');
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveSelection('right');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                moveSelection('up');
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                moveSelection('down');
            } else if (e.key === 'Enter') {
                e.preventDefault();
                handleEnterKey();
            } else if (e.key === 'Tab' && currentView === 'overview') {
                e.preventDefault();
                // Tab moves right, Shift+Tab moves left
                moveSelection(e.shiftKey ? 'left' : 'right');
            }
        });
        
        // ============================================================
        // Setup Manager
        // ============================================================
        
        // Factory Templates - initialized from factory_default.syx
        // Replaces the old FACTORY_DEFAULTS parametric approach
        // Each setup has unique channel (1-16 for setups 1-16, 13-14 for setups 17-18)
        // and group-specific CC/Note patterns
        
        function initFactoryTemplates() {
            if (!rawBuffer || !sectionIndex) {
                console.error('Cannot init factory templates: no SysEx loaded');
                return;
            }
            
            FACTORY_TEMPLATES = [];
            for (let setupIdx = 0; setupIdx < 18; setupIdx++) {
                FACTORY_TEMPLATES[setupIdx] = captureSetupSnapshot(setupIdx);
            }
            
            // Initialize Ableton hashes for auto-labeling
            initAbletonHashes();
            
            logDebug(null, 'Factory templates initialized for all 18 setups');
        }
        
        function createFactorySetupSnapshot(setupIdx = 0) {
            if (!FACTORY_TEMPLATES) {
                console.warn('Factory templates not initialized, returning empty snapshot');
                return { groups: [] };
            }
            // Deep clone to prevent mutation
            return JSON.parse(JSON.stringify(FACTORY_TEMPLATES[setupIdx]));
        }
        
        // Validation defaults - used for clamping/fallback during JSON import
        // These are NOT factory defaults, just safe fallback values
        const VALIDATION_DEFAULTS = {
            encoder: (idx) => ({
                channel: 1,
                type: 2,      // CCAb
                cc: idx,
                min: 0,
                max: 127,
                acc: 3,
                display: 1
            }),
            fader: (idx) => ({
                channel: 1,
                type: 0,
                cc: idx,
                min: 0,
                max: 127,
                mode: 0,
                display: 1
            }),
            pushButton: (idx) => ({
                channel: 1,
                typeNibble: 16,
                cc: idx,
                lower: 0,
                upper: 127,
                mode: 0,
                display: 0
            }),
            greenButton: (idx) => ({
                channel: 1,
                typeNibble: 16,
                cc: idx,
                lower: 0,
                upper: 127,
                mode: 0,
                display: 1
            }),
            fader9: () => ({
                channel: 1,
                cc: 112,
                min: 0,
                max: 127,
                mode: 0
            }),
            groupName: (groupIdx) => `GrP${groupIdx + 1}`
        };
        
        // Snapshot functions
        function captureSetupSnapshot(setupIdx) {
            return {
                groups: Array.from({ length: 8 }, (_, g) => ({
                    name: getGroupName(setupIdx, g),
                    encoders: Array.from({ length: 8 }, (_, i) => getEncoderData(setupIdx, g, i)),
                    pushButtons: Array.from({ length: 8 }, (_, i) => getPushData(setupIdx, g, i)),
                    greenButtons: Array.from({ length: 8 }, (_, i) => getGreenData(setupIdx, g, i)),
                    faders: Array.from({ length: 8 }, (_, i) => getFaderData(setupIdx, g, i)),
                    fader9: getFader9Data(setupIdx, g),
                })),
            };
        }
        
        function restoreSetupSnapshot(setupIdx, snap) {
            suppressModified = true;
            try {
                for (let g = 0; g < 8; g++) {
                    // Set group name
                    const nameResult = stringToGroupNameValues(snap.groups[g].name);
                    if (!nameResult.error) {
                        setGroupName(setupIdx, g, nameResult.values);
                    }
                    
                    // Set controls
                    for (let i = 0; i < 8; i++) {
                        setEncoderData(setupIdx, g, i, snap.groups[g].encoders[i]);
                        setPushData(setupIdx, g, i, snap.groups[g].pushButtons[i]);
                        setGreenData(setupIdx, g, i, snap.groups[g].greenButtons[i]);
                        setFaderData(setupIdx, g, i, snap.groups[g].faders[i]);
                    }
                    setFader9Data(setupIdx, g, snap.groups[g].fader9);
                }
            } finally {
                suppressModified = false;
            }
        }
        
        function invalidateDiffCache(indices) {
            if (Array.isArray(indices)) {
                for (const idx of indices) {
                    differsFromFactoryCache.delete(idx);
                }
            } else {
                differsFromFactoryCache.delete(indices);
            }
        }
        
        // Compare snapshots for equality
        function snapshotsEqual(a, b) {
            return JSON.stringify(a) === JSON.stringify(b);
        }
        
        // Check if setup differs from factory defaults
        function differsFromFactory(setupIdx) {
            if (!FACTORY_TEMPLATES) {
                return false;  // Can't compare without templates
            }
            
            if (differsFromFactoryCache.has(setupIdx)) {
                return differsFromFactoryCache.get(setupIdx);
            }
            
            const current = captureSetupSnapshot(setupIdx);
            const factory = FACTORY_TEMPLATES[setupIdx];
            
            // CRITICAL: Full comparison including channel
            // Each setup has unique factory template
            const differs = !snapshotsEqual(current, factory);
            
            differsFromFactoryCache.set(setupIdx, differs);
            return differs;
        }
        
        // Calculate primary channel for a setup (for display in cards)
        function calculatePrimaryChannel(setupIdx) {
            const channelCounts = new Map();
            
            // Count all channels across all groups and controls
            for (let g = 0; g < 8; g++) {
                for (let i = 0; i < 8; i++) {
                    const enc = getEncoderData(setupIdx, g, i);
                    channelCounts.set(enc.channel, (channelCounts.get(enc.channel) || 0) + 1);
                    
                    const push = getPushData(setupIdx, g, i);
                    channelCounts.set(push.channel, (channelCounts.get(push.channel) || 0) + 1);
                    
                    const green = getGreenData(setupIdx, g, i);
                    channelCounts.set(green.channel, (channelCounts.get(green.channel) || 0) + 1);
                    
                    const fader = getFaderData(setupIdx, g, i);
                    channelCounts.set(fader.channel, (channelCounts.get(fader.channel) || 0) + 1);
                }
                const f9 = getFader9Data(setupIdx, g);
                channelCounts.set(f9.channel, (channelCounts.get(f9.channel) || 0) + 1);
            }
            
            // Total controls: 264 per setup
            const totalControls = 264;
            
            // Check for exact 1-8 pattern
            const channels = [...channelCounts.keys()].sort((a, b) => a - b);
            if (channels.length === 8 && channels.join(',') === '1,2,3,4,5,6,7,8') {
                // Check if relatively evenly distributed
                const minCount = Math.min(...channelCounts.values());
                const maxCount = Math.max(...channelCounts.values());
                if (minCount >= totalControls / 16) {
                    return 'Ch 1-8';
                }
            }
            
            // Find dominant channel
            let maxChannel = 1;
            let maxCount = 0;
            for (const [ch, count] of channelCounts) {
                if (count > maxCount || (count === maxCount && ch < maxChannel)) {
                    maxChannel = ch;
                    maxCount = count;
                }
            }
            
            // Check if dominant (>70%)
            if (maxCount / totalControls > 0.7) {
                return `Ch ${maxChannel}`;
            }
            
            // Check for contiguous range with >=80% coverage
            if (channels.length >= 2) {
                const minCh = channels[0];
                const maxCh = channels[channels.length - 1];
                const rangeChannels = maxCh - minCh + 1;
                
                if (rangeChannels === channels.length) {
                    // Contiguous range
                    let rangeTotal = 0;
                    for (let ch = minCh; ch <= maxCh; ch++) {
                        rangeTotal += channelCounts.get(ch) || 0;
                    }
                    if (rangeTotal / totalControls >= 0.8) {
                        return `Ch ${minCh}-${maxCh}`;
                    }
                }
            }
            
            return 'Mixed';
        }
        
        // Open Setup Manager Modal
        function openSetupManager() {
            if (!rawBuffer) return;
            
            setupManagerOpen = true;
            setupManagerSelection.clear();
            setupManagerSelection.add(currentSetup);
            
            renderSetupManager();
        }
        
        function closeSetupManager() {
            setupManagerOpen = false;
            const overlay = document.querySelector('.setup-manager-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        function renderSetupManager() {
            // Remove existing overlay
            const existing = document.querySelector('.setup-manager-overlay');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.className = 'setup-manager-overlay';
            overlay.onclick = (e) => {
                if (e.target === overlay) closeSetupManager();
            };
            
            const modal = document.createElement('div');
            modal.className = 'setup-manager-modal';
            
            // Header
            const header = document.createElement('div');
            header.className = 'setup-manager-header';
            header.innerHTML = `
                <span class="setup-manager-title">Setup Manager</span>
                <button class="setup-manager-close" onclick="closeSetupManager()">&times;</button>
            `;
            modal.appendChild(header);
            
            // Body with grid
            const body = document.createElement('div');
            body.className = 'setup-manager-body';
            
            const grid = document.createElement('div');
            grid.className = 'setup-grid';
            
            for (let i = 0; i < 18; i++) {
                grid.appendChild(createSetupCard(i));
            }
            
            body.appendChild(grid);
            modal.appendChild(body);
            
            // Footer with actions
            const footer = document.createElement('div');
            footer.className = 'setup-manager-footer';
            footer.innerHTML = renderSetupManagerFooter();
            modal.appendChild(footer);
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Focus current setup card
            const currentCard = overlay.querySelector(`[data-setup="${currentSetup}"]`);
            if (currentCard) currentCard.focus();
            
            // Add keyboard handler
            overlay.addEventListener('keydown', handleSetupManagerKeyDown);
        }
        
        function createSetupCard(setupIdx) {
            const card = document.createElement('div');
            card.className = 'setup-card';
            card.dataset.setup = setupIdx;
            card.tabIndex = 0;
            
            if (setupManagerSelection.has(setupIdx)) {
                card.classList.add('selected');
            }
            
            const label = setupLabels.get(setupIdx);
            const primaryCh = calculatePrimaryChannel(setupIdx);
            const modified = differsFromFactory(setupIdx);
            
            card.innerHTML = `
                <div class="setup-card-header">Setup ${setupIdx + 1}</div>
                <div class="setup-card-label ${label ? '' : 'no-label'}">${label || '(no label)'}</div>
                <div class="setup-card-channel">
                    <span>${primaryCh}</span>
                    ${modified ? '<span class="setup-card-modified" title="Differs from factory">â—</span>' : ''}
                </div>
            `;
            
            // Double-click on label to edit
            const labelEl = card.querySelector('.setup-card-label');
            labelEl.ondblclick = (e) => {
                e.stopPropagation();
                setupManagerSelection.clear();
                setupManagerSelection.add(setupIdx);
                updateSetupManagerUI();
                showLabelEditor();
            };
            
            card.onclick = (e) => handleSetupCardClick(e, setupIdx);
            card.ondblclick = () => {
                closeSetupManager();
                selectSetup(setupIdx);
            };
            
            return card;
        }
        
        function handleSetupCardClick(e, setupIdx) {
            if (e.ctrlKey || e.metaKey) {
                // Toggle selection
                if (setupManagerSelection.has(setupIdx)) {
                    setupManagerSelection.delete(setupIdx);
                } else {
                    setupManagerSelection.add(setupIdx);
                }
            } else if (e.shiftKey && setupManagerSelection.size > 0) {
                // Range select
                const lastSelected = Math.max(...setupManagerSelection);
                const start = Math.min(lastSelected, setupIdx);
                const end = Math.max(lastSelected, setupIdx);
                for (let i = start; i <= end; i++) {
                    setupManagerSelection.add(i);
                }
            } else {
                // Single select
                setupManagerSelection.clear();
                setupManagerSelection.add(setupIdx);
            }
            
            updateSetupManagerUI();
        }
        
        function handleSetupManagerKeyDown(e) {
            if (e.key === 'Escape') {
                closeSetupManager();
                return;
            }
            
            if (e.key === 'Enter' && setupManagerSelection.size === 1) {
                const selected = [...setupManagerSelection][0];
                closeSetupManager();
                selectSetup(selected);
                return;
            }
            
            // Arrow navigation
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                navigateSetupGrid(e.key);
                return;
            }
            
            // Shortcut keys
            if (e.key === 'c' || e.key === 'C') {
                if (setupManagerSelection.size >= 1) {
                    showCopyDialog();
                }
            } else if (e.key === 's' || e.key === 'S') {
                if (setupManagerSelection.size === 2) {
                    performDirectSwap();
                } else if (setupManagerSelection.size === 1) {
                    showSwapDialog();
                }
            } else if (e.key === 'Delete') {
                if (setupManagerSelection.size >= 1) {
                    showResetToFactoryDialog();
                }
            } else if (e.key === 'e' || e.key === 'E') {
                if (setupManagerSelection.size === 1) {
                    e.preventDefault();
                    showLabelEditor();
                }
            }
        }
        
        function navigateSetupGrid(key) {
            if (setupManagerSelection.size === 0) {
                setupManagerSelection.add(0);
                updateSetupManagerUI();
                return;
            }
            
            const current = Math.max(...setupManagerSelection);
            let next = current;
            
            switch (key) {
                case 'ArrowLeft':
                    next = Math.max(0, current - 1);
                    break;
                case 'ArrowRight':
                    next = Math.min(17, current + 1);
                    break;
                case 'ArrowUp':
                    next = current >= 6 ? current - 6 : current;
                    break;
                case 'ArrowDown':
                    next = current <= 11 ? current + 6 : current;
                    break;
            }
            
            setupManagerSelection.clear();
            setupManagerSelection.add(next);
            updateSetupManagerUI();
            
            // Focus the card
            const card = document.querySelector(`[data-setup="${next}"]`);
            if (card) card.focus();
        }
        
        function updateSetupManagerUI() {
            // Update card selection states
            document.querySelectorAll('.setup-card').forEach(card => {
                const idx = parseInt(card.dataset.setup);
                card.classList.toggle('selected', setupManagerSelection.has(idx));
            });
            
            // Update footer
            const footer = document.querySelector('.setup-manager-footer');
            if (footer) {
                footer.innerHTML = renderSetupManagerFooter();
            }
        }
        
        function renderSetupManagerFooter() {
            const count = setupManagerSelection.size;
            let selectionText = 'Select one or more setups';
            
            if (count === 1) {
                const idx = [...setupManagerSelection][0];
                const label = setupLabels.get(idx);
                selectionText = `Selected: Setup ${idx + 1}${label ? ` (${label})` : ''}`;
            } else if (count > 1) {
                const indices = [...setupManagerSelection].sort((a, b) => a - b).map(i => i + 1);
                selectionText = `Selected: Setups ${indices.join(', ')}`;
            }
            
            const canCopy = count >= 1;
            const canSwap = count === 1 || count === 2;
            const canClear = count >= 1;
            const canEditLabel = count === 1;
            const canExport = count === 1;
            
            return `
                <div class="setup-manager-selection">${selectionText}</div>
                <div class="setup-manager-actions">
                    <button class="btn" onclick="showCopyDialog()" ${canCopy ? '' : 'disabled'}>Copy to...</button>
                    <button class="btn" onclick="${count === 2 ? 'performDirectSwap()' : 'showSwapDialog()'}" ${canSwap ? '' : 'disabled'}>Swap with...</button>
                    <button class="btn" onclick="showResetToFactoryDialog()" ${canClear ? '' : 'disabled'} title="Restore selected setups to factory defaults">Reset Slot to Factory</button>
                    <button class="btn" onclick="showLabelEditor()" ${canEditLabel ? '' : 'disabled'}>Edit Label</button>
                    <span class="btn-divider"></span>
                    <button class="btn" onclick="showImportToSlotDialog()">Import...</button>
                    <button class="btn" onclick="exportSingleSetup()" ${canExport ? '' : 'disabled'}>Export</button>
                    <span class="btn-divider"></span>
                    <button class="btn" onclick="closeSetupManager()">Close</button>
                </div>
            `;
        }
        
        // Copy Dialog
        function showCopyDialog() {
            if (setupManagerSelection.size === 0) return;
            
            const sourceIdx = [...setupManagerSelection][0];
            const sourceLabel = setupLabels.get(sourceIdx);
            
            const dialog = document.createElement('div');
            dialog.className = 'setup-subdialog';
            dialog.id = 'copySubdialog';
            
            dialog.innerHTML = `
                <h4>Copy Setup ${sourceIdx + 1} to...</h4>
                <p>Select destination slot(s):</p>
                <div class="setup-subdialog-grid" id="copyDestGrid"></div>
                <label class="setup-subdialog-checkbox">
                    <input type="checkbox" id="copyLabelCheck" checked>
                    Copy setup label${sourceLabel ? ` ("${sourceLabel}")` : ''}
                </label>
                <div id="copyWarning" class="setup-subdialog-warning" style="display: none;"></div>
                <div class="setup-subdialog-buttons">
                    <button class="btn" onclick="closeCopyDialog()">Cancel</button>
                    <button class="btn btn-primary" id="copyConfirmBtn" onclick="performCopy()" disabled>Copy</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // Render destination grid
            const grid = document.getElementById('copyDestGrid');
            const destSelection = new Set();
            
            for (let i = 0; i < 18; i++) {
                const item = document.createElement('div');
                item.className = 'setup-subdialog-item';
                item.dataset.idx = i;
                
                if (i === sourceIdx) {
                    item.classList.add('source');
                    item.textContent = `â–¸ ${i + 1}`;
                } else {
                    item.textContent = i + 1;
                    item.onclick = () => {
                        if (destSelection.has(i)) {
                            destSelection.delete(i);
                            item.classList.remove('selected');
                        } else {
                            destSelection.add(i);
                            item.classList.add('selected');
                        }
                        updateCopyDialogState(sourceIdx, destSelection);
                    };
                }
                
                grid.appendChild(item);
            }
            
            // Store reference
            dialog._sourceIdx = sourceIdx;
            dialog._destSelection = destSelection;
        }
        
        function updateCopyDialogState(sourceIdx, destSelection) {
            const confirmBtn = document.getElementById('copyConfirmBtn');
            const warning = document.getElementById('copyWarning');
            
            confirmBtn.disabled = destSelection.size === 0;
            
            if (destSelection.size > 0) {
                const destList = [...destSelection].sort((a, b) => a - b).map(i => i + 1).join(', ');
                warning.textContent = `âš  This will overwrite setup${destSelection.size > 1 ? 's' : ''} ${destList}`;
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }
        }
        
        function closeCopyDialog() {
            const dialog = document.getElementById('copySubdialog');
            if (dialog) dialog.remove();
        }
        
        function performCopy() {
            const dialog = document.getElementById('copySubdialog');
            if (!dialog) return;
            
            const sourceIdx = dialog._sourceIdx;
            const destIndices = [...dialog._destSelection];
            const copyLabel = document.getElementById('copyLabelCheck').checked;
            
            if (destIndices.length === 0) return;
            
            // Capture before snapshots
            const beforeSnapshots = {};
            const labelsBefore = {};
            for (const idx of destIndices) {
                beforeSnapshots[idx] = captureSetupSnapshot(idx);
                labelsBefore[idx] = setupLabels.get(idx) || null;
            }
            
            // Capture source
            const sourceSnapshot = captureSetupSnapshot(sourceIdx);
            const sourceLabel = setupLabels.get(sourceIdx);
            
            // Apply copy
            for (const idx of destIndices) {
                restoreSetupSnapshot(idx, sourceSnapshot);
                if (copyLabel) {
                    if (sourceLabel) {
                        setupLabels.set(idx, sourceLabel);
                    } else {
                        setupLabels.delete(idx);
                    }
                }
            }
            
            // Capture after snapshots
            const afterSnapshots = {};
            const labelsAfter = {};
            for (const idx of destIndices) {
                afterSnapshots[idx] = captureSetupSnapshot(idx);
                labelsAfter[idx] = setupLabels.get(idx) || null;
            }
            
            // Record undo
            recordUndo({
                type: 'setup-copy',
                description: `Copy Setup ${sourceIdx + 1} to ${destIndices.map(i => i + 1).join(', ')}`,
                sourceIdx,
                destIndices,
                beforeSnapshots,
                afterSnapshots,
                labelsBefore,
                labelsAfter
            });
            
            // Update state
            invalidateDiffCache(destIndices);
            dirtySinceLoad = true;
            markModified();
            afterSetupStateMutation(destIndices);
            
            closeCopyDialog();
            renderSetupManager();
            
            showToast(`Copied Setup ${sourceIdx + 1} to ${destIndices.length} slot(s)`, 'success');
        }
        
        // Swap Dialog
        function showSwapDialog() {
            if (setupManagerSelection.size !== 1) return;
            
            const sourceIdx = [...setupManagerSelection][0];
            const sourceLabel = setupLabels.get(sourceIdx);
            
            const dialog = document.createElement('div');
            dialog.className = 'setup-subdialog';
            dialog.id = 'swapSubdialog';
            
            dialog.innerHTML = `
                <h4>Swap Setup ${sourceIdx + 1} with...</h4>
                <p>Select setup to swap with:</p>
                <div class="setup-subdialog-grid" id="swapDestGrid"></div>
                <label class="setup-subdialog-checkbox">
                    <input type="checkbox" id="swapLabelCheck" checked>
                    Swap setup labels
                </label>
                <div id="swapPreview" style="font-size: 0.8rem; color: var(--text-dim); margin-top: 0.5rem;"></div>
                <div class="setup-subdialog-buttons">
                    <button class="btn" onclick="closeSwapDialog()">Cancel</button>
                    <button class="btn btn-primary" id="swapConfirmBtn" onclick="performSwapFromDialog()" disabled>Swap</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // Render grid
            const grid = document.getElementById('swapDestGrid');
            let targetIdx = null;
            
            for (let i = 0; i < 18; i++) {
                const item = document.createElement('div');
                item.className = 'setup-subdialog-item';
                item.dataset.idx = i;
                
                if (i === sourceIdx) {
                    item.classList.add('source');
                    item.textContent = `â–¸ ${i + 1}`;
                } else {
                    item.textContent = i + 1;
                    item.onclick = () => {
                        // Single selection
                        grid.querySelectorAll('.setup-subdialog-item').forEach(el => {
                            if (!el.classList.contains('source')) {
                                el.classList.remove('selected');
                            }
                        });
                        item.classList.add('selected');
                        targetIdx = i;
                        updateSwapDialogState(sourceIdx, targetIdx);
                    };
                }
                
                grid.appendChild(item);
            }
            
            dialog._sourceIdx = sourceIdx;
            dialog._getTarget = () => targetIdx;
        }
        
        function updateSwapDialogState(sourceIdx, targetIdx) {
            const confirmBtn = document.getElementById('swapConfirmBtn');
            const preview = document.getElementById('swapPreview');
            
            confirmBtn.disabled = targetIdx === null;
            
            if (targetIdx !== null) {
                const sourceLabel = setupLabels.get(sourceIdx) || '(no label)';
                const targetLabel = setupLabels.get(targetIdx) || '(no label)';
                preview.textContent = `Setup ${sourceIdx + 1} (${sourceLabel}) â†” Setup ${targetIdx + 1} (${targetLabel})`;
            } else {
                preview.textContent = '';
            }
        }
        
        function closeSwapDialog() {
            const dialog = document.getElementById('swapSubdialog');
            if (dialog) dialog.remove();
        }
        
        function performSwapFromDialog() {
            const dialog = document.getElementById('swapSubdialog');
            if (!dialog) return;
            
            const sourceIdx = dialog._sourceIdx;
            const targetIdx = dialog._getTarget();
            const swapLabels = document.getElementById('swapLabelCheck').checked;
            
            if (targetIdx === null) return;
            
            performSwap(sourceIdx, targetIdx, swapLabels);
            closeSwapDialog();
        }
        
        function performDirectSwap() {
            if (setupManagerSelection.size !== 2) return;
            
            const [idxA, idxB] = [...setupManagerSelection].sort((a, b) => a - b);
            performSwap(idxA, idxB, true);
        }
        
        function performSwap(idxA, idxB, swapLabelsFlag = true) {
            // Capture before
            const beforeSnapshots = {
                [idxA]: captureSetupSnapshot(idxA),
                [idxB]: captureSetupSnapshot(idxB)
            };
            const labelsBefore = {
                [idxA]: setupLabels.get(idxA) || null,
                [idxB]: setupLabels.get(idxB) || null
            };
            
            // Perform swap
            restoreSetupSnapshot(idxA, beforeSnapshots[idxB]);
            restoreSetupSnapshot(idxB, beforeSnapshots[idxA]);
            
            if (swapLabelsFlag) {
                const tempLabel = setupLabels.get(idxA);
                if (setupLabels.has(idxB)) {
                    setupLabels.set(idxA, setupLabels.get(idxB));
                } else {
                    setupLabels.delete(idxA);
                }
                if (tempLabel) {
                    setupLabels.set(idxB, tempLabel);
                } else {
                    setupLabels.delete(idxB);
                }
            }
            
            // Capture after
            const afterSnapshots = {
                [idxA]: captureSetupSnapshot(idxA),
                [idxB]: captureSetupSnapshot(idxB)
            };
            const labelsAfter = {
                [idxA]: setupLabels.get(idxA) || null,
                [idxB]: setupLabels.get(idxB) || null
            };
            
            // Record undo
            recordUndo({
                type: 'setup-swap',
                description: `Swap Setup ${idxA + 1} â†” Setup ${idxB + 1}`,
                idxA,
                idxB,
                beforeSnapshots,
                afterSnapshots,
                labelsBefore,
                labelsAfter
            });
            
            // Update state
            invalidateDiffCache([idxA, idxB]);
            dirtySinceLoad = true;
            markModified();
            refreshMainEditorIfNeeded([idxA, idxB]);
            
            renderSetupManager();
            showToast(`Swapped Setup ${idxA + 1} â†” Setup ${idxB + 1}`, 'success');
        }
        
        // Reset to Factory Dialog
        function showResetToFactoryDialog() {
            if (setupManagerSelection.size === 0) return;
            
            const indices = [...setupManagerSelection].sort((a, b) => a - b);
            const count = indices.length;
            
            const dialog = document.createElement('div');
            dialog.className = 'setup-subdialog';
            dialog.id = 'resetToFactorySubdialog';
            
            let content;
            if (count === 1) {
                const idx = indices[0];
                const label = setupLabels.get(idx);
                content = `
                    <h4>Reset Slot to Factory</h4>
                    <p>Restore Setup ${idx + 1}${label ? ` (${label})` : ''} to factory defaults?</p>
                    <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-dim);">This will restore all 264 controls and group names from <code>factory_default.syx</code>.</p>
                    ${label ? `<p style="font-size: 0.8rem; color: var(--text-dim);">The setup label will be removed.</p>` : ''}
                    <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">This action can be undone.</p>
                `;
            } else {
                const setupList = indices.map(i => {
                    const label = setupLabels.get(i);
                    return `Setup ${i + 1}${label ? ` (${label})` : ''}`;
                }).join(', ');
                content = `
                    <h4>Reset Slots to Factory</h4>
                    <p>Restore ${count} setups to factory defaults?</p>
                    <p style="font-size: 0.85rem; color: var(--text-dim); margin: 0.5rem 0;">${setupList}</p>
                    <p style="font-size: 0.75rem; color: var(--text-muted);">This action can be undone.</p>
                `;
            }
            
            dialog.innerHTML = `
                ${content}
                <div class="setup-subdialog-buttons">
                    <a href="#" onclick="selectAllSetups(); return false;" style="font-size: 0.8rem; margin-right: auto;">Select All</a>
                    <button class="btn" onclick="closeResetToFactoryDialog()">Cancel</button>
                    <button class="btn btn-primary" onclick="performResetToFactory()">Reset to Factory</button>
                </div>
            `;
            
            dialog._indices = indices;
            document.body.appendChild(dialog);
        }
        
        function closeResetToFactoryDialog() {
            const dialog = document.getElementById('resetToFactorySubdialog');
            if (dialog) dialog.remove();
        }
        
        function selectAllSetups() {
            // Select all 18 setups
            for (let i = 0; i < 18; i++) {
                setupManagerSelection.add(i);
            }
            // Close current dialog and reopen with new selection
            closeResetToFactoryDialog();
            updateSetupManagerUI();
            showResetToFactoryDialog();
        }
        
        function performResetToFactory() {
            const dialog = document.getElementById('resetToFactorySubdialog');
            if (!dialog) return;
            
            const indices = dialog._indices;
            
            // Capture before
            const beforeSnapshots = {};
            const labelsBefore = {};
            for (const idx of indices) {
                beforeSnapshots[idx] = captureSetupSnapshot(idx);
                labelsBefore[idx] = setupLabels.get(idx) || null;
            }
            
            // Apply factory defaults - each setup gets its own template
            for (const idx of indices) {
                const factorySnapshot = createFactorySetupSnapshot(idx);
                restoreSetupSnapshot(idx, factorySnapshot);
                setupLabels.delete(idx);
            }
            
            // Capture after
            const afterSnapshots = {};
            const labelsAfter = {};
            for (const idx of indices) {
                afterSnapshots[idx] = captureSetupSnapshot(idx);
                labelsAfter[idx] = null;
            }
            
            // Record undo
            recordUndo({
                type: 'setup-reset-factory',
                description: `Reset Setup${indices.length > 1 ? 's' : ''} ${indices.map(i => i + 1).join(', ')} to factory`,
                indices,
                beforeSnapshots,
                afterSnapshots,
                labelsBefore,
                labelsAfter
            });
            
            // Update state
            invalidateDiffCache(indices);
            dirtySinceLoad = true;
            markModified();
            
            closeResetToFactoryDialog();
            afterSetupStateMutation(indices);
            
            showToast(`Reset ${indices.length} setup${indices.length > 1 ? 's' : ''} to factory defaults`, 'success');
        }
        
        // Label Editor
        function showLabelEditor() {
            if (setupManagerSelection.size !== 1) return;
            
            const idx = [...setupManagerSelection][0];
            const currentLabel = setupLabels.get(idx) || '';
            
            const dialog = document.createElement('div');
            dialog.className = 'setup-subdialog';
            dialog.id = 'labelSubdialog';
            
            dialog.innerHTML = `
                <h4>Edit Label - Setup ${idx + 1}</h4>
                <div class="label-editor">
                    <input type="text" id="labelInput" value="${escapeHtml(currentLabel)}" maxlength="12" placeholder="Enter label...">
                    <div class="label-editor-hint">Max 12 characters. Letters, numbers, space, hyphen, underscore.</div>
                    <div id="labelError" class="label-editor-error" style="display: none;"></div>
                </div>
                <div class="setup-subdialog-buttons">
                    <button class="btn" onclick="closeLabelEditor()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveLabel()">Save</button>
                </div>
            `;
            
            dialog._idx = idx;
            dialog._originalLabel = currentLabel;
            document.body.appendChild(dialog);
            
            // Focus input
            const input = document.getElementById('labelInput');
            input.focus();
            input.select();
            
            // Validate on input
            input.oninput = validateLabelInput;
            input.onkeydown = (e) => {
                if (e.key === 'Enter') saveLabel();
                if (e.key === 'Escape') closeLabelEditor();
            };
        }
        
        function validateLabelInput() {
            const input = document.getElementById('labelInput');
            const error = document.getElementById('labelError');
            const value = input.value;
            
            // Valid characters: alphanumeric, space, hyphen, underscore
            const sanitized = value.replace(/[^a-zA-Z0-9 \-_]/g, '');
            
            if (sanitized !== value) {
                input.value = sanitized;
                error.textContent = 'Invalid characters removed';
                error.style.display = 'block';
            } else {
                error.style.display = 'none';
            }
        }
        
        function closeLabelEditor() {
            const dialog = document.getElementById('labelSubdialog');
            if (dialog) dialog.remove();
        }
        
        function saveLabel() {
            const dialog = document.getElementById('labelSubdialog');
            if (!dialog) return;
            
            const idx = dialog._idx;
            const originalLabel = dialog._originalLabel;
            const newLabel = document.getElementById('labelInput').value.trim();
            
            if (newLabel === originalLabel) {
                closeLabelEditor();
                return;
            }
            
            // Update label
            if (newLabel) {
                setupLabels.set(idx, newLabel);
            } else {
                setupLabels.delete(idx);
            }
            
            // Record undo (simple label change)
            recordUndo({
                type: 'setup-label',
                description: `Change Setup ${idx + 1} label`,
                idx,
                labelBefore: originalLabel || null,
                labelAfter: newLabel || null
            });
            
            dirtySinceLoad = true;
            markModified();
            updateSetupDropdownLabels();
            
            closeLabelEditor();
            renderSetupManager();
            
            showToast(`Updated Setup ${idx + 1} label`, 'success');
        }
        
        // Import to Slot Dialog (Phase 8)
        function showImportToSlotDialog() {
            const dialog = document.createElement('div');
            dialog.className = 'setup-subdialog import-subdialog';
            dialog.id = 'importSubdialog';
            
            dialog.innerHTML = `
                <h4>Import JSON to Slot</h4>
                <div class="import-file-section">
                    <input type="file" id="importSlotFileInput" accept=".json" style="display: none;">
                    <button class="btn" onclick="document.getElementById('importSlotFileInput').click()">Choose JSON file...</button>
                    <span id="importFileName" style="margin-left: 0.5rem; color: var(--text-dim);">No file selected</span>
                </div>
                <div id="importFileInfo" style="display: none; margin-top: 1rem;">
                    <div id="importFileType" style="font-size: 0.85rem; margin-bottom: 0.5rem;"></div>
                    <div id="importSourceSection" style="display: none; margin-bottom: 0.75rem;">
                        <p style="margin-bottom: 0.5rem;">Extract setup from file:</p>
                        <div class="setup-subdialog-grid" id="importSourceGrid"></div>
                    </div>
                    <div id="importTargetSection" style="margin-bottom: 0.75rem;">
                        <p style="margin-bottom: 0.5rem;">Import to slot:</p>
                        <div class="setup-subdialog-grid" id="importTargetGrid"></div>
                    </div>
                    <label class="setup-subdialog-checkbox">
                        <input type="checkbox" id="importLabelCheck" checked>
                        Import setup label
                    </label>
                </div>
                <div id="importWarnings" class="setup-subdialog-warning" style="display: none;"></div>
                <div class="setup-subdialog-buttons">
                    <button class="btn" onclick="closeImportSlotDialog()">Cancel</button>
                    <button class="btn btn-primary" id="importConfirmBtn" onclick="performImportToSlot()" disabled>Import</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // Store state
            dialog._parsedData = null;
            dialog._sourceIdx = null;
            dialog._targetIdx = setupManagerSelection.size === 1 ? [...setupManagerSelection][0] : null;
            dialog._validationWarnings = [];
            
            // Set up file input handler
            document.getElementById('importSlotFileInput').onchange = handleImportFileSelect;
            
            // If we have a pre-selected target, render target grid
            renderImportTargetGrid(dialog._targetIdx);
        }
        
        async function handleImportFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const dialog = document.getElementById('importSubdialog');
            if (!dialog) return;
            
            document.getElementById('importFileName').textContent = file.name;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                // Validate format
                const validation = validateImportJSON(data);
                
                if (validation.error) {
                    showImportError(validation.error);
                    return;
                }
                
                dialog._parsedData = data;
                dialog._validationWarnings = validation.warnings;
                
                // Determine file type and show appropriate UI
                if (data.format === 'uc4-editor-setup') {
                    // Single setup file
                    document.getElementById('importFileType').innerHTML = `
                        <strong>Type:</strong> Single setup
                        ${data.label ? `<br><strong>Label:</strong> ${escapeHtml(data.label)}` : ''}
                    `;
                    document.getElementById('importSourceSection').style.display = 'none';
                    dialog._sourceIdx = 0; // Single setup is always index 0 in the parsed data
                } else if (data.format === 'uc4-editor') {
                    // Full dump
                    document.getElementById('importFileType').innerHTML = `
                        <strong>Type:</strong> Full dump (${data.setups.length} setups)
                        ${data.version ? `<br><strong>Version:</strong> ${data.version}` : ''}
                    `;
                    document.getElementById('importSourceSection').style.display = 'block';
                    renderImportSourceGrid(data);
                    
                    // Default to first labeled setup, or setup 0
                    let defaultSource = 0;
                    if (data.setupLabels) {
                        for (let i = 0; i < 18; i++) {
                            if (data.setupLabels[i.toString()]) {
                                defaultSource = i;
                                break;
                            }
                        }
                    }
                    selectImportSource(defaultSource);
                }
                
                document.getElementById('importFileInfo').style.display = 'block';
                
                // Show warnings if any
                if (validation.warnings.length > 0) {
                    const warningsDiv = document.getElementById('importWarnings');
                    if (validation.warnings.length <= 5) {
                        warningsDiv.innerHTML = `<strong>âš  ${validation.warnings.length} issue(s) found:</strong><ul style="margin: 0.25rem 0 0 1rem; padding: 0;">` +
                            validation.warnings.map(w => `<li style="font-size: 0.75rem;">${escapeHtml(w)}</li>`).join('') +
                            '</ul>';
                    } else {
                        warningsDiv.innerHTML = `<strong>âš  ${validation.warnings.length} issues found.</strong> First 5:<ul style="margin: 0.25rem 0 0 1rem; padding: 0;">` +
                            validation.warnings.slice(0, 5).map(w => `<li style="font-size: 0.75rem;">${escapeHtml(w)}</li>`).join('') +
                            '</ul>';
                    }
                    warningsDiv.style.display = 'block';
                }
                
                updateImportDialogState();
                
            } catch (err) {
                showImportError(`Parse error: ${err.message}`);
            }
        }
        
        function validateImportJSON(data) {
            const warnings = [];
            
            // Check format
            if (!data.format) {
                return { error: 'Missing format field - not a UC4 configuration file' };
            }
            
            if (data.format === 'uc4-editor-setup') {
                // Single setup validation
                if (!data.groups || !Array.isArray(data.groups)) {
                    return { error: 'Invalid structure: missing groups array' };
                }
                if (data.groups.length !== 8) {
                    return { error: `Invalid structure: expected 8 groups, found ${data.groups.length}` };
                }
                
                // Validate each group
                for (let g = 0; g < 8; g++) {
                    const groupWarnings = validateGroupStructure(data.groups[g], g, 'groups');
                    if (groupWarnings.error) return groupWarnings;
                    warnings.push(...groupWarnings.warnings);
                }
                
                // Wrap in normalized structure for easier processing
                data._normalizedSetups = [{
                    groups: data.groups,
                    label: data.label
                }];
                
            } else if (data.format === 'uc4-editor') {
                // Full dump validation
                if (!data.setups || !Array.isArray(data.setups)) {
                    return { error: 'Invalid structure: missing setups array' };
                }
                if (data.setups.length !== 18) {
                    return { error: `Invalid structure: expected 18 setups, found ${data.setups.length}` };
                }
                
                // Validate each setup
                for (let s = 0; s < 18; s++) {
                    const setup = data.setups[s];
                    if (!setup.groups || !Array.isArray(setup.groups)) {
                        return { error: `Invalid structure: setup ${s + 1} missing groups array` };
                    }
                    if (setup.groups.length !== 8) {
                        return { error: `Invalid structure: setup ${s + 1} expected 8 groups, found ${setup.groups.length}` };
                    }
                    
                    // Check index consistency
                    if (setup.index !== undefined && setup.index !== s) {
                        warnings.push(`setups[${s}].index: value ${setup.index} doesn't match array position, using position`);
                    }
                    
                    for (let g = 0; g < 8; g++) {
                        const groupWarnings = validateGroupStructure(setup.groups[g], g, `setups[${s}].groups`);
                        if (groupWarnings.error) return groupWarnings;
                        warnings.push(...groupWarnings.warnings);
                    }
                }
                
                // Normalize for processing
                data._normalizedSetups = data.setups.map((setup, idx) => ({
                    groups: setup.groups,
                    label: data.setupLabels ? data.setupLabels[idx.toString()] : null
                }));
                
            } else {
                return { error: `Unknown format "${data.format}" - not a UC4 configuration file` };
            }
            
            return { warnings };
        }
        
        function validateGroupStructure(group, groupIdx, path) {
            const warnings = [];
            const prefix = `${path}[${groupIdx}]`;
            
            // Check required keys
            const required = ['encoders', 'pushButtons', 'greenButtons', 'faders', 'fader9'];
            for (const key of required) {
                if (!(key in group)) {
                    return { error: `Invalid structure: ${prefix} missing ${key}` };
                }
            }
            
            // Check array lengths
            const arrays = { encoders: 8, pushButtons: 8, greenButtons: 8, faders: 8 };
            for (const [key, expectedLen] of Object.entries(arrays)) {
                if (!Array.isArray(group[key])) {
                    return { error: `Invalid structure: ${prefix}.${key} is not an array` };
                }
                if (group[key].length !== expectedLen) {
                    return { error: `Invalid structure: ${prefix}.${key} length ${group[key].length}, expected ${expectedLen}` };
                }
            }
            
            // Check fader9 is object
            if (typeof group.fader9 !== 'object' || group.fader9 === null) {
                return { error: `Invalid structure: ${prefix}.fader9 is not an object` };
            }
            
            // Validate values and coerce if needed
            for (let i = 0; i < 8; i++) {
                warnings.push(...validateControlValues(group.encoders[i], `${prefix}.encoders[${i}]`, 'encoder', i));
                warnings.push(...validateControlValues(group.pushButtons[i], `${prefix}.pushButtons[${i}]`, 'pushButton', i));
                warnings.push(...validateControlValues(group.greenButtons[i], `${prefix}.greenButtons[${i}]`, 'greenButton', i));
                warnings.push(...validateControlValues(group.faders[i], `${prefix}.faders[${i}]`, 'fader', i));
            }
            warnings.push(...validateControlValues(group.fader9, `${prefix}.fader9`, 'fader9', 0));
            
            // Check for unknown fields
            const knownKeys = ['name', 'index', 'encoders', 'pushButtons', 'greenButtons', 'faders', 'fader9'];
            for (const key of Object.keys(group)) {
                if (!knownKeys.includes(key)) {
                    warnings.push(`${prefix}: unknown field '${key}' ignored`);
                }
            }
            
            return { warnings };
        }
        
        function validateControlValues(control, path, type, idx) {
            const warnings = [];
            const defaults = VALIDATION_DEFAULTS[type](idx);
            
            // Clamp channel
            if ('channel' in control) {
                const ch = parseInt(control.channel);
                if (isNaN(ch)) {
                    control.channel = defaults.channel;
                    warnings.push(`${path}.channel: invalid value, using default ${defaults.channel}`);
                } else if (ch < 1 || ch > 16) {
                    control.channel = Math.max(1, Math.min(16, ch));
                    warnings.push(`${path}.channel: value ${ch} clamped to ${control.channel}`);
                }
            }
            
            // Clamp CC
            if ('cc' in control) {
                const cc = parseInt(control.cc);
                if (isNaN(cc)) {
                    control.cc = defaults.cc;
                    warnings.push(`${path}.cc: invalid value, using default ${defaults.cc}`);
                } else if (cc < 0 || cc > 127) {
                    control.cc = Math.max(0, Math.min(127, cc));
                    warnings.push(`${path}.cc: value ${cc} clamped to ${control.cc}`);
                }
            }
            
            // Clamp min/max or lower/upper
            for (const field of ['min', 'max', 'lower', 'upper']) {
                if (field in control) {
                    const val = parseInt(control[field]);
                    if (isNaN(val)) {
                        control[field] = defaults[field] !== undefined ? defaults[field] : 0;
                        warnings.push(`${path}.${field}: invalid value, using default`);
                    } else if (val < 0 || val > 127) {
                        control[field] = Math.max(0, Math.min(127, val));
                        warnings.push(`${path}.${field}: value ${val} clamped to ${control[field]}`);
                    }
                }
            }
            
            // Validate type (encoder: 0-6, fader: 0-3)
            if ('type' in control) {
                const t = parseInt(control.type);
                const maxType = type === 'encoder' ? 6 : 3;
                if (isNaN(t) || t < 0 || t > maxType) {
                    control.type = defaults.type;
                    warnings.push(`${path}.type: invalid value ${control.type}, using default ${defaults.type}`);
                }
            }
            
            // Validate typeNibble (buttons)
            if ('typeNibble' in control) {
                const tn = parseInt(control.typeNibble);
                if (isNaN(tn)) {
                    control.typeNibble = defaults.typeNibble;
                    warnings.push(`${path}.typeNibble: invalid value, using default ${defaults.typeNibble}`);
                } else if (tn < 0 || tn > 127) {
                    control.typeNibble = Math.max(0, Math.min(127, tn));
                    warnings.push(`${path}.typeNibble: value ${tn} clamped to ${control.typeNibble}`);
                } else if (tn % 16 !== 0) {
                    warnings.push(`${path}.typeNibble: value ${tn} not nibble-aligned`);
                }
            }
            
            // Validate acc (encoder: 0-3)
            if ('acc' in control) {
                const acc = parseInt(control.acc);
                if (isNaN(acc) || acc < 0 || acc > 3) {
                    control.acc = defaults.acc !== undefined ? defaults.acc : 3;
                    warnings.push(`${path}.acc: invalid value, using default`);
                }
            }
            
            // Validate mode (0-1)
            if ('mode' in control) {
                const m = parseInt(control.mode);
                if (isNaN(m) || m < 0 || m > 1) {
                    control.mode = defaults.mode !== undefined ? defaults.mode : 0;
                    warnings.push(`${path}.mode: invalid value, using default 0`);
                }
            }
            
            // Validate display (0-2)
            if ('display' in control) {
                const d = parseInt(control.display);
                if (isNaN(d) || d < 0 || d > 2) {
                    control.display = defaults.display !== undefined ? defaults.display : 1;
                    warnings.push(`${path}.display: invalid value, using default 1`);
                }
            }
            
            return warnings;
        }
        
        function showImportError(message) {
            const warningsDiv = document.getElementById('importWarnings');
            if (warningsDiv) {
                warningsDiv.innerHTML = `<strong style="color: #ff6b6b;">âœ– ${escapeHtml(message)}</strong>`;
                warningsDiv.style.display = 'block';
            }
            document.getElementById('importFileInfo').style.display = 'none';
            document.getElementById('importConfirmBtn').disabled = true;
        }
        
        function renderImportSourceGrid(data) {
            const grid = document.getElementById('importSourceGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 18; i++) {
                const item = document.createElement('div');
                item.className = 'setup-subdialog-item';
                item.dataset.idx = i;
                
                // Check if this setup has a label
                const hasLabel = data.setupLabels && data.setupLabels[i.toString()];
                if (hasLabel) {
                    item.title = data.setupLabels[i.toString()];
                    item.classList.add('has-label');
                }
                
                item.textContent = i + 1;
                item.onclick = () => selectImportSource(i);
                grid.appendChild(item);
            }
        }
        
        function selectImportSource(idx) {
            const dialog = document.getElementById('importSubdialog');
            if (!dialog) return;
            
            dialog._sourceIdx = idx;
            
            // Update grid selection
            document.querySelectorAll('#importSourceGrid .setup-subdialog-item').forEach(el => {
                el.classList.toggle('selected', parseInt(el.dataset.idx) === idx);
            });
            
            updateImportDialogState();
        }
        
        function renderImportTargetGrid(preselectedIdx) {
            const grid = document.getElementById('importTargetGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 18; i++) {
                const item = document.createElement('div');
                item.className = 'setup-subdialog-item';
                item.dataset.idx = i;
                
                const label = setupLabels.get(i);
                if (label) {
                    item.title = label;
                    item.classList.add('has-label');
                }
                
                if (preselectedIdx === i) {
                    item.classList.add('selected');
                }
                
                item.textContent = i + 1;
                item.onclick = () => selectImportTarget(i);
                grid.appendChild(item);
            }
        }
        
        function selectImportTarget(idx) {
            const dialog = document.getElementById('importSubdialog');
            if (!dialog) return;
            
            dialog._targetIdx = idx;
            
            // Update grid selection (single select only)
            document.querySelectorAll('#importTargetGrid .setup-subdialog-item').forEach(el => {
                el.classList.toggle('selected', parseInt(el.dataset.idx) === idx);
            });
            
            updateImportDialogState();
        }
        
        function updateImportDialogState() {
            const dialog = document.getElementById('importSubdialog');
            if (!dialog) return;
            
            const canImport = dialog._parsedData && dialog._sourceIdx !== null && dialog._targetIdx !== null;
            document.getElementById('importConfirmBtn').disabled = !canImport;
        }
        
        function closeImportSlotDialog() {
            const dialog = document.getElementById('importSubdialog');
            if (dialog) dialog.remove();
        }
        
        function performImportToSlot() {
            const dialog = document.getElementById('importSubdialog');
            if (!dialog) return;
            
            const data = dialog._parsedData;
            const sourceIdx = dialog._sourceIdx;
            const targetIdx = dialog._targetIdx;
            const importLabel = document.getElementById('importLabelCheck').checked;
            
            if (!data || sourceIdx === null || targetIdx === null) return;
            
            // Get the normalized setup data
            const sourceSetup = data._normalizedSetups[sourceIdx];
            
            // Capture before state
            const beforeSnapshot = captureSetupSnapshot(targetIdx);
            const labelBefore = setupLabels.get(targetIdx) || null;
            
            // Convert imported groups to snapshot format and apply
            const importedSnapshot = {
                groups: sourceSetup.groups.map((g, gIdx) => ({
                    name: g.name || VALIDATION_DEFAULTS.groupName(gIdx),
                    encoders: g.encoders,
                    pushButtons: g.pushButtons,
                    greenButtons: g.greenButtons,
                    faders: g.faders,
                    fader9: g.fader9
                }))
            };
            
            restoreSetupSnapshot(targetIdx, importedSnapshot);
            
            // Handle label
            if (importLabel && sourceSetup.label) {
                const sanitized = sourceSetup.label.slice(0, 12).replace(/[^a-zA-Z0-9 \-_]/g, '');
                if (sanitized) {
                    setupLabels.set(targetIdx, sanitized);
                } else {
                    setupLabels.delete(targetIdx);
                }
            } else if (importLabel) {
                // No source label, clear target label
                setupLabels.delete(targetIdx);
            }
            // If !importLabel, leave target label unchanged
            
            // Capture after state
            const afterSnapshot = captureSetupSnapshot(targetIdx);
            const labelAfter = setupLabels.get(targetIdx) || null;
            
            // Record undo
            recordUndo({
                type: 'setup-import',
                description: `Import to Setup ${targetIdx + 1}`,
                targetIdx,
                beforeSnapshot,
                afterSnapshot,
                labelBefore,
                labelAfter
            });
            
            // Update state
            invalidateDiffCache(targetIdx);
            dirtySinceLoad = true;
            markModified();
            refreshMainEditorIfNeeded([targetIdx]);
            updateSetupDropdownLabels();
            
            closeImportSlotDialog();
            renderSetupManager();
            
            const warningCount = dialog._validationWarnings.length;
            if (warningCount > 0) {
                showToast(`Imported to Setup ${targetIdx + 1} (${warningCount} warning${warningCount > 1 ? 's' : ''})`, 'success');
            } else {
                showToast(`Imported to Setup ${targetIdx + 1}`, 'success');
            }
        }
        
        // Export Single Setup
        function exportSingleSetup() {
            if (setupManagerSelection.size !== 1) return;
            
            const idx = [...setupManagerSelection][0];
            const label = setupLabels.get(idx);
            
            // Generate default filename
            let defaultFilename = `uc4-setup-${idx + 1}`;
            if (label) {
                const sanitized = label.toLowerCase()
                    .replace(/[\/\\:*?"<>|]/g, '-')
                    .replace(/[\x00-\x1F]/g, '')
                    .replace(/-+/g, '-')
                    .replace(/^-|-$/g, '');
                if (sanitized) {
                    defaultFilename += `-${sanitized}`;
                }
            }
            defaultFilename += '.json';
            
            promptFilename(defaultFilename, 'Export Single Setup', (filename) => {
                const snapshot = captureSetupSnapshot(idx);
                
                const exportData = {
                    format: 'uc4-editor-setup',
                    version: '1.0',
                    exported: new Date().toISOString(),
                    sourceSetup: idx,
                    label: label || undefined,
                    groups: snapshot.groups
                };
                
                // Download
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast(`Exported Setup ${idx + 1}`, 'success');
            });
        }
        
        // Helper: refresh main editor if affected
        function refreshMainEditorIfNeeded(affectedSetups) {
            if (affectedSetups.includes(currentSetup)) {
                updateGroupNames();
                rebuildConflictMap();
                renderCurrentView();
            }
        }
        
        // Update setup dropdown to show labels
        function updateSetupDropdownLabels() {
            const select = document.getElementById('setupSelect');
            if (!select) return;
            
            const labels = getActiveLabels();
            for (let i = 0; i < 18; i++) {
                const option = select.options[i + 1]; // +1 for the "--" placeholder
                if (option) {
                    const label = labels.get(i);
                    option.textContent = label ? `${i + 1}: ${label}` : `${i + 1}`;
                }
            }
        }
        
        // Unified post-mutation hook for setup state changes
        // Call this after: clear, copy, swap, label edit, import-to-slot, global reset/import
        function afterSetupStateMutation(affectedSetupIdxs) {
            // Re-check Ableton labels for affected setups
            for (const idx of affectedSetupIdxs) {
                checkAndApplyAbletonLabel(idx);
            }
            
            // Always refresh dropdown labels
            updateSetupDropdownLabels();
            
            // Refresh main editor if affected setup is current
            refreshMainEditorIfNeeded(affectedSetupIdxs);
            
            // Refresh Setup Manager if open
            if (setupManagerOpen) {
                renderSetupManager();
            }
        }
        
        // Escape HTML for safe insertion
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ============================================================
        // Init
        // ============================================================
        
        async function loadFactoryDefault() {
            try {
                const response = await fetch('factory_default.syx');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const buffer = await response.arrayBuffer();
                const bytes = new Uint8Array(buffer);
                
                // Validate even factory default
                const validation = validateSyx(bytes);
                if (!validation.valid) {
                    // Preserve structured error - throw object, not string
                    const err = new Error(validation.message);
                    err.code = validation.code;
                    err.detail = validation.detail;
                    throw err;
                }
                
                logAction(Action.FACTORY_LOADED, { source: 'fetch' });
                return bytes;
                
            } catch (err) {
                logDebug(null, 'Factory default fetch failed:', err.message);
                
                // On file:// protocol, prompt user (fetch doesn't work locally)
                if (window.location.protocol === 'file:') {
                    return await promptForFactoryDefault();
                }
                
                // On http(s), this is a real error - preserve error code if available
                if (err.code) {
                    showError(err.code, err.message, err.detail);
                } else {
                    showError(ErrorCode.FILE_READ_FAILED, err.message);
                }
                return null;
            }
        }
        
        async function promptForFactoryDefault() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.id = 'factoryDefaultModal';
                overlay.setAttribute('role', 'dialog');
                overlay.setAttribute('aria-labelledby', 'factoryModalTitle');
                
                overlay.innerHTML = `
                    <div class="modal-content" style="max-width: 420px;">
                        <h3 id="factoryModalTitle">Load Factory Defaults</h3>
                        <p style="color: var(--text-dim); margin: 1rem 0;">
                            Running locally requires manually selecting the factory default file.
                        </p>
                        <p style="color: var(--text-dim); margin: 1rem 0;">
                            Select <code>factory_default.syx</code> from your UC4 Editor folder, 
                            or click Skip to start with a blank configuration.
                        </p>
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1.5rem;">
                            <button class="btn" id="factorySkipBtn">Skip</button>
                            <button class="btn primary" id="factorySelectBtn">Select File...</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                const skipBtn = document.getElementById('factorySkipBtn');
                const selectBtn = document.getElementById('factorySelectBtn');
                
                // Focus management
                selectBtn.focus();
                
                function cleanup() {
                    overlay.remove();
                    document.removeEventListener('keydown', handleKeydown);
                }
                
                function handleKeydown(e) {
                    if (e.key === 'Escape') {
                        cleanup();
                        logAction(Action.FACTORY_SKIPPED, { via: 'escape' });
                        showToast('Factory defaults not loaded', 'warning');
                        resolve(null);
                    } else if (e.key === 'Enter' && document.activeElement === selectBtn) {
                        selectBtn.click();
                    }
                }
                
                document.addEventListener('keydown', handleKeydown);
                
                skipBtn.addEventListener('click', () => {
                    cleanup();
                    logAction(Action.FACTORY_SKIPPED, {});
                    showToast('Factory defaults not loaded -- starting blank', 'warning');
                    resolve(null);
                });
                
                selectBtn.addEventListener('click', () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.syx';
                    
                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            try {
                                const buffer = await file.arrayBuffer();
                                const bytes = new Uint8Array(buffer);
                                
                                // Validate selected file
                                const validation = validateSyx(bytes);
                                if (!validation.valid) {
                                    showError(validation.code, validation.message, validation.detail);
                                    return;  // Keep modal open for retry
                                }
                                
                                cleanup();
                                logAction(Action.FACTORY_LOADED, { source: 'picker' });
                                resolve(bytes);
                            } catch (err) {
                                showError(ErrorCode.FILE_READ_FAILED, 'Could not read file');
                            }
                        }
                    });
                    
                    input.click();
                });
            });
        }
        
        async function initializeWithBytes(bytes) {
            // Initialize editor with loaded SysEx bytes
            // bytes may be null if user skipped or load failed
            if (!bytes) {
                updateStatus('', 'No data loaded');
                return;
            }
            
            rawBuffer = bytes;
            sectionIndex = buildIndex(rawBuffer);
            
            // Initialize factory templates from loaded SysEx
            // Must be done before any differsFromFactory checks
            initFactoryTemplates();
            
            // Enable UI
            document.getElementById('setupSelect').disabled = false;
            document.getElementById('setupSelect').value = '0';
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('exportJsonBtn').disabled = false;
            document.getElementById('manageSetupsBtn').disabled = false;
            document.getElementById('libraryBtn').disabled = false;
            
            currentSetup = 0;
            encoderGroup = 0;
            faderGroup = 0;
            isModified = false;
            dirtyBanks.clear();
            
            // Auto-label setups that match factory Ableton configs
            checkAllAbletonLabels();
            
            // Clear undo/redo stacks on fresh load
            undoStack.length = 0;
            redoStack.length = 0;
            updateUndoRedoUI();
            
            updateGroupTabs('encoderGroupTabs', 0);
            updateGroupTabs('faderGroupTabs', 0);
            updateGroupNames();
            updateStatus('loaded', 'Loaded: factory_default.syx');
            document.getElementById('fileInfo').textContent = `factory_default.syx (${rawBuffer.length.toLocaleString()} bytes)`;
            updateImportDropdownState();
            
            // Build initial conflict map
            rebuildConflictMap();
            
            renderFocusedView();
        }
        
        async function initializeEditor() {
            // Check if user previously said "don't ask again"
            if (sessionStorage.getItem('uc4-skip-restore') === 'true') {
                clearSession();
                dirtyBanks.clear();
                const bytes = await loadFactoryDefault();
                await initializeWithBytes(bytes);
                return;
            }
            
            // Check for saved session with actual unsaved changes
            const savedSession = loadSession();
            
            // Only prompt if there are dirty banks (actual unsaved edits)
            if (savedSession && savedSession.dirtyBanks && savedSession.dirtyBanks.length > 0) {
                const timeSince = formatTimeSince(savedSession.timestamp);
                
                // Show restore prompt
                const result = await showRestoreDialog(timeSince, savedSession);
                
                if (result === 'restore') {
                    logAction(Action.SESSION_RESTORE, { success: true });
                    restoreSession(savedSession);
                    return;
                } else if (result === 'discard-permanently') {
                    clearSession();
                    dirtyBanks.clear();
                    // Don't prompt again this browser session
                    sessionStorage.setItem('uc4-skip-restore', 'true');
                } else {
                    clearSession();
                    dirtyBanks.clear();
                }
            } else if (savedSession) {
                // Session exists but no dirty banks = clean baseline, just clear it
                clearSession();
            }
            
            // Load factory defaults
            const bytes = await loadFactoryDefault();
            await initializeWithBytes(bytes);
        }
        
        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            // Check if there are unsaved changes
            if (isModified || dirtyBanks.size > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        
        // ============================================================
        // Setup Library - Infrastructure (Phase 1)
        // ============================================================
        
        // SHA-256 hash functions (per spec Appendix B)
        
        // For config file contentHash verification (text -> UTF-8 bytes -> hash)
        async function hashTextUtf8(text) {
            const data = new TextEncoder().encode(text);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        // For factory slot detection (raw bytes -> hash)
        async function hashBytes(uint8Array) {
            const hash = await crypto.subtle.digest('SHA-256', uint8Array);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        // Content hash verification
        async function verifyContentHash(fetchedText, expectedHash) {
            const computed = await hashTextUtf8(fetchedText);
            return `sha256-${computed}` === expectedHash;
        }
        
        // Version comparison utilities
        function parseVersion(versionStr) {
            const parts = versionStr.split('.').map(n => parseInt(n, 10));
            return {
                major: parts[0] || 0,
                minor: parts[1] || 0,
                patch: parts[2] || 0
            };
        }
        
        function compareVersions(a, b) {
            const va = parseVersion(a);
            const vb = parseVersion(b);
            if (va.major !== vb.major) return va.major - vb.major;
            if (va.minor !== vb.minor) return va.minor - vb.minor;
            return va.patch - vb.patch;
        }
        
        // Import dropdown toggle
        function toggleImportDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('importDropdown');
            dropdown.classList.toggle('open');
        }
        
        function closeImportDropdown() {
            const dropdown = document.getElementById('importDropdown');
            dropdown.classList.remove('open');
        }
        
        function updateImportDropdownState() {
            const hasBuffer = rawBuffer !== null;
            const jsonItem = document.getElementById('importJsonItem');
            const libraryItem = document.getElementById('browseLibraryItem');
            
            if (jsonItem) {
                jsonItem.classList.toggle('disabled', !hasBuffer);
            }
            if (libraryItem) {
                libraryItem.classList.toggle('disabled', !hasBuffer);
            }
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('importDropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                closeImportDropdown();
            }
        });
        
        // Path validation for library entries (per spec)
        function validateLibraryFilePath(file) {
            if (!file.startsWith('configs/')) return false;
            if (!file.endsWith('.json')) return false;
            if (file.includes('..')) return false;
            if (file.includes('://')) return false;
            if (file.includes('\\')) return false;
            if (file.startsWith('/')) return false;
            const lower = file.toLowerCase();
            if (lower.includes('%2e') || lower.includes('%2f')) return false;
            return true;
        }
        
        // Index entry validation
        function validateIndexEntry(entry, index) {
            const errors = [];
            
            // Required fields
            if (!entry.id || typeof entry.id !== 'string') {
                errors.push(`Entry ${index}: missing or invalid id`);
            }
            if (!entry.name || typeof entry.name !== 'string' || entry.name.length < 1 || entry.name.length > 100) {
                errors.push(`Entry ${index}: name must be 1-100 characters`);
            }
            if (!entry.author || typeof entry.author !== 'string' || entry.author.length < 1 || entry.author.length > 50) {
                errors.push(`Entry ${index}: author must be 1-50 characters`);
            }
            if (!entry.description || typeof entry.description !== 'string' || entry.description.length < 1 || entry.description.length > 300) {
                errors.push(`Entry ${index}: description must be 1-300 characters`);
            }
            
            // Device validation
            if (!entry.deviceId || !CANONICAL_DEVICES.some(d => d.id === entry.deviceId)) {
                errors.push(`Entry ${index}: invalid deviceId "${entry.deviceId}"`);
            }
            
            // Tags validation
            if (!Array.isArray(entry.tags) || entry.tags.length < 1 || entry.tags.length > 5) {
                errors.push(`Entry ${index}: tags must be array of 1-5 items`);
            } else {
                for (const tag of entry.tags) {
                    if (!CANONICAL_TAGS.includes(tag)) {
                        errors.push(`Entry ${index}: invalid tag "${tag}"`);
                    }
                }
            }
            
            // Format validation
            if (entry.format !== 'uc4-editor' && entry.format !== 'uc4-editor-setup') {
                errors.push(`Entry ${index}: invalid format "${entry.format}"`);
            }
            
            // setupCount validation
            if (typeof entry.setupCount !== 'number' || entry.setupCount < 1 || entry.setupCount > 18) {
                errors.push(`Entry ${index}: setupCount must be 1-18`);
            }
            
            // File path validation
            if (!entry.file || !validateLibraryFilePath(entry.file)) {
                errors.push(`Entry ${index}: invalid file path "${entry.file}"`);
            }
            
            // Content hash format
            if (!entry.contentHash || !/^sha256-[0-9a-f]{64}$/.test(entry.contentHash)) {
                errors.push(`Entry ${index}: invalid contentHash format`);
            }
            
            // Dates
            if (!entry.created || isNaN(Date.parse(entry.created))) {
                errors.push(`Entry ${index}: invalid created date`);
            }
            if (!entry.updated || isNaN(Date.parse(entry.updated))) {
                errors.push(`Entry ${index}: invalid updated date`);
            }
            
            return errors;
        }
        
        // Fetch with timeout
        async function fetchWithTimeout(url, timeoutMs = LIBRARY_FETCH_TIMEOUT) {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), timeoutMs);
            
            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeout);
                return response;
            } catch (e) {
                clearTimeout(timeout);
                if (e.name === 'AbortError') {
                    throw new Error('Request timed out. Please try again.');
                }
                throw e;
            }
        }
        
        // Fetch and validate library index
        async function fetchLibraryIndex() {
            if (libraryCache.index) {
                return libraryCache.index;
            }
            
            const url = `${LIBRARY_BASE_URL}/index.json`;
            const response = await fetchWithTimeout(url);
            
            if (!response.ok) {
                throw new Error('Unable to load library. Check your internet connection.');
            }
            
            const data = await response.json();
            
            // Validate index structure
            if (!data.version || !data.entries || !Array.isArray(data.entries)) {
                throw new Error('Invalid library index structure.');
            }
            
            // Check index schema version
            const indexVersion = parseVersion(data.version);
            const supportedVersion = parseVersion(SUPPORTED_SCHEMA_VERSION);
            if (indexVersion.major !== supportedVersion.major) {
                throw new Error(`Unsupported library index version ${data.version}. This editor supports ${SUPPORTED_SCHEMA_VERSION.split('.')[0]}.x.`);
            }
            
            // Validate all entries
            const allErrors = [];
            const validEntries = [];
            
            for (let i = 0; i < data.entries.length; i++) {
                const entry = data.entries[i];
                const errors = validateIndexEntry(entry, i);
                if (errors.length > 0) {
                    console.warn('Library entry validation errors:', errors);
                    // Skip invalid entries but continue
                } else {
                    validEntries.push(entry);
                }
            }
            
            // Compute device and tag counts from validated entries
            const deviceCounts = new Map();
            const tagCounts = new Map();
            
            for (const entry of validEntries) {
                deviceCounts.set(entry.deviceId, (deviceCounts.get(entry.deviceId) || 0) + 1);
                for (const tag of entry.tags) {
                    tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
                }
            }
            
            // Build computed device list with counts
            const computedDevices = [];
            for (const device of CANONICAL_DEVICES) {
                const count = deviceCounts.get(device.id);
                if (count) {
                    computedDevices.push({ ...device, count });
                }
            }
            computedDevices.sort((a, b) => a.name.localeCompare(b.name));
            
            // Build computed tag list with counts
            const computedTags = [];
            for (const tag of CANONICAL_TAGS) {
                const count = tagCounts.get(tag);
                if (count) {
                    computedTags.push({ tag, count });
                }
            }
            computedTags.sort((a, b) => a.tag.localeCompare(b.tag));
            
            // Check for declared vs computed discrepancies (log warning only)
            if (data.devices && data.tags) {
                const declaredDeviceIds = new Set(data.devices.map(d => d.id));
                const computedDeviceIds = new Set(computedDevices.map(d => d.id));
                const declaredTagSet = new Set(data.tags.map(t => t.tag));
                const computedTagSet = new Set(computedTags.map(t => t.tag));
                
                if (declaredDeviceIds.size !== computedDeviceIds.size || 
                    declaredTagSet.size !== computedTagSet.size) {
                    console.warn('Library index: declared device/tag lists differ from entry-derived lists');
                }
            }
            
            const processedIndex = {
                version: data.version,
                generated: data.generated,
                entries: validEntries,
                devices: computedDevices,
                tags: computedTags
            };
            
            libraryCache.index = processedIndex;
            return processedIndex;
        }
        
        // Get cache key for config
        function getConfigCacheKey(entry) {
            return `${entry.id}:${entry.contentHash}`;
        }
        
        // Fetch config file with hash verification
        async function fetchLibraryConfig(entry) {
            const cacheKey = getConfigCacheKey(entry);
            const cached = libraryCache.configs.get(cacheKey);
            
            if (cached) {
                return cached;
            }
            
            const url = `${LIBRARY_BASE_URL}/${entry.file}`;
            const response = await fetchWithTimeout(url);
            
            if (!response.ok) {
                throw new Error(`Unable to load '${entry.name}'.`);
            }
            
            // Get raw text for hash verification (do NOT re-serialize)
            const text = await response.text();
            
            // Parse JSON
            let json;
            try {
                json = JSON.parse(text);
            } catch (e) {
                throw new Error('Configuration file is corrupted.');
            }
            
            // Verify content hash
            const hashValid = await verifyContentHash(text, entry.contentHash);
            
            const configData = {
                json,
                text,
                hashVerified: hashValid,
                fetchedAt: Date.now()
            };
            
            libraryCache.configs.set(cacheKey, configData);
            return configData;
        }
        
        // Version compatibility checks (per spec)
        function checkSchemaCompatibility(configVersion) {
            const config = parseVersion(configVersion);
            const supported = parseVersion(SUPPORTED_SCHEMA_VERSION);
            
            if (config.major !== supported.major) {
                return {
                    allowed: false,
                    message: `Unsupported configuration schema version ${config.major}.x. This editor supports ${supported.major}.x.`
                };
            }
            
            if (config.minor > supported.minor) {
                return {
                    allowed: true,
                    info: 'Config uses newer schema features'
                };
            }
            
            return { allowed: true };
        }
        
        function checkEditorMinVersion(minVersion) {
            const min = minVersion || '1.0.0';
            if (compareVersions(CURRENT_EDITOR_VERSION, min) < 0) {
                return {
                    allowed: false,
                    message: `This configuration requires editor version ${min} or later.`
                };
            }
            return { allowed: true };
        }
        
        // Library modal open/close
        function openLibraryModal() {
            libraryModalOpen = true;
            renderLibraryModal();
        }
        
        function closeLibraryModal() {
            // Save scroll position before closing
            const content = document.getElementById('libraryContent');
            if (content) {
                libraryState.scrollPosition = content.scrollTop;
            }
            
            libraryModalOpen = false;
            const modal = document.getElementById('libraryModal');
            if (modal) {
                // Clean up event listeners
                if (modal._cleanup) modal._cleanup();
                modal.remove();
            }
        }
        
        // Render library modal (basic structure for Phase 1)
        function renderLibraryModal() {
            // Remove existing modal if any
            const existing = document.getElementById('libraryModal');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'libraryModal';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-labelledby', 'libraryTitle');
            
            overlay.innerHTML = `
                <div class="library-modal">
                    <div class="library-header">
                        <h2 id="libraryTitle">Setup Library</h2>
                        <button class="library-close" onclick="closeLibraryModal()" aria-label="Close">&times;</button>
                    </div>
                    <div class="library-filters">
                        <div class="library-search">
                            <span class="library-search-icon">&#128269;</span>
                            <input type="text" id="librarySearchInput" placeholder="Search configs..." 
                                   value="${escapeHtml(libraryState.searchText)}"
                                   oninput="handleLibrarySearch(this.value)">
                            <button class="library-search-clear ${libraryState.searchText ? 'visible' : ''}" 
                                    onclick="clearLibrarySearch()">&times;</button>
                        </div>
                        <div class="library-filter-row">
                            <div class="library-filter-group">
                                <label>Device:</label>
                                <select id="libraryDeviceFilter" onchange="handleLibraryDeviceFilter(this.value)">
                                    <option value="">All Devices</option>
                                </select>
                            </div>
                            <div class="library-filter-group">
                                <label>Tags:</label>
                                <div class="library-tag-chips" id="libraryTagChips">
                                    <!-- Populated by JS -->
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="library-content" id="libraryContent">
                        <div class="library-loading">
                            <div class="library-spinner"></div>
                            <div>Loading library...</div>
                        </div>
                    </div>
                    <div class="library-footer">
                        <span id="libraryResultCount">Loading...</span>
                    </div>
                </div>
                <div class="sr-only" aria-live="polite" id="libraryLiveRegion"></div>
                <div class="sr-only" aria-live="assertive" id="libraryErrorRegion"></div>
            `;
            
            document.body.appendChild(overlay);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeLibraryModal();
            });
            
            // Focus trap and keyboard navigation
            const handleKeydown = (e) => {
                if (!libraryModalOpen) return;
                
                if (e.key === 'Escape') {
                    closeLibraryModal();
                    document.removeEventListener('keydown', handleKeydown);
                    return;
                }
                
                // Focus trap
                if (e.key === 'Tab') {
                    const modal = document.querySelector('.library-modal');
                    if (!modal) return;
                    
                    const focusables = modal.querySelectorAll(
                        'button, [href], input, select, [tabindex]:not([tabindex="-1"])'
                    );
                    if (focusables.length === 0) return;
                    
                    const first = focusables[0];
                    const last = focusables[focusables.length - 1];
                    
                    if (e.shiftKey && document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    } else if (!e.shiftKey && document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            };
            document.addEventListener('keydown', handleKeydown);
            
            // Store cleanup function
            overlay._cleanup = () => {
                document.removeEventListener('keydown', handleKeydown);
            };
            
            // Focus search input
            setTimeout(() => {
                const searchInput = document.getElementById('librarySearchInput');
                if (searchInput) searchInput.focus();
            }, 50);
            
            // Load index
            loadLibraryIndex();
        }
        
        // Load and display library index
        async function loadLibraryIndex() {
            const content = document.getElementById('libraryContent');
            const liveRegion = document.getElementById('libraryLiveRegion');
            
            try {
                const index = await fetchLibraryIndex();
                libraryState.index = index;
                
                // Populate device filter dropdown
                populateLibraryFilters(index);
                
                // Render entries
                renderLibraryEntries(index.entries);
                
                if (liveRegion) {
                    liveRegion.textContent = `Loaded ${index.entries.length} configurations`;
                }
                
            } catch (error) {
                console.error('Library load error:', error);
                if (content) {
                    content.innerHTML = `
                        <div class="library-error">
                            <div>${escapeHtml(error.message)}</div>
                            <button class="btn library-retry-btn" onclick="loadLibraryIndex()">Retry</button>
                        </div>
                    `;
                }
                if (liveRegion) {
                    liveRegion.textContent = 'Failed to load library';
                }
                const errorRegion = document.getElementById('libraryErrorRegion');
                if (errorRegion) {
                    errorRegion.textContent = error.message;
                }
            }
        }
        
        // Populate filter dropdowns
        function populateLibraryFilters(index) {
            const deviceSelect = document.getElementById('libraryDeviceFilter');
            const tagChips = document.getElementById('libraryTagChips');
            
            if (deviceSelect) {
                deviceSelect.innerHTML = '<option value="">All Devices</option>';
                for (const device of index.devices) {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = `${device.name} (${device.count})`;
                    if (device.id === libraryState.deviceFilter) {
                        option.selected = true;
                    }
                    deviceSelect.appendChild(option);
                }
            }
            
            if (tagChips) {
                tagChips.innerHTML = '';
                for (const tagInfo of index.tags) {
                    const chip = document.createElement('span');
                    chip.className = 'library-tag-chip';
                    chip.setAttribute('tabindex', '0');
                    chip.setAttribute('role', 'checkbox');
                    chip.setAttribute('aria-checked', libraryState.tagFilters.includes(tagInfo.tag) ? 'true' : 'false');
                    if (libraryState.tagFilters.includes(tagInfo.tag)) {
                        chip.classList.add('active');
                    }
                    chip.textContent = `${tagInfo.tag} (${tagInfo.count})`;
                    chip.onclick = () => toggleLibraryTag(tagInfo.tag);
                    chip.onkeydown = (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            toggleLibraryTag(tagInfo.tag);
                        }
                    };
                    tagChips.appendChild(chip);
                }
            }
        }
        
        // Render library entries
        function renderLibraryEntries(entries) {
            const content = document.getElementById('libraryContent');
            const countEl = document.getElementById('libraryResultCount');
            
            if (!content) return;
            
            // Apply filters
            let filtered = entries;
            
            // Search filter
            if (libraryState.searchText) {
                const search = libraryState.searchText.toLowerCase();
                filtered = filtered.filter(e => 
                    e.name.toLowerCase().includes(search) ||
                    e.description.toLowerCase().includes(search) ||
                    e.author.toLowerCase().includes(search) ||
                    e.device.toLowerCase().includes(search)
                );
            }
            
            // Device filter
            if (libraryState.deviceFilter) {
                filtered = filtered.filter(e => e.deviceId === libraryState.deviceFilter);
            }
            
            // Tag filters (AND logic)
            if (libraryState.tagFilters.length > 0) {
                filtered = filtered.filter(e => 
                    libraryState.tagFilters.every(tag => e.tags.includes(tag))
                );
            }
            
            // Update count
            if (countEl) {
                countEl.textContent = `Showing ${filtered.length} of ${entries.length} configs`;
            }
            
            // Restore scroll position
            if (libraryState.scrollPosition > 0) {
                setTimeout(() => {
                    if (content) content.scrollTop = libraryState.scrollPosition;
                }, 0);
            }
            
            // Empty state
            if (filtered.length === 0) {
                content.innerHTML = `
                    <div class="library-empty">
                        <div>No configs match your filters</div>
                        <button class="btn" style="margin-top: 1rem;" onclick="clearLibraryFilters()">Clear Filters</button>
                    </div>
                `;
                return;
            }
            
            // Render cards
            content.innerHTML = '<div class="library-cards"></div>';
            const cards = content.querySelector('.library-cards');
            
            for (const entry of filtered) {
                const card = document.createElement('div');
                card.className = 'library-card';
                card.setAttribute('tabindex', '0');
                card.setAttribute('role', 'article');
                card.setAttribute('aria-label', `${entry.name} by ${entry.author}, ${entry.setupCount} setup${entry.setupCount === 1 ? '' : 's'}`);
                
                // Keyboard navigation
                card.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.target.matches('button')) {
                        importLibraryEntry(entry.id);
                    }
                    // Arrow key navigation between cards
                    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        const cards = Array.from(document.querySelectorAll('.library-card'));
                        const currentIndex = cards.indexOf(card);
                        let nextIndex;
                        if (e.key === 'ArrowDown') {
                            nextIndex = currentIndex < cards.length - 1 ? currentIndex + 1 : 0;
                        } else {
                            nextIndex = currentIndex > 0 ? currentIndex - 1 : cards.length - 1;
                        }
                        cards[nextIndex].focus();
                    }
                });
                
                card.innerHTML = `
                    <div class="library-card-header">
                        <span class="library-card-title">${escapeHtml(entry.name)}</span>
                        <span class="library-card-badge">${entry.setupCount} ${entry.setupCount === 1 ? 'setup' : 'setups'}</span>
                    </div>
                    <div class="library-card-desc">${escapeHtml(truncateText(entry.description, 150))}</div>
                    <div class="library-card-meta">by ${escapeHtml(entry.author)} &middot; ${escapeHtml(entry.device)}</div>
                    <div class="library-card-tags">
                        ${entry.tags.map(t => `<span class="library-card-tag">${escapeHtml(t)}</span>`).join('')}
                    </div>
                    <div class="library-card-actions">
                        <button class="btn" onclick="previewLibraryEntry('${escapeHtml(entry.id)}')">Preview</button>
                        <button class="btn btn-primary" onclick="importLibraryEntry('${escapeHtml(entry.id)}')">Import</button>
                    </div>
                `;
                cards.appendChild(card);
            }
        }
        
        // Filter handlers
        let librarySearchDebounce = null;
        
        function handleLibrarySearch(value) {
            clearTimeout(librarySearchDebounce);
            librarySearchDebounce = setTimeout(() => {
                libraryState.searchText = value;
                const clearBtn = document.querySelector('.library-search-clear');
                if (clearBtn) {
                    clearBtn.classList.toggle('visible', !!value);
                }
                if (libraryState.index) {
                    renderLibraryEntries(libraryState.index.entries);
                }
            }, 300);
        }
        
        function clearLibrarySearch() {
            libraryState.searchText = '';
            const input = document.getElementById('librarySearchInput');
            if (input) input.value = '';
            const clearBtn = document.querySelector('.library-search-clear');
            if (clearBtn) clearBtn.classList.remove('visible');
            if (libraryState.index) {
                renderLibraryEntries(libraryState.index.entries);
            }
        }
        
        function handleLibraryDeviceFilter(value) {
            libraryState.deviceFilter = value;
            if (libraryState.index) {
                renderLibraryEntries(libraryState.index.entries);
            }
        }
        
        function toggleLibraryTag(tag) {
            const idx = libraryState.tagFilters.indexOf(tag);
            if (idx >= 0) {
                libraryState.tagFilters.splice(idx, 1);
            } else {
                libraryState.tagFilters.push(tag);
            }
            // Re-render tag chips to show active state
            if (libraryState.index) {
                populateLibraryFilters(libraryState.index);
                renderLibraryEntries(libraryState.index.entries);
            }
        }
        
        function clearLibraryFilters() {
            libraryState.searchText = '';
            libraryState.deviceFilter = '';
            libraryState.tagFilters = [];
            
            const input = document.getElementById('librarySearchInput');
            if (input) input.value = '';
            
            const select = document.getElementById('libraryDeviceFilter');
            if (select) select.value = '';
            
            if (libraryState.index) {
                populateLibraryFilters(libraryState.index);
                renderLibraryEntries(libraryState.index.entries);
            }
        }
        
        // ============================================================
        // Preview Mode (Phase 3)
        // ============================================================
        
        async function previewLibraryEntry(entryId) {
            if (!libraryState.index) return;
            
            const entry = libraryState.index.entries.find(e => e.id === entryId);
            if (!entry) {
                showToast('Config not found', 'error');
                return;
            }
            
            // Close library modal
            closeLibraryModal();
            
            try {
                // Fetch config
                const configResult = await fetchLibraryConfig(entry);
                
                // Check hash
                if (!configResult.hashVerified) {
                    const proceed = await showHashMismatchDialog();
                    if (!proceed) {
                        openLibraryModal();
                        return;
                    }
                }
                
                // Validate config structure
                const validation = validateConfigForPreview(configResult.json, entry);
                if (!validation.valid) {
                    showToast(validation.error, 'error');
                    openLibraryModal();
                    return;
                }
                
                // Check version compatibility
                const schemaCheck = checkSchemaCompatibility(configResult.json.version);
                if (!schemaCheck.allowed) {
                    showToast(schemaCheck.message, 'error');
                    openLibraryModal();
                    return;
                }
                
                const editorCheck = checkEditorMinVersion(entry.minEditorVersion);
                if (!editorCheck.allowed) {
                    showToast(editorCheck.message, 'error');
                    openLibraryModal();
                    return;
                }
                
                // Enter preview mode
                enterPreviewMode(entry, configResult.json);
                
                if (schemaCheck.info) {
                    showToast(schemaCheck.info, 'info');
                }
                
            } catch (error) {
                console.error('Preview error:', error);
                showToast(error.message || 'Failed to load config', 'error');
                openLibraryModal();
            }
        }
        
        function validateConfigForPreview(config, entry) {
            // Check format
            if (config.format !== 'uc4-editor' && config.format !== 'uc4-editor-setup') {
                return { valid: false, error: 'Invalid configuration format.' };
            }
            
            // Check exportedBy
            if (!config.exportedBy || config.exportedBy.app !== 'uc4-sysex-editor') {
                return { valid: false, error: 'Configuration missing required metadata.' };
            }
            
            // Check version
            if (!config.version) {
                return { valid: false, error: 'Configuration missing version.' };
            }
            
            if (config.format === 'uc4-editor-setup') {
                // Single setup
                if (!Array.isArray(config.groups) || config.groups.length !== 8) {
                    return { valid: false, error: 'Invalid structure: expected 8 groups.' };
                }
                if (entry.setupCount !== 1) {
                    return { valid: false, error: 'Index mismatch: setupCount must be 1 for single-setup format.' };
                }
            } else {
                // Full config
                if (!Array.isArray(config.setups) || config.setups.length === 0) {
                    return { valid: false, error: 'Invalid structure: no setups found.' };
                }
                if (config.setups.length !== entry.setupCount) {
                    return { valid: false, error: `Index mismatch: expected ${entry.setupCount} setups, found ${config.setups.length}.` };
                }
                // Check contiguous indices
                for (let i = 0; i < config.setups.length; i++) {
                    if (config.setups[i].index !== i) {
                        return { valid: false, error: 'Invalid structure: setup indices must be sequential from 0.' };
                    }
                }
            }
            
            return { valid: true };
        }
        
        function enterPreviewMode(entry, configData) {
            // Save current UI state
            prePreviewState = {
                currentSetup,
                encoderGroup,
                faderGroup,
                currentView,
                overviewTab: typeof overviewTab !== 'undefined' ? overviewTab : 'encoders'
            };
            
            // Create preview buffer from current rawBuffer or factory defaults
            const EXPECTED_SIZE = 100640;
            previewBuffer = new Uint8Array(EXPECTED_SIZE);
            if (rawBuffer) {
                previewBuffer.set(rawBuffer);
            }
            
            // Clear preview labels
            previewLabels.clear();
            
            // Apply config data to preview buffer
            if (configData.format === 'uc4-editor-setup') {
                applyGroupsToPreviewBuffer(0, configData.groups);
                if (configData.label) {
                    previewLabels.set(0, configData.label);
                }
            } else {
                for (const setup of configData.setups) {
                    applyGroupsToPreviewBuffer(setup.index, setup.groups);
                }
                if (configData.labels) {
                    configData.labels.forEach((label, i) => {
                        if (label) previewLabels.set(i, label);
                    });
                }
            }
            
            // Set preview state
            previewMode = true;
            previewEntry = entry;
            previewConfigData = configData;
            
            // Navigate to first setup in config
            if (configData.format === 'uc4-editor-setup') {
                currentSetup = 0;
            } else {
                currentSetup = configData.setups[0].index;
            }
            encoderGroup = 0;
            faderGroup = 0;
            
            // Update UI
            document.body.classList.add('preview-mode');
            renderPreviewBanner();
            updateUndoRedoUI();
            renderCurrentView();
            updateSetupDropdownLabels();
            
            showToast(`Previewing: ${entry.name}`, 'info');
        }
        
        function applyGroupsToPreviewBuffer(setupIdx, groups) {
            // This writes directly to previewBuffer using low-level encode
            for (const group of groups) {
                const g = group.index;
                
                // Apply encoders
                if (group.encoders) {
                    for (let i = 0; i < 8; i++) {
                        if (group.encoders[i]) {
                            applyEncoderToPreviewBuffer(setupIdx, g, i, group.encoders[i]);
                        }
                    }
                }
                
                // Apply push buttons
                if (group.pushButtons) {
                    for (let i = 0; i < 8; i++) {
                        if (group.pushButtons[i]) {
                            applyPushToPreviewBuffer(setupIdx, g, i, group.pushButtons[i]);
                        }
                    }
                }
                
                // Apply green buttons
                if (group.greenButtons) {
                    for (let i = 0; i < 8; i++) {
                        if (group.greenButtons[i]) {
                            applyGreenToPreviewBuffer(setupIdx, g, i, group.greenButtons[i]);
                        }
                    }
                }
                
                // Apply faders
                if (group.faders) {
                    for (let i = 0; i < 8; i++) {
                        if (group.faders[i]) {
                            applyFaderToPreviewBuffer(setupIdx, g, i, group.faders[i]);
                        }
                    }
                }
                
                // Apply fader9
                if (group.fader9) {
                    applyFader9ToPreviewBuffer(setupIdx, g, group.fader9);
                }
                
                // Apply group name
                if (group.name) {
                    applyGroupNameToPreviewBuffer(setupIdx, g, group.name);
                }
            }
        }
        
        // Low-level preview buffer writers (mirror the setXXXData functions but write to previewBuffer)
        function setPreviewValue(setupIdx, secId, bank, valueIdx, value) {
            if (!sectionIndex) return;
            const loc = computeActualLocation(setupIdx, secId, bank, valueIdx);
            const sec = sectionIndex[loc.actualSecId];
            if (!sec) return;
            const bnk = sec[loc.actualBank];
            if (!bnk) return;
            encodeValue(previewBuffer, bnk.dataOffset, loc.actualValueIdx, value);
        }
        
        function applyEncoderToPreviewBuffer(setupIdx, group, enc, data) {
            const idx = group * 8 + enc;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            const accDisp = ((data.acc & 0x0F) << 4) | (data.display & 0x0F);
            setPreviewValue(setupIdx, 0x1C, 0x00, idx, chanType);
            setPreviewValue(setupIdx, 0x1C, 0x40, idx, data.cc || data.number || 0);
            setPreviewValue(setupIdx, 0x1C, 0x80, idx, data.min || 0);
            setPreviewValue(setupIdx, 0x1C, 0xC0, idx, data.max !== undefined ? data.max : 127);
            setPreviewValue(setupIdx, 0x1D, 0x00, idx, accDisp);
        }
        
        function applyPushToPreviewBuffer(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            setPreviewValue(setupIdx, 0x1E, 0x00, idx, chanType);
            setPreviewValue(setupIdx, 0x1E, 0x40, idx, data.number || 0);
            setPreviewValue(setupIdx, 0x1E, 0x80, idx, data.lower || 0);
            setPreviewValue(setupIdx, 0x1E, 0xC0, idx, data.upper !== undefined ? data.upper : 127);
        }
        
        function applyGreenToPreviewBuffer(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            setPreviewValue(setupIdx, 0x1F, 0x00, idx, chanType);
            setPreviewValue(setupIdx, 0x1F, 0x40, idx, data.number || 0);
            setPreviewValue(setupIdx, 0x1F, 0x80, idx, data.lower || 0);
            setPreviewValue(setupIdx, 0x1F, 0xC0, idx, data.upper !== undefined ? data.upper : 127);
        }
        
        function applyFaderToPreviewBuffer(setupIdx, group, fader, data) {
            const idx = group * 8 + fader;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            setPreviewValue(setupIdx, 0x20, 0x00, idx, chanType);
            setPreviewValue(setupIdx, 0x20, 0x40, idx, data.cc || data.number || 0);
            setPreviewValue(setupIdx, 0x20, 0x80, idx, data.min || 0);
            setPreviewValue(setupIdx, 0x20, 0xC0, idx, data.max !== undefined ? data.max : 127);
        }
        
        function applyFader9ToPreviewBuffer(setupIdx, group, data) {
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            setPreviewValue(setupIdx, 0x21, 0x00, group, chanType);
            setPreviewValue(setupIdx, 0x21, 0x40, group, data.cc || data.number || 0);
            setPreviewValue(setupIdx, 0x21, 0x80, group, data.min || 0);
            setPreviewValue(setupIdx, 0x21, 0xC0, group, data.max !== undefined ? data.max : 127);
        }
        
        function applyGroupNameToPreviewBuffer(setupIdx, group, name) {
            const result = stringToGroupNameValues(name);
            if (result.error) return;
            
            const baseIdx = setupIdx * 8 + group;
            for (let i = 0; i < 4; i++) {
                setPreviewValue(0, 0x1B, i * 0x40, baseIdx, result.values[i]);
            }
        }
        
        function renderPreviewBanner() {
            // Remove existing banner
            const existing = document.getElementById('previewBanner');
            if (existing) existing.remove();
            
            if (!previewMode || !previewEntry) return;
            
            const banner = document.createElement('div');
            banner.id = 'previewBanner';
            banner.className = 'preview-banner';
            banner.innerHTML = `
                <div class="preview-banner-text">
                    <span class="preview-banner-icon">&#9888;</span>
                    <span>
                        <span class="preview-banner-title">Preview: ${escapeHtml(previewEntry.name)}</span>
                        <span class="preview-banner-subtitle"> &mdash; Read-only preview</span>
                    </span>
                </div>
                <div class="preview-banner-actions">
                    <button class="btn" onclick="exitPreviewMode()">Close Preview</button>
                    <button class="btn btn-primary" onclick="importFromPreview()">Import This Config</button>
                </div>
            `;
            
            // Insert after header
            const mainContent = document.getElementById('mainContent');
            if (mainContent) {
                mainContent.parentNode.insertBefore(banner, mainContent);
            }
        }
        
        function exitPreviewMode() {
            if (!previewMode) return;
            
            // Restore UI state
            if (prePreviewState) {
                currentSetup = prePreviewState.currentSetup;
                encoderGroup = prePreviewState.encoderGroup;
                faderGroup = prePreviewState.faderGroup;
                currentView = prePreviewState.currentView;
                if (typeof overviewTab !== 'undefined') {
                    overviewTab = prePreviewState.overviewTab;
                }
            }
            
            // Clear preview state
            previewBuffer = null;
            previewMode = false;
            previewEntry = null;
            previewConfigData = null;
            previewLabels.clear();
            prePreviewState = null;
            
            // Update UI
            document.body.classList.remove('preview-mode');
            const banner = document.getElementById('previewBanner');
            if (banner) banner.remove();
            
            updateUndoRedoUI();
            renderCurrentView();
            updateSetupDropdownLabels();
            
            // Reopen library modal
            openLibraryModal();
        }
        
        function importFromPreview() {
            if (!previewMode || !previewEntry || !previewConfigData) {
                showToast('No preview active', 'error');
                return;
            }
            
            // Store entry/config for import dialog
            const entry = previewEntry;
            const configData = previewConfigData;
            
            // Exit preview mode first
            previewBuffer = null;
            previewMode = false;
            previewEntry = null;
            previewConfigData = null;
            previewLabels.clear();
            prePreviewState = null;
            document.body.classList.remove('preview-mode');
            const banner = document.getElementById('previewBanner');
            if (banner) banner.remove();
            
            // Show import dialog (Phase 4)
            showImportDialog(entry, configData);
        }
        
        async function showHashMismatchDialog() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal-dialog">
                        <h3>&#9888; Content Verification Failed</h3>
                        <p>The configuration file doesn't match the expected content. This could indicate:</p>
                        <ul style="margin: 0.5rem 0 1rem 1.5rem; font-size: 0.85rem; color: var(--text-dim);">
                            <li>File updated but index wasn't</li>
                            <li>Network corruption</li>
                            <li>File tampering</li>
                        </ul>
                        <p>Do you want to continue anyway?</p>
                        <div class="modal-actions">
                            <button class="btn" id="hashCancelBtn">Cancel</button>
                            <button class="btn btn-primary" id="hashContinueBtn">Continue</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                overlay.querySelector('#hashCancelBtn').onclick = () => {
                    overlay.remove();
                    resolve(false);
                };
                
                overlay.querySelector('#hashContinueBtn').onclick = () => {
                    overlay.remove();
                    resolve(true);
                };
            });
        }
        
        // Placeholder for Phase 4
        function showImportDialog(entry, configData) {
            const setupCount = configData.format === 'uc4-editor-setup' ? 1 : configData.setups.length;
            
            // Determine which dialog type
            if (setupCount === 1) {
                showSingleSetupImportDialog(entry, configData);
            } else if (setupCount === 18) {
                showFullImportDialog(entry, configData);
            } else {
                showPartialImportDialog(entry, configData, setupCount);
            }
        }
        
        function showSingleSetupImportDialog(entry, configData) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'libraryImportOverlay';
            
            // Check if source has a label
            const sourceLabel = configData.label || '';
            const hasSourceLabel = sourceLabel.length > 0;
            
            overlay.innerHTML = `
                <div class="modal-dialog" style="max-width: 400px;">
                    <h3>Import: ${escapeHtml(entry.name)}</h3>
                    <p style="margin-bottom: 1rem;">Select target setup slot:</p>
                    <div class="setup-subdialog-grid" id="importSlotGrid"></div>
                    ${hasSourceLabel ? `
                        <label class="setup-subdialog-checkbox" style="margin-top: 1rem;">
                            <input type="checkbox" id="importLabelCheckbox" checked>
                            Apply label "${escapeHtml(sourceLabel)}"
                        </label>
                    ` : ''}
                    <div class="modal-actions" style="margin-top: 1.5rem;">
                        <button class="btn" onclick="closeLibraryImportDialog()">Cancel</button>
                        <button class="btn btn-primary" id="importConfirmBtn" disabled>Import</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Store state
            overlay._entry = entry;
            overlay._configData = configData;
            overlay._selectedSlot = null;
            
            // Render slot grid
            renderImportSlotGrid();
            
            // Wire up confirm button
            document.getElementById('importConfirmBtn').onclick = () => {
                performLibrarySingleImport();
            };
        }
        
        function renderImportSlotGrid() {
            const grid = document.getElementById('importSlotGrid');
            if (!grid) return;
            
            const overlay = document.getElementById('libraryImportOverlay');
            
            let html = '';
            for (let i = 0; i < 18; i++) {
                const label = setupLabels.get(i);
                const hasLabel = label && label.length > 0;
                const isFactory = differsFromFactory(i) === false && !hasLabel;
                
                let indicator = '';
                if (hasLabel) indicator = '&#9642;'; // small black square
                else if (isFactory) indicator = '&#9670;'; // black diamond
                
                const selected = overlay._selectedSlot === i ? 'selected' : '';
                
                html += `<div class="setup-subdialog-item ${selected}" data-slot="${i}" onclick="selectImportSlot(${i})">
                    ${i + 1}${indicator}
                </div>`;
            }
            
            grid.innerHTML = html;
        }
        
        function selectImportSlot(slot) {
            const overlay = document.getElementById('libraryImportOverlay');
            if (!overlay) return;
            
            overlay._selectedSlot = slot;
            renderImportSlotGrid();
            
            document.getElementById('importConfirmBtn').disabled = false;
        }
        
        function performLibrarySingleImport() {
            const overlay = document.getElementById('libraryImportOverlay');
            if (!overlay || overlay._selectedSlot === null) return;
            
            const entry = overlay._entry;
            const configData = overlay._configData;
            const targetSlot = overlay._selectedSlot;
            const importLabel = document.getElementById('importLabelCheckbox')?.checked ?? false;
            
            // Get source data
            const sourceGroups = configData.groups;
            const sourceLabel = configData.label || '';
            
            // Capture before state
            const beforeSnapshot = captureSetupSnapshot(targetSlot);
            const labelBefore = setupLabels.get(targetSlot) || null;
            
            // Build snapshot from source and apply
            const importedSnapshot = {
                groups: sourceGroups.map((g, gIdx) => ({
                    name: g.name || `Grp${gIdx + 1}`,
                    encoders: g.encoders,
                    pushButtons: g.pushButtons,
                    greenButtons: g.greenButtons,
                    faders: g.faders,
                    fader9: g.fader9
                }))
            };
            
            restoreSetupSnapshot(targetSlot, importedSnapshot);
            
            // Handle label
            if (importLabel && sourceLabel) {
                const sanitized = sourceLabel.slice(0, 12).replace(/[^a-zA-Z0-9 \\-_]/g, '');
                if (sanitized) {
                    setupLabels.set(targetSlot, sanitized);
                } else {
                    setupLabels.delete(targetSlot);
                }
            }
            
            // Capture after state
            const afterSnapshot = captureSetupSnapshot(targetSlot);
            const labelAfter = setupLabels.get(targetSlot) || null;
            
            // Record undo
            recordUndo({
                type: 'library-import',
                description: `Import "${entry.name}" to Setup ${targetSlot + 1}`,
                affectedSlots: [targetSlot],
                beforeSnapshots: [{ index: targetSlot, snapshot: beforeSnapshot, label: labelBefore }],
                afterSnapshots: [{ index: targetSlot, snapshot: afterSnapshot, label: labelAfter }]
            });
            
            // Update state
            invalidateDiffCache(targetSlot);
            dirtySinceLoad = true;
            markModified();
            
            // Close dialog and cleanup preview mode if active
            closeLibraryImportDialog();
            exitPreviewModeIfActive();
            
            refreshMainEditorIfNeeded([targetSlot]);
            updateSetupDropdownLabels();
            
            // Track library source
            librarySourceMap.set(targetSlot, entry.name);
            updateLibrarySourceBadge();
            
            showToast(`Imported to Setup ${targetSlot + 1}`, 'success');
        }
        
        function showFullImportDialog(entry, configData) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'libraryImportOverlay';
            
            // Check for unsaved changes
            const modifiedSetups = [];
            for (let i = 0; i < 18; i++) {
                if (differsFromFactory(i)) {
                    const label = setupLabels.get(i);
                    modifiedSetups.push(label ? `Setup ${i + 1} (${label})` : `Setup ${i + 1}`);
                }
            }
            
            // Check if source has labels
            const hasSourceLabels = configData.labels && configData.labels.some(l => l && l.length > 0);
            
            overlay.innerHTML = `
                <div class="modal-dialog" style="max-width: 450px;">
                    <h3>Import: ${escapeHtml(entry.name)}</h3>
                    <p style="color: var(--warning); margin-bottom: 1rem;">
                        &#9888; This will replace ALL 18 setups
                    </p>
                    ${modifiedSetups.length > 0 ? `
                        <p style="margin-bottom: 0.5rem;">Current session has changes in:</p>
                        <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 1rem;">
                            ${escapeHtml(modifiedSetups.slice(0, 5).join(', '))}${modifiedSetups.length > 5 ? ` (+${modifiedSetups.length - 5} more)` : ''}
                        </p>
                    ` : ''}
                    <p style="margin-bottom: 0.5rem;">Label handling:</p>
                    <label style="display: block; margin-bottom: 0.5rem; cursor: pointer;">
                        <input type="radio" name="labelOption" value="import" checked>
                        Import labels from config
                    </label>
                    <label style="display: block; margin-bottom: 1rem; cursor: pointer;">
                        <input type="radio" name="labelOption" value="keep">
                        Keep my existing labels
                    </label>
                    <div class="modal-actions">
                        <button class="btn" onclick="closeLibraryImportDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="performLibraryFullImport()">Replace All</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Store state
            overlay._entry = entry;
            overlay._configData = configData;
        }
        
        function performLibraryFullImport() {
            const overlay = document.getElementById('libraryImportOverlay');
            if (!overlay) return;
            
            const entry = overlay._entry;
            const configData = overlay._configData;
            const importLabels = document.querySelector('input[name="labelOption"]:checked')?.value === 'import';
            
            // Capture before state for all 18 setups
            const beforeSnapshots = [];
            for (let i = 0; i < 18; i++) {
                beforeSnapshots.push({
                    index: i,
                    snapshot: captureSetupSnapshot(i),
                    label: setupLabels.get(i) || null
                });
            }
            
            // Apply all setups
            for (const setup of configData.setups) {
                const targetSlot = setup.index;
                const importedSnapshot = {
                    groups: setup.groups.map((g, gIdx) => ({
                        name: g.name || `Grp${gIdx + 1}`,
                        encoders: g.encoders,
                        pushButtons: g.pushButtons,
                        greenButtons: g.greenButtons,
                        faders: g.faders,
                        fader9: g.fader9
                    }))
                };
                restoreSetupSnapshot(targetSlot, importedSnapshot);
            }
            
            // Handle labels
            if (importLabels) {
                setupLabels.clear();
                if (configData.labels) {
                    configData.labels.forEach((label, i) => {
                        if (label && label.length > 0) {
                            const sanitized = label.slice(0, 12).replace(/[^a-zA-Z0-9 \\-_]/g, '');
                            if (sanitized) setupLabels.set(i, sanitized);
                        }
                    });
                }
            }
            
            // Capture after state
            const afterSnapshots = [];
            for (let i = 0; i < 18; i++) {
                afterSnapshots.push({
                    index: i,
                    snapshot: captureSetupSnapshot(i),
                    label: setupLabels.get(i) || null
                });
            }
            
            // Record undo
            recordUndo({
                type: 'library-import',
                description: `Import "${entry.name}" (all 18 setups)`,
                affectedSlots: Array.from({ length: 18 }, (_, i) => i),
                beforeSnapshots,
                afterSnapshots
            });
            
            // Invalidate all caches
            for (let i = 0; i < 18; i++) {
                invalidateDiffCache(i);
            }
            dirtySinceLoad = true;
            markModified();
            
            // Close and cleanup
            closeLibraryImportDialog();
            exitPreviewModeIfActive();
            
            refreshMainEditorIfNeeded(Array.from({ length: 18 }, (_, i) => i));
            updateSetupDropdownLabels();
            
            // Track library source for all 18 setups
            for (let i = 0; i < 18; i++) {
                librarySourceMap.set(i, entry.name);
            }
            updateLibrarySourceBadge();
            
            showToast('Imported all 18 setups', 'success');
        }
        
        function showPartialImportDialog(entry, configData, setupCount) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'libraryImportOverlay';
            
            // Build dropdown options (max starting slot is 18 - setupCount)
            const maxStart = 18 - setupCount;
            let options = '';
            for (let i = 0; i <= maxStart; i++) {
                options += `<option value="${i}">${i + 1}</option>`;
            }
            
            // Check if source has labels
            const hasSourceLabels = configData.labels && configData.labels.some(l => l && l.length > 0);
            
            overlay.innerHTML = `
                <div class="modal-dialog" style="max-width: 400px;">
                    <h3>Import: ${escapeHtml(entry.name)}</h3>
                    <p style="margin-bottom: 1rem;">
                        Import ${setupCount} setups starting at slot:
                        <select id="partialStartSlot" onchange="updatePartialImportPreview()" style="margin-left: 0.5rem;">
                            ${options}
                        </select>
                    </p>
                    <p id="partialSlotPreview" style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 1rem;"></p>
                    ${hasSourceLabels ? `
                        <label class="setup-subdialog-checkbox">
                            <input type="checkbox" id="partialImportLabels" checked>
                            Import labels from config
                        </label>
                    ` : ''}
                    <div class="modal-actions" style="margin-top: 1.5rem;">
                        <button class="btn" onclick="closeLibraryImportDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="performLibraryPartialImport()">Import</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Store state
            overlay._entry = entry;
            overlay._configData = configData;
            overlay._setupCount = setupCount;
            
            // Initial preview
            updatePartialImportPreview();
        }
        
        function updatePartialImportPreview() {
            const overlay = document.getElementById('libraryImportOverlay');
            if (!overlay) return;
            
            const startSlot = parseInt(document.getElementById('partialStartSlot').value);
            const count = overlay._setupCount;
            const endSlot = startSlot + count - 1;
            
            const slots = [];
            for (let i = startSlot; i <= endSlot; i++) {
                slots.push(i + 1);
            }
            
            document.getElementById('partialSlotPreview').textContent = 
                `This will fill slots ${slots.join(', ')}`;
        }
        
        function performLibraryPartialImport() {
            const overlay = document.getElementById('libraryImportOverlay');
            if (!overlay) return;
            
            const entry = overlay._entry;
            const configData = overlay._configData;
            const startSlot = parseInt(document.getElementById('partialStartSlot').value);
            const setupCount = overlay._setupCount;
            const importLabels = document.getElementById('partialImportLabels')?.checked ?? false;
            
            // Capture before state
            const beforeSnapshots = [];
            const affectedSlots = [];
            for (let i = 0; i < setupCount; i++) {
                const targetSlot = startSlot + i;
                affectedSlots.push(targetSlot);
                beforeSnapshots.push({
                    index: targetSlot,
                    snapshot: captureSetupSnapshot(targetSlot),
                    label: setupLabels.get(targetSlot) || null
                });
            }
            
            // Apply setups
            for (let i = 0; i < setupCount; i++) {
                const sourceSetup = configData.setups[i];
                const targetSlot = startSlot + i;
                
                const importedSnapshot = {
                    groups: sourceSetup.groups.map((g, gIdx) => ({
                        name: g.name || `Grp${gIdx + 1}`,
                        encoders: g.encoders,
                        pushButtons: g.pushButtons,
                        greenButtons: g.greenButtons,
                        faders: g.faders,
                        fader9: g.fader9
                    }))
                };
                restoreSetupSnapshot(targetSlot, importedSnapshot);
                
                // Handle label for this slot
                if (importLabels && configData.labels && configData.labels[i]) {
                    const label = configData.labels[i];
                    const sanitized = label.slice(0, 12).replace(/[^a-zA-Z0-9 \\-_]/g, '');
                    if (sanitized) {
                        setupLabels.set(targetSlot, sanitized);
                    } else {
                        setupLabels.delete(targetSlot);
                    }
                }
            }
            
            // Capture after state
            const afterSnapshots = [];
            for (let i = 0; i < setupCount; i++) {
                const targetSlot = startSlot + i;
                afterSnapshots.push({
                    index: targetSlot,
                    snapshot: captureSetupSnapshot(targetSlot),
                    label: setupLabels.get(targetSlot) || null
                });
            }
            
            // Record undo
            recordUndo({
                type: 'library-import',
                description: `Import "${entry.name}" to Setups ${startSlot + 1}-${startSlot + setupCount}`,
                affectedSlots,
                beforeSnapshots,
                afterSnapshots
            });
            
            // Invalidate caches
            for (const slot of affectedSlots) {
                invalidateDiffCache(slot);
            }
            dirtySinceLoad = true;
            markModified();
            
            // Close and cleanup
            closeLibraryImportDialog();
            exitPreviewModeIfActive();
            
            refreshMainEditorIfNeeded(affectedSlots);
            updateSetupDropdownLabels();
            
            // Track library source for affected slots
            for (const slot of affectedSlots) {
                librarySourceMap.set(slot, entry.name);
            }
            updateLibrarySourceBadge();
            
            showToast(`Imported ${setupCount} setups starting at slot ${startSlot + 1}`, 'success');
        }
        
        function closeLibraryImportDialog() {
            const overlay = document.getElementById('libraryImportOverlay');
            if (overlay) overlay.remove();
        }
        
        function exitPreviewModeIfActive() {
            if (previewMode) {
                // Clean exit without reopening library
                previewBuffer = null;
                previewMode = false;
                previewEntry = null;
                previewConfigData = null;
                previewLabels.clear();
                prePreviewState = null;
                document.body.classList.remove('preview-mode');
                const banner = document.getElementById('previewBanner');
                if (banner) banner.remove();
                updateUndoRedoUI();
                renderCurrentView();
            }
        }
        
        function refreshMainEditorIfNeeded(affectedSlots) {
            if (affectedSlots.includes(currentSetup)) {
                renderCurrentView();
            }
            updateGroupNames();
        }
        
        function importLibraryEntry(entryId) {
            // Direct import (skip preview)
            if (!libraryState.index) return;
            
            const entry = libraryState.index.entries.find(e => e.id === entryId);
            if (!entry) {
                showToast('Config not found', 'error');
                return;
            }
            
            closeLibraryModal();
            
            fetchLibraryConfig(entry).then(async (configResult) => {
                // Check hash
                if (!configResult.hashVerified) {
                    const proceed = await showHashMismatchDialog();
                    if (!proceed) {
                        openLibraryModal();
                        return;
                    }
                }
                
                // Validate
                const validation = validateConfigForPreview(configResult.json, entry);
                if (!validation.valid) {
                    showToast(validation.error, 'error');
                    openLibraryModal();
                    return;
                }
                
                // Check versions
                const schemaCheck = checkSchemaCompatibility(configResult.json.version);
                if (!schemaCheck.allowed) {
                    showToast(schemaCheck.message, 'error');
                    openLibraryModal();
                    return;
                }
                
                const editorCheck = checkEditorMinVersion(entry.minEditorVersion);
                if (!editorCheck.allowed) {
                    showToast(editorCheck.message, 'error');
                    openLibraryModal();
                    return;
                }
                
                // Show import dialog
                showImportDialog(entry, configResult.json);
                
            }).catch(error => {
                console.error('Import error:', error);
                showToast(error.message || 'Failed to load config', 'error');
                openLibraryModal();
            });
        }
        
        // ============================================================
        // Share Dialog (Phase 5)
        // ============================================================
        
        const CANONICAL_DEVICES = [
            { id: 'generic', name: 'Generic' },
            { id: 'ableton-live', name: 'Ableton Live' },
            { id: 'bitwig-studio', name: 'Bitwig Studio' },
            { id: 'korg-wavestate', name: 'Korg Wavestate' },
            { id: 'korg-drumlogue', name: 'Korg Drumlogue' },
            { id: 'roland-tr6s', name: 'Roland TR-6S' },
            { id: 'squarp-hapax', name: 'Squarp Hapax' },
            { id: 'elektron-digitakt', name: 'Elektron Digitakt' },
            { id: 'elektron-syntakt', name: 'Elektron Syntakt' },
            { id: 'other', name: 'Other (specify in description)' }
        ];
        
        const CANONICAL_TAGS = [
            // Device categories
            'synth', 'sequencer', 'drum-machine', 'effects', 'daw', 'sampler', 'groovebox',
            // Manufacturers
            'korg', 'roland', 'squarp', 'elektron', 'arturia', 'ableton', 'bitwig', 'native-instruments',
            // Use cases
            'performance', 'studio', 'live', 'mixing', 'sound-design',
            // Config types
            'complete', 'template', 'minimal'
        ];
        
        let shareDialogState = {
            selectedTags: new Set(),
            sourceType: 'current' // 'current' or 'setup-N'
        };
        
        function shareFromSetupManager() {
            if (setupManagerSelection.size !== 1) return;
            const setupIdx = [...setupManagerSelection][0];
            openShareDialog(setupIdx);
        }
        
        function openShareDialog(sourceSetup = null) {
            // Close library modal if open
            closeLibraryModal();
            // Close setup manager if open
            closeSetupManager();
            
            shareDialogState.selectedTags.clear();
            shareDialogState.sourceType = sourceSetup !== null ? `setup-${sourceSetup}` : 'current';
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'shareDialogOverlay';
            
            // Build device options
            let deviceOptions = CANONICAL_DEVICES.map(d => 
                `<option value="${d.id}">${escapeHtml(d.name)}</option>`
            ).join('');
            
            // Build tag chips
            let tagChips = CANONICAL_TAGS.map(tag =>
                `<span class="share-tag" data-tag="${tag}" onclick="toggleShareTag('${tag}')">${tag}</span>`
            ).join('');
            
            // Source info
            let sourceInfo = '';
            if (sourceSetup !== null) {
                const label = setupLabels.get(sourceSetup);
                sourceInfo = `Setup ${sourceSetup + 1}${label ? ` (${escapeHtml(label)})` : ''}`;
            } else {
                sourceInfo = 'Current Setup (Setup ' + (currentSetup + 1) + ')';
            }
            
            overlay.innerHTML = `
                <div class="modal-dialog share-dialog">
                    <h3>Submit to Library</h3>
                    
                    <div class="share-source">
                        <div class="share-source-label">Sharing:</div>
                        <div>${sourceInfo}</div>
                    </div>
                    
                    <div class="share-field">
                        <label for="shareName">Config Name *</label>
                        <input type="text" id="shareName" maxlength="100" placeholder="e.g., Korg Wavestate Performance">
                        <div class="char-count"><span id="shareNameCount">0</span>/100</div>
                    </div>
                    
                    <div class="share-field">
                        <label for="shareDevice">Target Device *</label>
                        <select id="shareDevice">
                            <option value="">Select device...</option>
                            ${deviceOptions}
                        </select>
                    </div>
                    
                    <div class="share-field">
                        <label for="shareDescription">Description *</label>
                        <textarea id="shareDescription" maxlength="300" placeholder="Describe what this config does, which controls map to what, etc."></textarea>
                        <div class="char-count"><span id="shareDescCount">0</span>/300</div>
                    </div>
                    
                    <div class="share-field">
                        <label>Tags * (select 1-5)</label>
                        <div class="share-tags" id="shareTagsContainer">
                            ${tagChips}
                        </div>
                        <div class="share-tag-count"><span id="shareTagCount">0</span>/5 selected</div>
                    </div>
                    
                    <div class="share-field">
                        <label for="shareAuthor">Your Name *</label>
                        <input type="text" id="shareAuthor" maxlength="50" placeholder="GitHub username or display name">
                        <div class="char-count"><span id="shareAuthorCount">0</span>/50</div>
                    </div>
                    
                    <div class="modal-actions">
                        <button class="btn" onclick="closeShareDialog()">Cancel</button>
                        <button class="btn btn-primary" id="shareSubmitBtn" onclick="submitShare()" disabled>Submit</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Wire up character counters
            document.getElementById('shareName').addEventListener('input', updateShareValidation);
            document.getElementById('shareDescription').addEventListener('input', updateShareValidation);
            document.getElementById('shareAuthor').addEventListener('input', updateShareValidation);
            document.getElementById('shareDevice').addEventListener('change', updateShareValidation);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeShareDialog();
            });
            
            // Escape key
            overlay.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeShareDialog();
            });
            
            // Focus first field
            setTimeout(() => {
                document.getElementById('shareName')?.focus();
            }, 50);
        }
        
        function toggleShareTag(tag) {
            if (shareDialogState.selectedTags.has(tag)) {
                shareDialogState.selectedTags.delete(tag);
            } else if (shareDialogState.selectedTags.size < 5) {
                shareDialogState.selectedTags.add(tag);
            }
            
            // Update UI
            document.querySelectorAll('.share-tag').forEach(el => {
                const t = el.dataset.tag;
                el.classList.toggle('selected', shareDialogState.selectedTags.has(t));
            });
            
            document.getElementById('shareTagCount').textContent = shareDialogState.selectedTags.size;
            updateShareValidation();
        }
        
        function updateShareValidation() {
            const name = document.getElementById('shareName').value.trim();
            const device = document.getElementById('shareDevice').value;
            const description = document.getElementById('shareDescription').value.trim();
            const author = document.getElementById('shareAuthor').value.trim();
            const tagCount = shareDialogState.selectedTags.size;
            
            // Update counts
            document.getElementById('shareNameCount').textContent = name.length;
            document.getElementById('shareDescCount').textContent = description.length;
            document.getElementById('shareAuthorCount').textContent = author.length;
            
            // Highlight if near limit
            document.getElementById('shareNameCount').parentElement.classList.toggle('warning', name.length > 90);
            document.getElementById('shareDescCount').parentElement.classList.toggle('warning', description.length > 280);
            
            // Validate
            const valid = name.length >= 1 && name.length <= 100 &&
                          device !== '' &&
                          description.length >= 1 && description.length <= 300 &&
                          author.length >= 1 && author.length <= 50 &&
                          tagCount >= 1 && tagCount <= 5;
            
            document.getElementById('shareSubmitBtn').disabled = !valid;
        }
        
        function closeShareDialog() {
            const overlay = document.getElementById('shareDialogOverlay');
            if (overlay) overlay.remove();
        }
        
        function submitShare() {
            const name = document.getElementById('shareName').value.trim();
            const device = document.getElementById('shareDevice').value;
            const deviceName = CANONICAL_DEVICES.find(d => d.id === device)?.name || device;
            const description = document.getElementById('shareDescription').value.trim();
            const author = document.getElementById('shareAuthor').value.trim();
            const tags = Array.from(shareDialogState.selectedTags);
            
            // Generate config JSON
            let configJson;
            if (shareDialogState.sourceType === 'current') {
                configJson = generateSetupJson(currentSetup);
            } else {
                const setupIdx = parseInt(shareDialogState.sourceType.replace('setup-', ''));
                configJson = generateSetupJson(setupIdx);
            }
            
            // Open GitHub issue
            openShareIssue({
                name,
                device: deviceName,
                description,
                tags,
                author,
                configJson
            });
            
            closeShareDialog();
        }
        
        function generateSetupJson(setupIdx) {
            // Generate single setup export JSON
            const snapshot = captureSetupSnapshot(setupIdx);
            const label = setupLabels.get(setupIdx) || '';
            
            const config = {
                format: 'uc4-editor-setup',
                version: SUPPORTED_SCHEMA_VERSION,
                exportedBy: {
                    app: 'uc4-sysex-editor',
                    version: CURRENT_EDITOR_VERSION
                },
                exported: new Date().toISOString(),
                sourceSetup: setupIdx,
                label: label,
                groups: snapshot.groups.map((g, i) => ({
                    index: i,
                    name: g.name,
                    encoders: g.encoders,
                    pushButtons: g.pushButtons,
                    greenButtons: g.greenButtons,
                    faders: g.faders,
                    fader9: g.fader9
                }))
            };
            
            return JSON.stringify(config, null, 2);
        }
        
        const URL_LENGTH_LIMIT = 8000;
        
        function openShareIssue(shareData) {
            const { name, device, description, tags, author, configJson } = shareData;
            
            const metadata = `## Config Submission
**Name:** ${name}
**Device:** ${device}
**Author:** ${author}
**Tags:** ${tags.join(', ')}

## Description
${description}

## Checklist
- [ ] Tested with UC4 editor
- [ ] Description explains the mapping
- [ ] Agree to MIT license
`;

            const title = encodeURIComponent(`[Library] ${name}`);
            
            if ((metadata + configJson).length < URL_LENGTH_LIMIT) {
                const body = encodeURIComponent(metadata + '\n## JSON\n```json\n' + configJson + '\n```');
                window.open(`https://github.com/thegdyne/uc4-sysex-editor/issues/new?title=${title}&body=${body}&labels=library-submission`, '_blank');
            } else {
                navigator.clipboard.writeText(configJson).then(() => {
                    showToast('JSON copied to clipboard', 'success');
                }).catch(() => {
                    // Fallback if clipboard fails
                    console.warn('Clipboard write failed');
                });
                const body = encodeURIComponent(metadata + '\n## JSON\nâš Ã¯Â¸Â Config too large for URL. Paste from clipboard:\n```json\n(paste here)\n```');
                window.open(`https://github.com/thegdyne/uc4-sysex-editor/issues/new?title=${title}&body=${body}&labels=library-submission`, '_blank');
            }
        }
        
        // Truncate text helper
        function truncateText(text, maxLen) {
            if (text.length <= maxLen) return text;
            return text.slice(0, maxLen - 3) + '...';
        }
        
        initUI();
        initTooltipSystem();
        
        // Set version display in footer
        document.getElementById('versionDisplay').textContent = CURRENT_EDITOR_VERSION;
        
        initializeEditor();
    </script>
</body>
</html>

