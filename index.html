<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UC4 SysEx Editor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Orbitron:wght@400;500;700&display=swap');
        
        :root {
            --bg-dark: #0a0a0c;
            --bg-panel: #111114;
            --bg-control: #18181c;
            --bg-input: #1e1e24;
            --border: #2a2a32;
            --border-light: #3a3a44;
            --text: #e0e0e8;
            --text-dim: #888898;
            --text-muted: #555560;
            --accent: #00d4aa;
            --accent-dim: #00a888;
            --warning: #ffaa00;
            --error: #ff4466;
            --encoder: #00aaff;
            --push: #aa66ff;
            --green-btn: #44dd66;
            --fader: #ff8844;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.4;
        }
        
        /* Header */
        .header {
            background: linear-gradient(180deg, var(--bg-panel) 0%, var(--bg-dark) 100%);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        .logo span {
            color: var(--text-dim);
            font-weight: 400;
        }
        
        .file-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .btn {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: var(--accent);
            color: var(--bg-dark);
            border-color: var(--accent);
            font-weight: 600;
        }
        
        .btn-primary:hover {
            background: var(--accent-dim);
            border-color: var(--accent-dim);
            color: var(--bg-dark);
        }
        
        .btn-divider {
            display: inline-block;
            width: 1px;
            height: 1.5rem;
            background: var(--border);
            margin: 0 0.5rem;
            vertical-align: middle;
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .toast {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 0.75rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
        }
        
        .toast.error {
            border-color: var(--error);
            color: var(--error);
        }
        
        .toast.success {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Restore Dialog */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .modal-dialog {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
        }
        
        .modal-dialog h3 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent);
            margin-bottom: 1rem;
        }
        
        .modal-dialog p {
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }
        
        .modal-dialog .info {
            background: var(--bg-input);
            padding: 0.75rem;
            margin: 1rem 0;
            font-size: 0.8rem;
        }
        
        .modal-dialog label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-dim);
            margin: 1rem 0;
            cursor: pointer;
        }
        
        .modal-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        
        /* Overview Mode */
        .overview-container {
            padding: 1rem;
        }
        
        .overview-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .overview-tab {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .overview-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .overview-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .overview-grid {
            overflow-x: auto;
        }
        
        .overview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        
        .overview-table th,
        .overview-table td {
            border: 1px solid var(--border);
            padding: 0.4rem 0.5rem;
            text-align: center;
            min-width: 80px;
        }
        
        .overview-table th {
            background: var(--bg-panel);
            color: var(--text-dim);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .overview-table th.group-header {
            color: var(--accent);
        }
        
        .overview-table th.row-header {
            text-align: left;
            width: 70px;
            min-width: 70px;
        }
        
        .overview-table td {
            background: var(--bg-input);
            cursor: pointer;
            transition: background 0.1s;
        }
        
        .overview-table td:hover {
            background: var(--bg-control);
        }
        
        .overview-table td.conflict {
            background: rgba(255, 170, 0, 0.2);
        }
        
        .overview-table td.conflict-dim {
            background: rgba(255, 170, 0, 0.1);
        }
        
        .overview-table td.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
            background: rgba(0, 255, 170, 0.15);
        }
        
        .overview-table td.selected.conflict {
            background: rgba(255, 170, 0, 0.3);
        }
        
        .overview-table td.selected.conflict-dim {
            background: rgba(255, 170, 0, 0.2);
        }
        
        .overview-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        
        .overview-cell .conflict-icon {
            color: var(--warning);
            font-size: 0.65rem;
        }
        
        .group-name-row td {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            color: var(--text-muted);
            background: var(--bg-panel) !important;
            padding: 0.2rem 0.5rem;
        }
        
        /* Conflict Filter Chips */
        .conflict-filters {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
        }
        
        .conflict-filters-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 0.5rem;
        }
        
        .filter-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.15s;
            user-select: none;
        }
        
        .filter-chip:hover {
            border-color: var(--accent);
        }
        
        .filter-chip.active {
            background: var(--warning);
            border-color: var(--warning);
            color: var(--bg-dark);
        }
        
        .filter-chip.active.dim {
            background: rgba(255, 170, 0, 0.3);
            border-color: var(--warning);
            color: var(--warning);
        }
        
        .filter-chip .count {
            font-weight: 600;
        }
        
        .filter-chip .checkmark {
            font-size: 0.8rem;
        }
        
        /* Conflict Panel */
        .conflict-panel {
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .conflict-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .conflict-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
        }
        
        .conflict-item:last-child {
            border-bottom: none;
        }
        
        .conflict-item .warning-icon {
            color: var(--warning);
            flex-shrink: 0;
        }
        
        .conflict-item.dim .warning-icon {
            opacity: 0.5;
        }
        
        .conflict-key {
            color: var(--accent);
            font-weight: 600;
            margin-right: 0.5rem;
        }
        
        .conflict-refs {
            color: var(--text-dim);
        }
        
        /* Context Menu */
        .context-menu {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            min-width: 200px;
            z-index: 1000;
            padding: 0.25rem 0;
        }
        
        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text);
        }
        
        .context-menu-item:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        .context-menu-item.disabled {
            color: var(--text-muted);
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: none;
            color: var(--text-muted);
        }
        
        .context-menu-separator {
            height: 1px;
            background: var(--border);
            margin: 0.25rem 0;
        }
        
        /* Paste Special Dialog */
        .paste-special-dialog {
            max-width: 400px;
        }
        
        .paste-source {
            color: var(--accent);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }
        
        .paste-section {
            margin-bottom: 1rem;
        }
        
        .paste-section-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        
        .paste-targets label {
            display: block;
            padding: 0.25rem 0;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .paste-targets input[type="radio"] {
            margin-right: 0.5rem;
        }
        
        .paste-transforms {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .transform-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        
        .transform-row label {
            min-width: 140px;
        }
        
        .transform-row input[type="number"] {
            width: 80px;
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        
        .transform-row select {
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        
        .btn-primary {
            background: var(--accent);
            color: var(--bg-dark);
            border-color: var(--accent);
        }
        
        .btn-primary:hover {
            background: var(--accent-dim);
            border-color: var(--accent-dim);
        }
        
        /* Navigation */
        .nav-bar {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 2rem;
            flex-wrap: wrap;
        }
        
        .nav-section {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .nav-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .link-groups-toggle {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: pointer;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            transition: all 0.15s;
        }
        
        .link-groups-toggle:hover {
            border-color: var(--accent);
        }
        
        .link-groups-toggle input[type="checkbox"] {
            display: none;
        }
        
        .link-groups-toggle .link-icon {
            font-size: 0.9rem;
            opacity: 0.5;
            transition: opacity 0.15s;
        }
        
        .link-groups-toggle input:checked ~ .link-icon {
            opacity: 1;
        }
        
        .link-groups-toggle input:checked ~ .nav-label {
            color: var(--accent);
        }
        
        .select-wrapper {
            position: relative;
        }
        
        select {
            font-family: inherit;
            font-size: 0.8rem;
            padding: 0.4rem 2rem 0.4rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
            cursor: pointer;
            appearance: none;
            min-width: 100px;
        }
        
        select:hover, select:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .select-wrapper::after {
            content: 'â–¾';
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-dim);
            pointer-events: none;
            font-size: 0.7rem;
        }
        
        .group-tabs {
            display: flex;
            gap: 2px;
        }
        
        .group-tab {
            font-family: inherit;
            font-size: 0.75rem;
            width: 2rem;
            height: 2rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .group-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .group-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .group-name-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: var(--accent);
            padding: 0.4rem 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            min-width: 4rem;
            text-align: center;
        }
        
        /* Main Content */
        .main-content {
            padding: 1.5rem;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .no-data {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }
        
        .no-data h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }
        
        .no-data p {
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }
        
        /* Control Sections */
        .control-section {
            margin-bottom: 2rem;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .section-title::after {
            content: 'â€”';
            margin-left: 0.75rem;
            color: var(--border);
            font-weight: 300;
        }
        
        .section-title.encoders { color: var(--encoder); }
        .section-title.push { color: var(--push); }
        .section-title.green { color: var(--green-btn); }
        .section-title.faders { color: var(--fader); }
        .section-title.fader9 { color: var(--fader); }
        
        .section-badge {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            padding: 0.2rem 0.6rem;
            background: transparent;
            color: var(--accent);
            letter-spacing: 0.05em;
        }
        
        /* Control Grid */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
        }
        
        .control-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 0.75rem;
            transition: border-color 0.15s;
        }
        
        .control-card:hover {
            border-color: var(--border-light);
        }
        
        .control-card.encoder { border-left: 3px solid var(--encoder); }
        .control-card.push { border-left: 3px solid var(--push); }
        .control-card.green { border-left: 3px solid var(--green-btn); }
        .control-card.fader { border-left: 3px solid var(--fader); }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .control-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
        }
        
        .control-index {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.4rem;
            gap: 0.5rem;
        }
        
        .param-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            width: 3.5rem;
            flex-shrink: 0;
            text-transform: uppercase;
        }
        
        .param-input {
            flex: 1;
        }
        
        .param-input input,
        .param-input select {
            width: 100%;
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
        }
        
        .param-input input:focus,
        .param-input select:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .param-input input[type="number"] {
            -moz-appearance: textfield;
        }
        
        .param-input input::-webkit-outer-spin-button,
        .param-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Fader 9 Special */
        .fader9-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-left: 3px solid var(--fader);
            padding: 0.75rem;
            margin-top: 1rem;
        }
        
        .fader9-card .control-header {
            background: linear-gradient(90deg, rgba(255,136,68,0.1) 0%, transparent 100%);
            margin: -0.75rem -0.75rem 0.75rem -0.75rem;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        
        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 0.5rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem;
            color: var(--text-dim);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        
        .status-dot.loaded {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }
        
        .status-dot.modified {
            background: var(--warning);
            box-shadow: 0 0 8px var(--warning);
        }
        
        /* Warnings */
        .warning-badge {
            font-size: 0.6rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid var(--warning);
            color: var(--warning);
            margin-left: 0.5rem;
        }
        
        /* Hidden file input */
        .hidden-input {
            display: none;
        }
        
        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 2px;
        }
        
        .view-btn {
            font-family: inherit;
            font-size: 0.7rem;
            padding: 0.4rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
        }
        
        .view-btn:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .view-btn.active {
            background: var(--bg-input);
            border-color: var(--accent);
            color: var(--accent);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .nav-bar {
                flex-direction: column;
                gap: 1rem;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }
        
        /* Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div id="toastContainer" class="toast-container"></div>
    <header class="header">
        <div class="logo">UC4 <span>SysEx Editor</span></div>
        <div class="file-actions">
            <input type="file" id="sysexInput" accept=".syx" class="hidden-input">
            <button class="btn" onclick="document.getElementById('sysexInput').click()">Import SysEx</button>
            <button class="btn" id="exportBtn" onclick="exportSysEx()" disabled>Export SysEx</button>
            <input type="file" id="jsonInput" accept=".json" class="hidden-input">
            <button class="btn" onclick="document.getElementById('jsonInput').click()">Import JSON</button>
            <button class="btn" id="exportJsonBtn" onclick="exportJSON()" disabled>Export JSON</button>
            <span class="btn-divider"></span>
            <button class="btn" id="undoBtn" onclick="undo()" disabled title="Undo (Ctrl+Z)">â†¶ Undo</button>
            <button class="btn" id="redoBtn" onclick="redo()" disabled title="Redo (Ctrl+Y)">â†· Redo</button>
        </div>
    </header>
    
    <nav class="nav-bar">
        <div class="nav-section">
            <span class="nav-label">Setup</span>
            <div class="select-wrapper">
                <select id="setupSelect" onchange="selectSetup(this.value)" disabled>
                    <option value="">--</option>
                </select>
            </div>
        </div>
        
        <div class="nav-section">
            <label class="link-groups-toggle" title="Change both groups together">
                <input type="checkbox" id="linkGroupsCheckbox" onchange="toggleLinkGroups(this.checked)">
                <span class="link-icon">ðŸ”—</span>
                <span class="nav-label">Link</span>
            </label>
        </div>
        
        <div class="nav-section">
            <span class="nav-label">Encoder Grp</span>
            <div class="group-tabs" id="encoderGroupTabs">
                <!-- Generated by JS -->
            </div>
            <div class="group-name-display" id="encoderGroupName">----</div>
        </div>
        
        <div class="nav-section">
            <span class="nav-label">Fader/Btn Grp</span>
            <div class="group-tabs" id="faderGroupTabs">
                <!-- Generated by JS -->
            </div>
            <div class="group-name-display" id="faderGroupName">----</div>
        </div>
        
        <div class="nav-section" style="margin-left: auto;">
            <div class="view-toggle">
                <button class="view-btn active" id="focusedViewBtn" onclick="setView('focused')">Focused</button>
                <button class="view-btn" id="overviewBtn" onclick="setView('overview')">Overview</button>
            </div>
        </div>
    </nav>
    
    <main class="main-content" id="mainContent">
        <div class="no-data">
            <h2>No SysEx Data Loaded</h2>
            <p>Import a UC4 SysEx dump to begin editing.</p>
            <p>Expected file size: 100,640 bytes (all 18 setups)</p>
        </div>
    </main>
    
    <footer class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">No data loaded</span>
        </div>
        <div>
            <span id="fileInfo">--</span>
        </div>
    </footer>

    <script>
        // ============================================================
        // UC4 SysEx Editor - Core Logic
        // ============================================================
        
        // State
        let rawBuffer = null;
        let sectionIndex = null;
        let currentSetup = 0;
        let encoderGroup = 0;
        let faderGroup = 0;
        let currentView = 'focused';
        let isModified = false;
        let dirtyBanks = new Set();
        
        // Undo/Redo State
        const undoStack = [];
        const redoStack = [];
        const MAX_UNDO = 100;
        const COALESCE_WINDOW = 1000; // 1 second
        
        // Session Persistence State
        const STORAGE_KEY = 'uc4-editor-session';
        const SESSION_VERSION = 1;
        const AUTO_SAVE_DELAY = 2000; // 2 seconds
        let autoSaveTimer = null;
        
        // Conflict Detection State
        const CONFLICT_REBUILD_DELAY = 200; // 200ms
        let conflictRebuildTimer = null;
        let conflicts = { concurrent: new Map(), mutuallyExclusive: new Map() };
        let conflictsByControl = new Map(); // Quick lookup: "type-group-index" -> [conflict keys]
        
        // Conflict filter state
        let showConcurrentConflicts = true;
        let showMutuallyExclusiveConflicts = false;
        
        // Copy/Paste State
        let clipboard = null;
        let selection = {
            mode: 'none', // 'none' | 'single' | 'row' | 'column'
            controlType: null,
            group: null,
            index: null
        };
        
        // Link Groups State
        let linkGroups = false;
        
        // Parameters that affect conflict detection
        const CONFLICT_PARAMS = new Set([
            'channel', 'type', 'cc', 'note', 'typeNibble', 
            'upper', 'lower', 'mode', 'min', 'max'
        ]);
        
        // Constants
        const EXPECTED_SIZE = 100640;
        const NUM_SETUPS = 18;
        const NUM_GROUPS = 8;
        
        // Section IDs
        const SECTIONS = {
            ENCODER_CHAN_TYPE: 0x1C,
            ENCODER_ACC_DISP: 0x1D,
            PUSH_CHAN_TYPE: 0x1D,
            PUSH_CC: 0x1D,
            PUSH_LOWER: 0x1D,
            PUSH_UPPER: 0x1E,
            PUSH_MODE: 0x1E,
            GREEN_CHAN_TYPE: 0x1E,
            GREEN_CC: 0x1E,
            GREEN_LOWER: 0x1F,
            GREEN_UPPER: 0x1F,
            GREEN_MODE: 0x1F,
            FADER_CHAN_TYPE: 0x1F,
            FADER_CC: 0x20,
            FADER_MIN: 0x20,
            FADER_MAX: 0x20,
            FADER_MODE: 0x20,
            FADER9: 0x17,
            GROUP_NAMES: 0x14
        };
        
        const BANKS = {
            ENC_CHAN_TYPE: 0x00,
            ENC_CC: 0x40,
            ENC_MIN: 0x80,
            ENC_MAX: 0xC0,
            ENC_ACC_DISP: 0x00,
            PUSH_CHAN_TYPE: 0x40,
            PUSH_CC: 0x80,
            PUSH_LOWER: 0xC0,
            PUSH_UPPER: 0x00,
            PUSH_MODE: 0x40,
            GREEN_CHAN_TYPE: 0x80,
            GREEN_CC: 0xC0,
            GREEN_LOWER: 0x00,
            GREEN_UPPER: 0x40,
            GREEN_MODE: 0x80,
            FADER_CHAN_TYPE: 0xC0,
            FADER_CC: 0x00,
            FADER_MIN: 0x40,
            FADER_MAX: 0x80,
            FADER_MODE: 0xC0,
            FADER9: 0x00,
            GROUP_NAMES: 0x80
        };
        
        // Type definitions
        const ENCODER_TYPES = ['CCr1', 'CCr2', 'CCAb', 'PrGC', 'CCAh', 'Pbnd', 'AFtt'];
        const FADER_TYPES = ['CCAb', 'PrGC', 'Pbnd', 'AFtt'];
        const BUTTON_TYPES = {0x00: 'OFF', 0x10: 'Note', 0x20: 'CC', 0x30: 'PrGC', 0x40: 'AFtt'};
        const BUTTON_TYPE_VALUES = [0x00, 0x10, 0x20, 0x30, 0x40];
        const ACC_MODES = ['Acc0', 'Acc1', 'Acc2', 'Acc3'];
        const DISPLAY_MODES = ['OFF', 'Std', 'bPoL'];
        const BUTTON_DISPLAY_MODES = ['OFF', 'Std'];
        const GREEN_DISPLAY_MODES = ['OFF', 'Std', 'EXt'];
        const BUTTON_MODES = ['Momentary', 'Toggle'];
        const FADER_MODES = ['Jump', 'Snap'];
        
        // ============================================================
        // SysEx Parsing
        // ============================================================
        
        function decodeValue(buf, offset, idx) {
            const pos = offset + idx * 3;
            if (pos + 2 >= buf.length || buf[pos] !== 0x4D) return null;
            return ((buf[pos + 1] & 0x0F) << 4) | (buf[pos + 2] & 0x0F);
        }
        
        function encodeValue(buf, offset, idx, value) {
            const pos = offset + idx * 3;
            buf[pos] = 0x4D;
            buf[pos + 1] = 0x20 | ((value >> 4) & 0x0F);
            buf[pos + 2] = 0x10 | (value & 0x0F);
        }
        
        function buildIndex(buf) {
            const occ = {};
            
            for (let i = 0; i < buf.length - 10; i++) {
                if (buf[i] === 0x49 && (i === 0 || buf[i-1] !== 0x4D) && buf[i+3] === 0x4A) {
                    const secId = ((buf[i+1] & 0x0F) << 4) | (buf[i+2] & 0x0F);
                    const bank = ((buf[i+4] & 0x0F) << 4) | (buf[i+5] & 0x0F);
                    const dataOffset = i + 6;
                    
                    let pos = dataOffset;
                    while (pos < buf.length && buf[pos] === 0x4D) pos += 3;
                    const valueCount = (pos - dataOffset) / 3;
                    const checksumOffset = pos;
                    
                    if (!occ[secId]) occ[secId] = {};
                    if (!occ[secId][bank]) occ[secId][bank] = [];
                    occ[secId][bank].push({ dataOffset, valueCount, checksumOffset });
                }
            }
            
            const index = [];
            for (let setupIdx = 0; setupIdx < NUM_SETUPS; setupIdx++) {
                index[setupIdx] = {};
                for (const secId in occ) {
                    index[setupIdx][secId] = {};
                    for (const bank in occ[secId]) {
                        if (occ[secId][bank][setupIdx]) {
                            index[setupIdx][secId][bank] = occ[secId][bank][setupIdx];
                        }
                    }
                }
            }
            
            return index;
        }
        
        function recalcBankChecksum(buf, dataStart) {
            let sum = 0;
            let pos = dataStart;
            
            while (pos < buf.length && buf[pos] === 0x4D) {
                sum += ((buf[pos + 1] & 0x0F) << 4) | (buf[pos + 2] & 0x0F);
                pos += 3;
            }
            
            sum = sum & 0xFFFF;
            
            if (pos + 5 < buf.length && buf[pos] === 0x4B && buf[pos + 3] === 0x4C) {
                buf[pos + 1] = 0x20 | ((sum >> 12) & 0x0F);
                buf[pos + 2] = 0x10 | ((sum >> 8) & 0x0F);
                buf[pos + 4] = 0x20 | ((sum >> 4) & 0x0F);
                buf[pos + 5] = 0x10 | (sum & 0x0F);
            }
        }
        
        function getValue(setupIdx, secId, bank, valueIdx) {
            if (!sectionIndex || !sectionIndex[setupIdx]) return null;
            const sec = sectionIndex[setupIdx][secId];
            if (!sec) return null;
            const bnk = sec[bank];
            if (!bnk) return null;
            return decodeValue(rawBuffer, bnk.dataOffset, valueIdx);
        }
        
        function setValue(setupIdx, secId, bank, valueIdx, value) {
            if (!sectionIndex || !sectionIndex[setupIdx]) return;
            const sec = sectionIndex[setupIdx][secId];
            if (!sec) return;
            const bnk = sec[bank];
            if (!bnk) return;
            
            encodeValue(rawBuffer, bnk.dataOffset, valueIdx, value);
            dirtyBanks.add(`${setupIdx}-${secId}-${bank}`);
            markModified();
        }
        
        // ============================================================
        // Control Value Helpers
        // ============================================================
        
        function getEncoderData(setupIdx, group, enc) {
            const idx = group * 8 + enc;
            const chanType = getValue(setupIdx, 0x1C, 0x00, idx) || 0x20;
            const accDisp = getValue(setupIdx, 0x1D, 0x00, idx) || 0x31;
            
            return {
                channel: (chanType & 0x0F) + 1,
                type: (chanType >> 4) & 0x0F,
                cc: getValue(setupIdx, 0x1C, 0x40, idx) || 0,
                min: getValue(setupIdx, 0x1C, 0x80, idx) || 0,
                max: getValue(setupIdx, 0x1C, 0xC0, idx) || 127,
                acc: (accDisp >> 4) & 0x0F,
                display: accDisp & 0x0F
            };
        }
        
        function setEncoderData(setupIdx, group, enc, data) {
            const idx = group * 8 + enc;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            const accDisp = ((data.acc & 0x0F) << 4) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1C, 0x00, idx, chanType);
            setValue(setupIdx, 0x1C, 0x40, idx, data.cc);
            setValue(setupIdx, 0x1C, 0x80, idx, data.min);
            setValue(setupIdx, 0x1C, 0xC0, idx, data.max);
            setValue(setupIdx, 0x1D, 0x00, idx, accDisp);
        }
        
        function getPushData(setupIdx, group, btn) {
            const idx = group * 8 + btn;
            const chanType = getValue(setupIdx, 0x1D, 0x40, idx) || 0x10;
            const modeDisp = getValue(setupIdx, 0x1E, 0x40, idx) || 0x00;
            
            return {
                channel: (chanType & 0x0F) + 1,
                typeNibble: chanType & 0xF0,
                cc: getValue(setupIdx, 0x1D, 0x80, idx) || 0,
                lower: getValue(setupIdx, 0x1D, 0xC0, idx) || 0,
                upper: getValue(setupIdx, 0x1E, 0x00, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setPushData(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = (data.typeNibble & 0xF0) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1D, 0x40, idx, chanType);
            setValue(setupIdx, 0x1D, 0x80, idx, data.cc);
            setValue(setupIdx, 0x1D, 0xC0, idx, data.lower);
            setValue(setupIdx, 0x1E, 0x00, idx, data.upper);
            setValue(setupIdx, 0x1E, 0x40, idx, modeDisp);
        }
        
        function getGreenData(setupIdx, group, btn) {
            const idx = group * 8 + btn;
            const chanType = getValue(setupIdx, 0x1E, 0x80, idx) || 0x10;
            const modeDisp = getValue(setupIdx, 0x1F, 0x80, idx) || 0x01;
            
            return {
                channel: (chanType & 0x0F) + 1,
                typeNibble: chanType & 0xF0,
                cc: getValue(setupIdx, 0x1E, 0xC0, idx) || 64,
                lower: getValue(setupIdx, 0x1F, 0x00, idx) || 0,
                upper: getValue(setupIdx, 0x1F, 0x40, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setGreenData(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = (data.typeNibble & 0xF0) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1E, 0x80, idx, chanType);
            setValue(setupIdx, 0x1E, 0xC0, idx, data.cc);
            setValue(setupIdx, 0x1F, 0x00, idx, data.lower);
            setValue(setupIdx, 0x1F, 0x40, idx, data.upper);
            setValue(setupIdx, 0x1F, 0x80, idx, modeDisp);
        }
        
        function getFaderData(setupIdx, group, fader) {
            const idx = group * 8 + fader;
            const chanType = getValue(setupIdx, 0x1F, 0xC0, idx) || 0x00;
            const modeDisp = getValue(setupIdx, 0x20, 0xC0, idx) || 0x01;
            
            return {
                channel: (chanType & 0x0F) + 1,
                type: (chanType >> 4) & 0x0F,
                cc: getValue(setupIdx, 0x20, 0x00, idx) || 32,
                min: getValue(setupIdx, 0x20, 0x40, idx) || 0,
                max: getValue(setupIdx, 0x20, 0x80, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setFaderData(setupIdx, group, fader, data) {
            const idx = group * 8 + fader;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1F, 0xC0, idx, chanType);
            setValue(setupIdx, 0x20, 0x00, idx, data.cc);
            setValue(setupIdx, 0x20, 0x40, idx, data.min);
            setValue(setupIdx, 0x20, 0x80, idx, data.max);
            setValue(setupIdx, 0x20, 0xC0, idx, modeDisp);
        }
        
        function getFader9Data(setupIdx, group) {
            // Fader 9: 5 values per group in section 0x17 bank 0x00
            const baseIdx = group * 5;
            const modeVal = getValue(setupIdx, 0x17, 0x00, baseIdx + 4) || 1;
            
            return {
                channel: (getValue(setupIdx, 0x17, 0x00, baseIdx) || 0) + 1,
                cc: getValue(setupIdx, 0x17, 0x00, baseIdx + 1) || 112,
                min: getValue(setupIdx, 0x17, 0x00, baseIdx + 2) || 0,
                max: getValue(setupIdx, 0x17, 0x00, baseIdx + 3) || 127,
                mode: (modeVal & 0x10) ? 1 : 0
            };
        }
        
        function setFader9Data(setupIdx, group, data) {
            const baseIdx = group * 5;
            const modeVal = data.mode ? 0x11 : 0x01;
            
            setValue(setupIdx, 0x17, 0x00, baseIdx, (data.channel - 1) & 0x0F);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 1, data.cc);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 2, data.min);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 3, data.max);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 4, modeVal);
        }
        
        function getGroupName(setupIdx, group) {
            // 4 characters per group, 32 total values
            const baseIdx = group * 4;
            let name = '';
            for (let i = 0; i < 4; i++) {
                const val = getValue(setupIdx, 0x14, 0x80, baseIdx + i);
                if (val !== null) {
                    // Simple 7-seg decode (approximate)
                    name += decode7Seg(val);
                } else {
                    name += '?';
                }
            }
            return name;
        }
        
        function decode7Seg(val) {
            // Approximate 7-segment character mapping
            const map = {
                0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9',
                10: 'A', 11: 'b', 12: 'C', 13: 'd', 14: 'E', 15: 'F', 16: 'G', 17: 'H',
                18: 'I', 19: 'J', 20: 'L', 21: 'n', 22: 'O', 23: 'P', 24: 'r', 25: 'S',
                26: 't', 27: 'U', 28: 'Y', 29: '-', 30: '_', 31: ' '
            };
            return map[val] || String.fromCharCode(val > 31 && val < 127 ? val : 63);
        }
        
        // ============================================================
        // UI Rendering
        // ============================================================
        
        function initUI() {
            // Generate group tabs
            for (let i = 0; i < NUM_GROUPS; i++) {
                const encTab = document.createElement('button');
                encTab.className = 'group-tab' + (i === 0 ? ' active' : '');
                encTab.textContent = i + 1;
                encTab.onclick = () => selectEncoderGroup(i);
                document.getElementById('encoderGroupTabs').appendChild(encTab);
                
                const fadTab = document.createElement('button');
                fadTab.className = 'group-tab' + (i === 0 ? ' active' : '');
                fadTab.textContent = i + 1;
                fadTab.onclick = () => selectFaderGroup(i);
                document.getElementById('faderGroupTabs').appendChild(fadTab);
            }
            
            // Populate setup dropdown
            const setupSelect = document.getElementById('setupSelect');
            for (let i = 0; i < NUM_SETUPS; i++) {
                const opt = document.createElement('option');
                opt.value = i;
                if (i < 16) {
                    opt.textContent = `Setup ${i + 1}`;
                } else if (i === 16) {
                    opt.textContent = 'Setup 17 (Ableton 1-8)';
                } else {
                    opt.textContent = 'Setup 18 (Ableton 9-16)';
                }
                setupSelect.appendChild(opt);
            }
        }
        
        function renderFocusedView() {
            const main = document.getElementById('mainContent');
            main.innerHTML = '';
            
            // Get group names for display
            const encoderGroupName = getGroupName(currentSetup, encoderGroup);
            const faderGroupName = getGroupName(currentSetup, faderGroup);
            
            // Faders section (uses fader group)
            const faderSection = createSection('Faders', 'faders', faderGroupName);
            const faderGrid = document.createElement('div');
            faderGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                faderGrid.appendChild(createFaderCard(i));
            }
            faderSection.appendChild(faderGrid);
            main.appendChild(faderSection);
            
            // Green Buttons section (uses fader group)
            const greenSection = createSection('Green Buttons', 'green', faderGroupName);
            const greenGrid = document.createElement('div');
            greenGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                greenGrid.appendChild(createGreenCard(i));
            }
            greenSection.appendChild(greenGrid);
            main.appendChild(greenSection);
            
            // Encoders section (uses encoder group)
            const encSection = createSection('Encoders', 'encoders', encoderGroupName);
            const encGrid = document.createElement('div');
            encGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                encGrid.appendChild(createEncoderCard(i));
            }
            encSection.appendChild(encGrid);
            main.appendChild(encSection);
            
            // Push Buttons section (uses encoder group - they're on the encoders)
            const pushSection = createSection('Push Buttons', 'push', encoderGroupName);
            const pushGrid = document.createElement('div');
            pushGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                pushGrid.appendChild(createPushCard(i));
            }
            pushSection.appendChild(pushGrid);
            main.appendChild(pushSection);
            
            // Fader 9 section (uses fader group)
            const fader9Section = createSection('Fader 9', 'fader9', faderGroupName);
            fader9Section.appendChild(createFader9Card());
            main.appendChild(fader9Section);
        }
        
        function createSection(title, className, badge) {
            const section = document.createElement('section');
            section.className = 'control-section';
            
            const header = document.createElement('div');
            header.className = 'section-header';
            
            const h2 = document.createElement('h2');
            h2.className = 'section-title ' + className;
            h2.textContent = title;
            header.appendChild(h2);
            
            const span = document.createElement('span');
            span.className = 'section-badge';
            span.textContent = badge;
            header.appendChild(span);
            
            section.appendChild(header);
            return section;
        }
        
        function createEncoderCard(idx) {
            const data = getEncoderData(currentSetup, encoderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card encoder';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Encoder ${idx + 1}</span>
                    <span class="control-index">E${encoderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label">Chan</span>
                    <div class="param-input">
                        <select data-param="channel" onchange="updateEncoder(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">CC</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}" 
                            onchange="updateEncoder(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Type</span>
                    <div class="param-input">
                        <select onchange="updateEncoder(${idx}, 'type', this.value)">
                            ${ENCODER_TYPES.map((t, i) => 
                                `<option value="${i}" ${data.type === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Acc</span>
                    <div class="param-input">
                        <select onchange="updateEncoder(${idx}, 'acc', this.value)">
                            ${ACC_MODES.map((t, i) => 
                                `<option value="${i}" ${data.acc === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Disp</span>
                    <div class="param-input">
                        <select onchange="updateEncoder(${idx}, 'display', this.value)">
                            ${DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Min</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.min}" 
                            onchange="updateEncoder(${idx}, 'min', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Max</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.max}" 
                            onchange="updateEncoder(${idx}, 'max', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createPushCard(idx) {
            const data = getPushData(currentSetup, encoderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card push';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Push ${idx + 1}</span>
                    <span class="control-index">P${encoderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label">Chan</span>
                    <div class="param-input">
                        <select onchange="updatePush(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Note</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}" 
                            onchange="updatePush(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Type</span>
                    <div class="param-input">
                        <select onchange="updatePush(${idx}, 'typeNibble', this.value)">
                            ${BUTTON_TYPE_VALUES.map(v => 
                                `<option value="${v}" ${data.typeNibble === v ? 'selected' : ''}>${BUTTON_TYPES[v]}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Mode</span>
                    <div class="param-input">
                        <select onchange="updatePush(${idx}, 'mode', this.value)">
                            ${BUTTON_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Lo</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.lower}" 
                            onchange="updatePush(${idx}, 'lower', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Hi</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.upper}" 
                            onchange="updatePush(${idx}, 'upper', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createGreenCard(idx) {
            const data = getGreenData(currentSetup, faderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card green';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Button ${idx + 1}</span>
                    <span class="control-index">B${faderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label">Chan</span>
                    <div class="param-input">
                        <select onchange="updateGreen(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Note</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}" 
                            onchange="updateGreen(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Type</span>
                    <div class="param-input">
                        <select onchange="updateGreen(${idx}, 'typeNibble', this.value)">
                            ${BUTTON_TYPE_VALUES.map(v => 
                                `<option value="${v}" ${data.typeNibble === v ? 'selected' : ''}>${BUTTON_TYPES[v]}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Mode</span>
                    <div class="param-input">
                        <select onchange="updateGreen(${idx}, 'mode', this.value)">
                            ${BUTTON_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">LED</span>
                    <div class="param-input">
                        <select onchange="updateGreen(${idx}, 'display', this.value)">
                            ${GREEN_DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Lo</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.lower}" 
                            onchange="updateGreen(${idx}, 'lower', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Hi</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.upper}" 
                            onchange="updateGreen(${idx}, 'upper', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createFaderCard(idx) {
            const data = getFaderData(currentSetup, faderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card fader';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Fader ${idx + 1}</span>
                    <span class="control-index">F${faderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label">Chan</span>
                    <div class="param-input">
                        <select onchange="updateFader(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">CC</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}" 
                            onchange="updateFader(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Type</span>
                    <div class="param-input">
                        <select onchange="updateFader(${idx}, 'type', this.value)">
                            ${FADER_TYPES.map((t, i) => 
                                `<option value="${i}" ${data.type === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Mode</span>
                    <div class="param-input">
                        <select onchange="updateFader(${idx}, 'mode', this.value)">
                            ${FADER_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Disp</span>
                    <div class="param-input">
                        <select onchange="updateFader(${idx}, 'display', this.value)">
                            ${DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Min</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.min}" 
                            onchange="updateFader(${idx}, 'min', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label">Max</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.max}" 
                            onchange="updateFader(${idx}, 'max', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createFader9Card() {
            const data = getFader9Data(currentSetup, faderGroup);
            const card = document.createElement('div');
            card.className = 'fader9-card';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Fader 9</span>
                    <span class="control-index">F${faderGroup + 1}.9</span>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.75rem;">
                    <div class="param-row">
                        <span class="param-label">Chan</span>
                        <div class="param-input">
                            <select onchange="updateFader9('channel', this.value)">
                                ${Array.from({length: 16}, (_, i) => 
                                    `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label">CC</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.cc}" 
                                onchange="updateFader9('cc', this.value)">
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label">Mode</span>
                        <div class="param-input">
                            <select onchange="updateFader9('mode', this.value)">
                                ${FADER_MODES.map((t, i) => 
                                    `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label">Min</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.min}" 
                                onchange="updateFader9('min', this.value)">
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label">Max</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.max}" 
                                onchange="updateFader9('max', this.value)">
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function renderOverview() {
            const main = document.getElementById('mainContent');
            main.innerHTML = '';
            
            const container = document.createElement('div');
            container.className = 'overview-container';
            
            // Tab bar
            const tabs = document.createElement('div');
            tabs.className = 'overview-tabs';
            tabs.innerHTML = `
                <button class="overview-tab ${overviewTab === 'encoders' ? 'active' : ''}" onclick="setOverviewTab('encoders')">Encoders</button>
                <button class="overview-tab ${overviewTab === 'push' ? 'active' : ''}" onclick="setOverviewTab('push')">Push Buttons</button>
                <button class="overview-tab ${overviewTab === 'green' ? 'active' : ''}" onclick="setOverviewTab('green')">Green Buttons</button>
                <button class="overview-tab ${overviewTab === 'faders' ? 'active' : ''}" onclick="setOverviewTab('faders')">Faders</button>
            `;
            container.appendChild(tabs);
            
            // Conflict filter chips
            const filters = document.createElement('div');
            filters.className = 'conflict-filters';
            filters.innerHTML = `
                <span class="conflict-filters-label">Conflicts:</span>
                <div class="filter-chip ${showConcurrentConflicts ? 'active' : ''}" onclick="toggleConcurrentFilter()">
                    <span class="checkmark">${showConcurrentConflicts ? 'âœ“' : ''}</span>
                    Concurrent
                    <span class="count" id="concurrentCount">${conflicts.concurrent.size}</span>
                </div>
                <div class="filter-chip ${showMutuallyExclusiveConflicts ? 'active dim' : ''}" onclick="toggleMEFilter()">
                    <span class="checkmark">${showMutuallyExclusiveConflicts ? 'âœ“' : ''}</span>
                    Mutually-Exclusive
                    <span class="count" id="meCount">${conflicts.mutuallyExclusive.size}</span>
                </div>
            `;
            container.appendChild(filters);
            
            // Grid based on active tab
            const grid = document.createElement('div');
            grid.className = 'overview-grid';
            
            switch (overviewTab) {
                case 'encoders':
                    grid.appendChild(createEncoderOverviewTable());
                    break;
                case 'push':
                    grid.appendChild(createButtonOverviewTable('push', getPushData, 'P'));
                    break;
                case 'green':
                    grid.appendChild(createButtonOverviewTable('green', getGreenData, 'B'));
                    break;
                case 'faders':
                    grid.appendChild(createFaderOverviewTable());
                    break;
            }
            
            container.appendChild(grid);
            
            // Conflict panel (show only if there are conflicts to display)
            const visibleConflicts = [];
            if (showConcurrentConflicts) {
                for (const [key, entry] of conflicts.concurrent) {
                    visibleConflicts.push({ key, entry, type: 'concurrent' });
                }
            }
            if (showMutuallyExclusiveConflicts) {
                for (const [key, entry] of conflicts.mutuallyExclusive) {
                    visibleConflicts.push({ key, entry, type: 'me' });
                }
            }
            
            if (visibleConflicts.length > 0) {
                const panel = document.createElement('div');
                panel.className = 'conflict-panel';
                panel.innerHTML = `
                    <div class="conflict-panel-header">
                        <span>âš  ${visibleConflicts.length} Conflict${visibleConflicts.length !== 1 ? 's' : ''}</span>
                    </div>
                `;
                
                for (const { key, entry, type } of visibleConflicts.slice(0, 20)) {
                    const item = document.createElement('div');
                    item.className = `conflict-item ${type === 'me' ? 'dim' : ''}`;
                    const refsStr = entry.refs.map(formatControlRef).join(', ');
                    item.innerHTML = `
                        <span class="warning-icon">âš </span>
                        <span class="conflict-key">${formatConflictKey(key)}:</span>
                        <span class="conflict-refs">${refsStr}</span>
                    `;
                    panel.appendChild(item);
                }
                
                if (visibleConflicts.length > 20) {
                    const more = document.createElement('div');
                    more.className = 'conflict-item';
                    more.innerHTML = `<span class="conflict-refs">...and ${visibleConflicts.length - 20} more</span>`;
                    panel.appendChild(more);
                }
                
                container.appendChild(panel);
            }
            
            main.appendChild(container);
        }
        
        // Overview state
        let overviewTab = 'encoders';
        
        function setOverviewTab(tab) {
            overviewTab = tab;
            renderOverview();
        }
        
        // MIDI Channel Helpers
        function chDisp(ch0) { return (ch0 | 0) + 1; }
        
        function formatEncoderCell(data) {
            const typeMap = {
                0: 'r1', 1: 'r2', 2: 'CC', 3: 'PC', 4: 'Hi', 5: 'PB', 6: 'AT'
            };
            const type = typeMap[data.type] || '??';
            const ch = chDisp(data.channel - 1);  // data.channel is already 1-based
            
            // Program Change: show range
            if (data.type === 3) {
                const lo = Math.min(data.min, data.max);
                const hi = Math.max(data.min, data.max);
                return `${ch}:PC ${lo}-${hi}`;
            }
            
            // Pitch bend and aftertouch have no CC number
            if (data.type === 5 || data.type === 6) {
                return `${ch}:${type}`;
            }
            
            return `${ch}:${type} ${data.cc}`;
        }
        
        function formatFaderCell(data) {
            const typeMap = { 0: 'CC', 1: 'PC', 2: 'PB', 3: 'AT' };
            const type = typeMap[data.type] || '??';
            const ch = chDisp(data.channel - 1);
            
            // Program Change: show range
            if (data.type === 1) {
                const lo = Math.min(data.min, data.max);
                const hi = Math.max(data.min, data.max);
                return `${ch}:PC ${lo}-${hi}`;
            }
            
            // Pitch bend and aftertouch have no CC number
            if (data.type === 2 || data.type === 3) {
                return `${ch}:${type}`;
            }
            
            return `${ch}:${type} ${data.cc}`;
        }
        
        function formatButtonCell(data) {
            if (data.typeNibble === 0x00) return '--';
            
            const typeMap = { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' };
            const type = typeMap[data.typeNibble] || '??';
            const ch = chDisp(data.channel - 1);
            const mode = data.mode ? 'T' : 'M';
            
            if (data.typeNibble === 0x40) {
                return `${ch}:${type} [${mode}]`;
            }
            
            return `${ch}:${type} ${data.cc} [${mode}]`;
        }
        
        function createEncoderOverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerHtml += `<td>${name}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Data rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">Enc ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getEncoderData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = 'encoder';
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType('encoder', g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === 'encoder' && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatEncoderCell(data)}</div>`;
                    cell.onclick = () => { setSelection('encoder', g, i); };
                    cell.ondblclick = () => jumpToFocusedView('encoder', g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, 'encoder', g, i);
                    cell.title = createEncoderTooltip(data, g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        function createButtonOverviewTable(type, getData, prefix) {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerHtml += `<td>${name}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Data rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">${prefix} ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = type;
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType(type, g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === type && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatButtonCell(data)}</div>`;
                    cell.onclick = () => { setSelection(type, g, i); };
                    cell.ondblclick = () => jumpToFocusedView(type, g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, type, g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        function createFaderOverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerHtml += `<td>${name}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Fader 1-8 rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">Fad ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getFaderData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = 'fader';
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType('fader', g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === 'fader' && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatFaderCell(data)}</div>`;
                    cell.onclick = () => { setSelection('fader', g, i); };
                    cell.ondblclick = () => jumpToFocusedView('fader', g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, 'fader', g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            // Fader 9 row
            const f9row = document.createElement('tr');
            f9row.innerHTML = `<th class="row-header">Fad 9</th>`;
            
            for (let g = 0; g < 8; g++) {
                const data = getFader9Data(currentSetup, g);
                const cell = document.createElement('td');
                
                // Add data attributes for keyboard navigation
                cell.dataset.type = 'fader9';
                cell.dataset.group = g;
                cell.dataset.index = 0;
                
                // Check for conflicts
                const conflictType = getControlConflictType('fader9', g, 0);
                if (conflictType === 'concurrent') {
                    cell.className = 'conflict';
                } else if (conflictType === 'mutuallyExclusive') {
                    cell.className = 'conflict-dim';
                }
                
                // Check if this cell is selected
                if (selection.mode !== 'none' && 
                    selection.controlType === 'fader9' && 
                    selection.group === g) {
                    cell.classList.add('selected');
                }
                
                // Fader 9 only has CC type
                const ch = chDisp(data.channel - 1);
                const warningIcon = conflictType ? '<span class="conflict-icon">âš </span>' : '';
                cell.innerHTML = `<div class="overview-cell">${warningIcon}${ch}:CC ${data.cc}</div>`;
                cell.onclick = () => { setSelection('fader9', g, 0); };
                cell.ondblclick = () => jumpToFocusedView('fader9', g, 0);
                cell.oncontextmenu = (e) => showContextMenu(e, 'fader9', g, 0);
                f9row.appendChild(cell);
            }
            
            table.appendChild(f9row);
            
            return table;
        }
        
        function createEncoderTooltip(data, group, index) {
            const types = ['CCr1', 'CCr2', 'CCAb', 'PrGC', 'CCAh', 'Pbnd', 'AFtt'];
            const accs = ['Acc0', 'Acc1', 'Acc2', 'Acc3'];
            const disps = ['OFF', 'Std', 'bPoL'];
            
            return `Encoder ${index + 1}, Group ${group + 1}
Channel: ${data.channel}
Type: ${types[data.type] || '?'}
CC#: ${data.cc}
Min: ${data.min}, Max: ${data.max}
Acc: ${accs[data.acc] || '?'}, Display: ${disps[data.display] || '?'}`;
        }
        
        function jumpToFocusedView(type, group, index) {
            // Switch to the appropriate group
            if (type === 'encoder' || type === 'push') {
                selectEncoderGroup(group);
            } else {
                selectFaderGroup(group);
            }
            
            // Switch to focused view
            setView('focused');
            
            // Scroll to the control (after view renders)
            setTimeout(() => {
                const cards = document.querySelectorAll('.control-card');
                // Find the right card based on type and index
                // This is approximate - we'd need better selectors in production
            }, 100);
        }
        
        // ============================================================
        // Update Functions (with undo support)
        // ============================================================
        
        function updateEncoder(idx, param, value) {
            const data = getEncoderData(currentSetup, encoderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return; // No change
            
            data[param] = after;
            setEncoderData(currentSetup, encoderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'encoder',
                setupIdx: currentSetup,
                group: encoderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updatePush(idx, param, value) {
            const data = getPushData(currentSetup, encoderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setPushData(currentSetup, encoderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'push',
                setupIdx: currentSetup,
                group: encoderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateGreen(idx, param, value) {
            const data = getGreenData(currentSetup, faderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setGreenData(currentSetup, faderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'green',
                setupIdx: currentSetup,
                group: faderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateFader(idx, param, value) {
            const data = getFaderData(currentSetup, faderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setFaderData(currentSetup, faderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'fader',
                setupIdx: currentSetup,
                group: faderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateFader9(param, value) {
            const data = getFader9Data(currentSetup, faderGroup);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setFader9Data(currentSetup, faderGroup, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'fader9',
                setupIdx: currentSetup,
                group: faderGroup,
                index: 0,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        // ============================================================
        // Navigation
        // ============================================================
        
        function selectSetup(idx) {
            currentSetup = parseInt(idx);
            updateGroupNames();
            // Rebuild conflict map for new setup
            rebuildConflictMap();
            renderCurrentView();
        }
        
        function toggleLinkGroups(checked) {
            linkGroups = checked;
            // If linking and groups are different, sync fader to encoder
            if (linkGroups && encoderGroup !== faderGroup) {
                faderGroup = encoderGroup;
                updateGroupTabs('faderGroupTabs', faderGroup);
                document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, faderGroup);
                renderCurrentView();
            }
        }
        
        function selectEncoderGroup(idx, fromLink = false) {
            encoderGroup = idx;
            updateGroupTabs('encoderGroupTabs', idx);
            document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, idx);
            
            // If linked and not already called from fader, update fader too
            if (linkGroups && !fromLink) {
                faderGroup = idx;
                updateGroupTabs('faderGroupTabs', idx);
                document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, idx);
            }
            
            renderCurrentView();
        }
        
        function selectFaderGroup(idx, fromLink = false) {
            faderGroup = idx;
            updateGroupTabs('faderGroupTabs', idx);
            document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, idx);
            
            // If linked and not already called from encoder, update encoder too
            if (linkGroups && !fromLink) {
                encoderGroup = idx;
                updateGroupTabs('encoderGroupTabs', idx);
                document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, idx);
            }
            
            renderCurrentView();
        }
        
        function updateGroupTabs(containerId, activeIdx) {
            const tabs = document.getElementById(containerId).querySelectorAll('.group-tab');
            tabs.forEach((tab, i) => {
                tab.classList.toggle('active', i === activeIdx);
            });
        }
        
        function updateGroupNames() {
            document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, encoderGroup);
            document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, faderGroup);
        }
        
        function setView(view) {
            currentView = view;
            document.getElementById('focusedViewBtn').classList.toggle('active', view === 'focused');
            document.getElementById('overviewBtn').classList.toggle('active', view === 'overview');
            
            // Clear selection when leaving overview
            if (view === 'focused') {
                clearSelection();
            }
            
            renderCurrentView();
        }
        
        function renderCurrentView() {
            if (!rawBuffer) return;
            if (currentView === 'focused') {
                renderFocusedView();
            } else {
                renderOverview();
            }
        }
        
        // ============================================================
        // File Operations
        // ============================================================
        
        document.getElementById('sysexInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const buffer = await file.arrayBuffer();
                rawBuffer = new Uint8Array(buffer);
                
                if (rawBuffer.length !== EXPECTED_SIZE) {
                    alert(`Invalid file size: ${rawBuffer.length} bytes. Expected ${EXPECTED_SIZE} bytes.`);
                    rawBuffer = null;
                    return;
                }
                
                // Validate SysEx framing
                if (rawBuffer[0] !== 0xF0 || rawBuffer[rawBuffer.length - 1] !== 0xF7) {
                    alert('Invalid SysEx file: Missing F0/F7 framing bytes.');
                    rawBuffer = null;
                    return;
                }
                
                sectionIndex = buildIndex(rawBuffer);
                
                // Clear previous session - new import is clean slate
                clearSession();
                
                // Clear undo/redo stacks
                undoStack.length = 0;
                redoStack.length = 0;
                updateUndoRedoUI();
                
                // Enable UI
                document.getElementById('setupSelect').disabled = false;
                document.getElementById('setupSelect').value = '0';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('exportJsonBtn').disabled = false;
                
                currentSetup = 0;
                encoderGroup = 0;
                faderGroup = 0;
                isModified = false;
                dirtyBanks.clear();
                
                updateGroupTabs('encoderGroupTabs', 0);
                updateGroupTabs('faderGroupTabs', 0);
                updateGroupNames();
                updateStatus('loaded', `Loaded: ${file.name}`);
                document.getElementById('fileInfo').textContent = `${file.name} (${rawBuffer.length.toLocaleString()} bytes)`;
                
                // Build initial conflict map
                rebuildConflictMap();
                
                renderFocusedView();
            } catch (err) {
                alert('Error loading file: ' + err.message);
                console.error(err);
            }
            
            e.target.value = '';
        });
        
        function exportSysEx() {
            if (!rawBuffer) return;
            
            // Recalculate all dirty checksums
            for (const key of dirtyBanks) {
                const [setupIdx, secId, bank] = key.split('-').map(Number);
                const sec = sectionIndex[setupIdx][secId];
                if (sec && sec[bank]) {
                    recalcBankChecksum(rawBuffer, sec[bank].dataOffset);
                }
            }
            dirtyBanks.clear();
            
            const blob = new Blob([rawBuffer], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'uc4_edited.syx';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Clear session - user saved their work
            clearSession();
            isModified = false;
            updateStatus('loaded', 'Exported successfully');
            showToast('SysEx exported', 'success');
        }
        
        function exportJSON() {
            if (!rawBuffer) return;
            
            const data = {
                format: 'uc4-editor',
                version: '1.0',
                exported: new Date().toISOString(),
                setups: []
            };
            
            for (let s = 0; s < NUM_SETUPS; s++) {
                const setup = {
                    index: s,
                    groups: []
                };
                
                for (let g = 0; g < NUM_GROUPS; g++) {
                    const group = {
                        index: g,
                        name: getGroupName(s, g),
                        encoders: [],
                        pushButtons: [],
                        greenButtons: [],
                        faders: [],
                        fader9: getFader9Data(s, g)
                    };
                    
                    for (let i = 0; i < 8; i++) {
                        group.encoders.push(getEncoderData(s, g, i));
                        group.pushButtons.push(getPushData(s, g, i));
                        group.greenButtons.push(getGreenData(s, g, i));
                        group.faders.push(getFaderData(s, g, i));
                    }
                    
                    setup.groups.push(group);
                }
                
                data.setups.push(setup);
            }
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'uc4_config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        document.getElementById('jsonInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!rawBuffer) {
                alert('Please import a SysEx file first to use as a base.');
                e.target.value = '';
                return;
            }
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (data.format !== 'uc4-editor') {
                    alert('Invalid JSON format. Expected UC4 Editor export.');
                    return;
                }
                
                // Apply JSON data to buffer
                for (const setup of data.setups) {
                    for (const group of setup.groups) {
                        for (let i = 0; i < 8; i++) {
                            if (group.encoders[i]) setEncoderData(setup.index, group.index, i, group.encoders[i]);
                            if (group.pushButtons[i]) setPushData(setup.index, group.index, i, group.pushButtons[i]);
                            if (group.greenButtons[i]) setGreenData(setup.index, group.index, i, group.greenButtons[i]);
                            if (group.faders[i]) setFaderData(setup.index, group.index, i, group.faders[i]);
                        }
                        if (group.fader9) setFader9Data(setup.index, group.index, group.fader9);
                    }
                }
                
                updateStatus('modified', 'JSON imported - changes pending');
                renderCurrentView();
            } catch (err) {
                alert('Error loading JSON: ' + err.message);
                console.error(err);
            }
            
            e.target.value = '';
        });
        
        // ============================================================
        // Status
        // ============================================================
        
        function markModified() {
            isModified = true;
            updateStatus('modified', 'Modified - remember to export');
            scheduleAutoSave();
        }
        
        function updateStatus(state, text) {
            const dot = document.getElementById('statusDot');
            const txt = document.getElementById('statusText');
            
            dot.className = 'status-dot ' + state;
            txt.textContent = text;
        }
        
        // ============================================================
        // Toast Notifications
        // ============================================================
        
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // ============================================================
        // Undo/Redo System
        // ============================================================
        
        function recordUndo(action) {
            if (!action.description) {
                action.description = generateDescription(action);
            }
            action.timestamp = Date.now();
            
            undoStack.push(action);
            
            // Clear redo stack (new action invalidates redo history)
            redoStack.length = 0;
            
            // Trim if over limit
            while (undoStack.length > MAX_UNDO) {
                undoStack.shift();
            }
            
            updateUndoRedoUI();
        }
        
        function recordUndoCoalesced(action) {
            const last = undoStack[undoStack.length - 1];
            
            // Check if we should coalesce with previous action
            if (last && 
                last.type === 'value' &&
                action.type === 'value' &&
                last.controlType === action.controlType &&
                last.setupIdx === action.setupIdx &&
                last.group === action.group &&
                last.index === action.index &&
                last.param === action.param &&
                (Date.now() - last.timestamp) < COALESCE_WINDOW) {
                
                // Update the existing action's 'after' value
                last.after = action.after;
                last.timestamp = Date.now();
                // Keep original 'before' value
                return;
            }
            
            // Otherwise record as new action
            recordUndo(action);
        }
        
        function generateDescription(action) {
            const formatControlName = (type, group, index) => {
                const g = group + 1;
                const i = index + 1;
                switch (type) {
                    case 'encoder': return `Encoder G${g}.${i}`;
                    case 'push': return `Push G${g}.${i}`;
                    case 'green': return `Green G${g}.${i}`;
                    case 'fader': return `Fader G${g}.${i}`;
                    case 'fader9': return `Fader9 G${g}`;
                    default: return `${type} G${g}.${i}`;
                }
            };
            
            switch (action.type) {
                case 'value':
                    return `Change ${formatControlName(action.controlType, action.group, action.index)} ${action.param}`;
                case 'control':
                    return `Update ${formatControlName(action.controlType, action.group, action.index)}`;
                case 'batch':
                    return action.description || 'Batch operation';
                default:
                    return 'Unknown action';
            }
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            const action = undoStack.pop();
            
            // Apply reverse
            applyAction(action, true);
            
            redoStack.push(action);
            updateUndoRedoUI();
            renderCurrentView();
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            const action = redoStack.pop();
            
            // Apply forward
            applyAction(action, false);
            
            undoStack.push(action);
            updateUndoRedoUI();
            renderCurrentView();
        }
        
        function applyAction(action, reverse) {
            switch (action.type) {
                case 'value': {
                    const value = reverse ? action.before : action.after;
                    applyValueChange(action, value);
                    break;
                }
                    
                case 'control': {
                    const data = reverse ? action.before : action.after;
                    setControlDataSilent(action.controlType, action.setupIdx, action.group, action.index, data);
                    break;
                }
                    
                case 'batch': {
                    for (const subAction of action.actions) {
                        const subData = reverse ? subAction.before : subAction.after;
                        setControlDataSilent(subAction.controlType, subAction.setupIdx, subAction.group, subAction.index, subData);
                    }
                    break;
                }
            }
            
            // After any change
            markModified();
            
            // Only rebuild conflicts if action affects routing params
            if (actionAffectsConflicts(action)) {
                scheduleConflictRebuild();
            }
        }
        
        function applyValueChange(action, value) {
            const getData = getControlDataByType(action.controlType);
            const setData = setControlDataByType(action.controlType);
            
            if (!getData || !setData) return;
            
            const data = getData(action.setupIdx, action.group, action.index);
            data[action.param] = value;
            setData(action.setupIdx, action.group, action.index, data);
        }
        
        function getControlDataByType(type) {
            switch (type) {
                case 'encoder': return getEncoderData;
                case 'push': return getPushData;
                case 'green': return getGreenData;
                case 'fader': return getFaderData;
                case 'fader9': return (s, g, i) => getFader9Data(s, g);
                default: return null;
            }
        }
        
        function setControlDataByType(type) {
            switch (type) {
                case 'encoder': return setEncoderData;
                case 'push': return setPushData;
                case 'green': return setGreenData;
                case 'fader': return setFaderData;
                case 'fader9': return (s, g, i, d) => setFader9Data(s, g, d);
                default: return null;
            }
        }
        
        // Silent setters that don't trigger markModified (for undo/redo)
        function setControlDataSilent(type, setupIdx, group, index, data) {
            const setData = setControlDataByType(type);
            if (setData) {
                // Temporarily disable markModified in setValue
                const originalMarkModified = markModified;
                // setValue calls markModified, so we need to track dirty banks without it
                setData(setupIdx, group, index, data);
            }
        }
        
        function actionAffectsConflicts(action) {
            if (action.type === 'value') {
                return CONFLICT_PARAMS.has(action.param);
            }
            // control and batch actions are conservative - always rebuild
            return true;
        }
        
        function updateUndoRedoUI() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            
            // Update tooltips
            if (undoStack.length > 0) {
                undoBtn.title = `Undo: ${undoStack[undoStack.length - 1].description}`;
            } else {
                undoBtn.title = 'Undo (Ctrl+Z)';
            }
            
            if (redoStack.length > 0) {
                redoBtn.title = `Redo: ${redoStack[redoStack.length - 1].description}`;
            } else {
                redoBtn.title = 'Redo (Ctrl+Y)';
            }
        }
        
        // ============================================================
        // Session Persistence
        // ============================================================
        
        function scheduleAutoSave() {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
                saveSession();
            }, AUTO_SAVE_DELAY);
        }
        
        function saveSession() {
            if (!rawBuffer) return;
            
            try {
                const sessionData = {
                    version: SESSION_VERSION,
                    timestamp: Date.now(),
                    buffer: Array.from(rawBuffer),
                    uiState: {
                        currentSetup,
                        encoderGroup,
                        faderGroup,
                        currentView
                    },
                    dirtyBanks: Array.from(dirtyBanks)
                };
                
                localStorage.setItem(STORAGE_KEY, JSON.stringify(sessionData));
            } catch (e) {
                console.warn('Session save failed:', e);
                if (e.name === 'QuotaExceededError') {
                    showToast('Autosave failed (storage full)', 'error');
                }
            }
        }
        
        function loadSession() {
            try {
                const json = localStorage.getItem(STORAGE_KEY);
                if (!json) return null;
                
                const session = JSON.parse(json);
                
                // Version check
                if (session.version !== SESSION_VERSION) {
                    console.warn('Session version mismatch, discarding');
                    clearSession();
                    return null;
                }
                
                // Buffer integrity checks
                if (!session.buffer || session.buffer.length !== EXPECTED_SIZE) {
                    console.warn('Invalid buffer length, discarding');
                    clearSession();
                    return null;
                }
                
                // SysEx framing check
                if (session.buffer[0] === 0xF0) {
                    if (session.buffer[session.buffer.length - 1] !== 0xF7) {
                        console.warn('Invalid SysEx framing, discarding');
                        clearSession();
                        return null;
                    }
                }
                
                return session;
            } catch (e) {
                console.error('Failed to parse session:', e);
                clearSession();
                return null;
            }
        }
        
        function clearSession() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (e) {
                console.warn('Failed to clear session:', e);
            }
        }
        
        function restoreSession(session) {
            rawBuffer = new Uint8Array(session.buffer);
            sectionIndex = buildIndex(rawBuffer);
            
            // Restore UI state
            currentSetup = session.uiState.currentSetup || 0;
            encoderGroup = session.uiState.encoderGroup || 0;
            faderGroup = session.uiState.faderGroup || 0;
            currentView = session.uiState.currentView || 'focused';
            
            // Restore dirty banks
            dirtyBanks = new Set(session.dirtyBanks || []);
            isModified = dirtyBanks.size > 0;
            
            // Enable UI
            document.getElementById('setupSelect').disabled = false;
            document.getElementById('setupSelect').value = currentSetup.toString();
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('exportJsonBtn').disabled = false;
            
            updateGroupTabs('encoderGroupTabs', encoderGroup);
            updateGroupTabs('faderGroupTabs', faderGroup);
            updateGroupNames();
            
            // Build conflict map for restored setup
            rebuildConflictMap();
            
            setView(currentView);
            
            if (isModified) {
                updateStatus('modified', 'Session restored - changes pending');
            } else {
                updateStatus('loaded', 'Session restored');
            }
            
            document.getElementById('fileInfo').textContent = `Restored session (${rawBuffer.length.toLocaleString()} bytes)`;
            
            showToast('Session restored', 'success');
        }
        
        function formatTimeSince(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            const days = Math.floor(hours / 24);
            return `${days} day${days > 1 ? 's' : ''} ago`;
        }
        
        function showRestoreDialog(timeSince, session) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                
                const dirtyCount = session.dirtyBanks ? session.dirtyBanks.length : 0;
                const setupInfo = session.uiState ? `Setup ${(session.uiState.currentSetup || 0) + 1}` : 'Unknown setup';
                
                overlay.innerHTML = `
                    <div class="modal-dialog">
                        <h3>Restore Previous Session?</h3>
                        <p>Found unsaved changes from ${timeSince}.</p>
                        <div class="info">
                            ${setupInfo}<br>
                            ${dirtyCount} modified bank${dirtyCount !== 1 ? 's' : ''}
                        </div>
                        <label>
                            <input type="checkbox" id="skipRestoreCheck">
                            Don't ask again this session
                        </label>
                        <div class="modal-actions">
                            <button class="btn" id="discardBtn">Discard & Load Factory</button>
                            <button class="btn btn-primary" id="restoreBtn">Restore Session</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                document.getElementById('restoreBtn').onclick = () => {
                    overlay.remove();
                    resolve('restore');
                };
                
                document.getElementById('discardBtn').onclick = () => {
                    const skipCheck = document.getElementById('skipRestoreCheck').checked;
                    overlay.remove();
                    if (skipCheck) {
                        resolve('discard-permanently');
                    } else {
                        resolve('discard');
                    }
                };
            });
        }
        
        // ============================================================
        // Conflict Detection
        // ============================================================
        
        function scheduleConflictRebuild() {
            clearTimeout(conflictRebuildTimer);
            conflictRebuildTimer = setTimeout(() => {
                rebuildConflictMap();
                updateConflictUI();
            }, CONFLICT_REBUILD_DELAY);
        }
        
        function rebuildConflictMap() {
            if (!rawBuffer) return;
            
            const result = buildConflictMap(currentSetup);
            conflicts = result;
            
            // Build reverse lookup for quick cell highlighting
            conflictsByControl.clear();
            
            for (const [key, entry] of conflicts.concurrent) {
                for (const ref of entry.refs) {
                    const controlKey = `${ref.type}-${ref.group}-${ref.index}`;
                    if (!conflictsByControl.has(controlKey)) {
                        conflictsByControl.set(controlKey, { concurrent: [], mutuallyExclusive: [] });
                    }
                    conflictsByControl.get(controlKey).concurrent.push(key);
                }
            }
            
            for (const [key, entry] of conflicts.mutuallyExclusive) {
                for (const ref of entry.refs) {
                    const controlKey = `${ref.type}-${ref.group}-${ref.index}`;
                    if (!conflictsByControl.has(controlKey)) {
                        conflictsByControl.set(controlKey, { concurrent: [], mutuallyExclusive: [] });
                    }
                    conflictsByControl.get(controlKey).mutuallyExclusive.push(key);
                }
            }
        }
        
        function buildConflictMap(setupIdx) {
            const assignments = new Map(); // conflictKey -> [controlRef, ...]
            
            // Collect all assignments
            for (let group = 0; group < 8; group++) {
                // Encoders
                for (let i = 0; i < 8; i++) {
                    const data = getEncoderData(setupIdx, group, i);
                    const keys = getEncoderConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'encoder', group, index: i,
                            groupSelector: 'encoder',
                            subtype: ['r1', 'r2', 'CC', 'PC', 'Hi', 'PB', 'AT'][data.type] || 'CC'
                        });
                    }
                }
                
                // Push buttons (same group selector as encoders)
                for (let i = 0; i < 8; i++) {
                    const data = getPushData(setupIdx, group, i);
                    const keys = getButtonConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'push', group, index: i,
                            groupSelector: 'encoder',
                            subtype: { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' }[data.typeNibble] || '?'
                        });
                    }
                }
                
                // Green buttons (fader/button group selector)
                for (let i = 0; i < 8; i++) {
                    const data = getGreenData(setupIdx, group, i);
                    const keys = getButtonConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'green', group, index: i,
                            groupSelector: 'fader',
                            subtype: { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' }[data.typeNibble] || '?'
                        });
                    }
                }
                
                // Faders 1-8
                for (let i = 0; i < 8; i++) {
                    const data = getFaderData(setupIdx, group, i);
                    const keys = getFaderConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'fader', group, index: i,
                            groupSelector: 'fader',
                            subtype: ['CC', 'PC', 'PB', 'AT'][data.type] || 'CC'
                        });
                    }
                }
                
                // Fader 9
                const f9data = getFader9Data(setupIdx, group);
                const f9key = `${f9data.channel}-cc-${f9data.cc}`;
                if (!assignments.has(f9key)) assignments.set(f9key, []);
                assignments.get(f9key).push({
                    type: 'fader9', group, index: 0,
                    groupSelector: 'fader',
                    subtype: 'CC'
                });
            }
            
            // Build key-centric conflict structure
            const result = {
                concurrent: new Map(),
                mutuallyExclusive: new Map()
            };
            
            for (const [key, refs] of assignments) {
                if (refs.length < 2) continue;
                
                // Check if ANY pair in this key is concurrent
                let hasConcurrent = false;
                for (let i = 0; i < refs.length && !hasConcurrent; i++) {
                    for (let j = i + 1; j < refs.length && !hasConcurrent; j++) {
                        if (isConcurrentConflict(refs[i], refs[j])) {
                            hasConcurrent = true;
                        }
                    }
                }
                
                // Whole key goes into one bucket
                if (hasConcurrent) {
                    result.concurrent.set(key, { key, refs });
                } else {
                    result.mutuallyExclusive.set(key, { key, refs });
                }
            }
            
            return result;
        }
        
        function isConcurrentConflict(a, b) {
            // Different selector domains = can be active simultaneously = concurrent
            if (a.groupSelector !== b.groupSelector) {
                return true;
            }
            // Same selector domain + same group = concurrent (both active when that group selected)
            // Same selector domain + different groups = mutually exclusive
            return a.group === b.group;
        }
        
        function getEncoderConflictKeys(data) {
            const ch = data.channel; // Already 1-based from getEncoderData
            switch (data.type) {
                case 0: // CCr1
                case 1: // CCr2
                case 2: // CCAb
                    return [`${ch}-cc-${data.cc}`];
                case 3: { // PrGC - encoder sweeps a program range
                    const lo = Math.max(0, Math.min(127, data.min | 0));
                    const hi = Math.max(0, Math.min(127, data.max | 0));
                    const a = Math.min(lo, hi), b = Math.max(lo, hi);
                    const keys = [];
                    for (let p = a; p <= b; p++) keys.push(`${ch}-pc-${p}`);
                    return keys;
                }
                case 4: // CCAh (14-bit) - occupies CC and CC+32
                    if (data.cc < 0 || data.cc > 31) return [];
                    return [`${ch}-cc-${data.cc}`, `${ch}-cc-${data.cc + 32}`];
                case 5: // Pbnd
                    return [`${ch}-pb-null`];
                case 6: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getButtonConflictKeys(data) {
            if (data.typeNibble === 0x00) return []; // OFF
            const ch = data.channel; // Already 1-based
            switch (data.typeNibble) {
                case 0x10: // Note
                    return [`${ch}-note-${data.cc}`];
                case 0x20: // CC
                    return [`${ch}-cc-${data.cc}`];
                case 0x30: // PrGC - button sends upper on press, lower on release
                    const keys = [`${ch}-pc-${data.upper}`];
                    if (data.lower !== data.upper) {
                        keys.push(`${ch}-pc-${data.lower}`);
                    }
                    return keys;
                case 0x40: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getFaderConflictKeys(data) {
            const ch = data.channel; // Already 1-based
            switch (data.type) {
                case 0: // CCAb
                    return [`${ch}-cc-${data.cc}`];
                case 1: { // PrGC - fader sweeps a program range
                    const lo = Math.max(0, Math.min(127, data.min | 0));
                    const hi = Math.max(0, Math.min(127, data.max | 0));
                    const a = Math.min(lo, hi), b = Math.max(lo, hi);
                    const keys = [];
                    for (let p = a; p <= b; p++) keys.push(`${ch}-pc-${p}`);
                    return keys;
                }
                case 2: // Pbnd
                    return [`${ch}-pb-null`];
                case 3: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getControlConflictType(type, group, index) {
            const controlKey = `${type}-${group}-${index}`;
            const conflicts = conflictsByControl.get(controlKey);
            if (!conflicts) return null;
            
            if (showConcurrentConflicts && conflicts.concurrent.length > 0) {
                return 'concurrent';
            }
            if (showMutuallyExclusiveConflicts && conflicts.mutuallyExclusive.length > 0) {
                return 'mutuallyExclusive';
            }
            return null;
        }
        
        function formatConflictKey(key) {
            // Parse key like "1-cc-64" or "2-pb-null"
            const parts = key.split('-');
            const ch = parts[0];
            const type = parts[1];
            const num = parts[2];
            
            const typeNames = {
                'cc': 'CC',
                'note': 'Note',
                'pc': 'PC',
                'pb': 'PB',
                'at': 'AT'
            };
            
            if (num === 'null') {
                return `Ch${ch} ${typeNames[type] || type}`;
            }
            return `Ch${ch} ${typeNames[type] || type} ${num}`;
        }
        
        function formatControlRef(ref) {
            const typeNames = {
                'encoder': 'Enc',
                'push': 'Push',
                'green': 'Grn',
                'fader': 'Fad',
                'fader9': 'F9'
            };
            const name = typeNames[ref.type] || ref.type;
            return `${name} G${ref.group + 1}.${ref.index + 1} (${ref.subtype})`;
        }
        
        function updateConflictUI() {
            // Update filter chip counts
            updateConflictFilterCounts();
            
            // Re-render overview if in that view
            if (currentView === 'overview') {
                renderOverview();
            }
        }
        
        function updateConflictFilterCounts() {
            const concurrentCount = document.getElementById('concurrentCount');
            const meCount = document.getElementById('meCount');
            
            if (concurrentCount) {
                concurrentCount.textContent = conflicts.concurrent.size;
            }
            if (meCount) {
                meCount.textContent = conflicts.mutuallyExclusive.size;
            }
        }
        
        function toggleConcurrentFilter() {
            showConcurrentConflicts = !showConcurrentConflicts;
            updateConflictUI();
        }
        
        function toggleMEFilter() {
            showMutuallyExclusiveConflicts = !showMutuallyExclusiveConflicts;
            updateConflictUI();
        }
        
        // ============================================================
        // Copy/Paste Operations
        // ============================================================
        
        // Generic control data accessors
        function getControlData(controlType, setupIdx, group, index) {
            switch (controlType) {
                case 'encoder': return getEncoderData(setupIdx, group, index);
                case 'push': return getPushData(setupIdx, group, index);
                case 'green': return getGreenData(setupIdx, group, index);
                case 'fader': return getFaderData(setupIdx, group, index);
                case 'fader9': return getFader9Data(setupIdx, group);
                default: return null;
            }
        }
        
        function setControlData(controlType, setupIdx, group, index, data) {
            switch (controlType) {
                case 'encoder': return setEncoderData(setupIdx, group, index, data);
                case 'push': return setPushData(setupIdx, group, index, data);
                case 'green': return setGreenData(setupIdx, group, index, data);
                case 'fader': return setFaderData(setupIdx, group, index, data);
                case 'fader9': return setFader9Data(setupIdx, group, data);
            }
        }
        
        function formatControlName(controlType, group, index) {
            const typeNames = {
                'encoder': 'Enc',
                'push': 'Push',
                'green': 'Grn',
                'fader': 'Fad',
                'fader9': 'Fad9'
            };
            const name = typeNames[controlType] || controlType;
            if (controlType === 'fader9') {
                return `${name} G${group + 1}`;
            }
            return `${name} G${group + 1}.${index + 1}`;
        }
        
        // Copy operations
        function copyControl(controlType, setupIdx, group, index) {
            const data = getControlData(controlType, setupIdx, group, index);
            if (!data) return;
            
            clipboard = {
                type: 'control',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: group,
                sourceIndex: index,
                data: { ...data }
            };
            showToast(`Copied ${formatControlName(controlType, group, index)}`);
        }
        
        function copyRow(controlType, setupIdx, index) {
            const data = [];
            for (let g = 0; g < 8; g++) {
                data.push({ ...getControlData(controlType, setupIdx, g, index) });
            }
            clipboard = {
                type: 'row',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: null,
                sourceIndex: index,
                data
            };
            const typeName = { encoder: 'Enc', push: 'Push', green: 'Grn', fader: 'Fad', fader9: 'Fad9' }[controlType];
            showToast(`Copied ${typeName} ${index + 1} row (all groups)`);
        }
        
        function copyColumn(controlType, setupIdx, group) {
            const count = controlType === 'fader9' ? 1 : 8;
            const data = [];
            for (let i = 0; i < count; i++) {
                data.push({ ...getControlData(controlType, setupIdx, group, i) });
            }
            clipboard = {
                type: 'column',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: group,
                sourceIndex: null,
                data
            };
            const typeName = { encoder: 'Encoders', push: 'Push Btns', green: 'Green Btns', fader: 'Faders', fader9: 'Fader 9' }[controlType];
            showToast(`Copied Group ${group + 1} ${typeName}`);
        }
        
        // Check paste compatibility
        function canPaste(clip, targetControlType) {
            if (!clip) return false;
            // Must be same control type
            return clip.controlType === targetControlType;
        }
        
        // Apply offset with wrap/clamp
        function applyOffset(value, delta, min, max, wrapMode) {
            const v = value + delta;
            if (wrapMode === 'wrap') {
                const range = max - min + 1;
                return min + (((v - min) % range) + range) % range;
            } else {
                return Math.max(min, Math.min(max, v)); // clamp
            }
        }
        
        // Transform copied data with options
        function transformControlData(data, options, incrementIndex = 0) {
            let newData = { ...data };
            
            // Apply channel offset (channel is 1-based: 1-16)
            if (options.channelOffset && options.channelOffset !== 0) {
                const newCh = applyOffset(newData.channel, options.channelOffset, 1, 16, options.wrapMode);
                newData.channel = newCh;
            }
            
            // Apply CC/number offset
            if (options.numberOffset && options.numberOffset !== 0) {
                if (newData.cc !== undefined) {
                    newData.cc = applyOffset(newData.cc, options.numberOffset, 0, 127, options.wrapMode);
                }
            }
            
            // Apply auto-increment
            if (options.autoIncrement && options.incrementBy) {
                const delta = options.incrementBy * incrementIndex;
                if (newData.cc !== undefined) {
                    newData.cc = applyOffset(newData.cc, delta, 0, 127, options.wrapMode);
                }
            }
            
            return newData;
        }
        
        // Paste to single control
        function pasteToControl(controlType, setupIdx, group, index, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const before = getControlData(controlType, setupIdx, group, index);
            let sourceData;
            
            if (clipboard.type === 'control') {
                sourceData = clipboard.data;
            } else if (clipboard.type === 'row') {
                sourceData = clipboard.data[group]; // Use data for this group
            } else if (clipboard.type === 'column') {
                sourceData = clipboard.data[index]; // Use data for this index
            } else {
                showToast('Unsupported clipboard type for single paste', 'warning');
                return;
            }
            
            const newData = transformControlData(sourceData, options, 0);
            setControlData(controlType, setupIdx, group, index, newData);
            
            recordUndo({
                type: 'control',
                description: `Paste to ${formatControlName(controlType, group, index)}`,
                controlType,
                setupIdx,
                group,
                index,
                before,
                after: newData
            });
            
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to ${formatControlName(controlType, group, index)}`);
        }
        
        // Paste row to all groups
        function pasteRowToGroups(controlType, setupIdx, index, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const batch = { type: 'batch', description: `Paste row ${index + 1}`, actions: [] };
            
            for (let g = 0; g < 8; g++) {
                const before = getControlData(controlType, setupIdx, g, index);
                let sourceData;
                
                if (clipboard.type === 'control') {
                    sourceData = clipboard.data;
                } else if (clipboard.type === 'row') {
                    sourceData = clipboard.data[g];
                } else if (clipboard.type === 'column') {
                    sourceData = clipboard.data[0]; // Use first item for all
                }
                
                const newData = transformControlData(sourceData, options, g);
                setControlData(controlType, setupIdx, g, index, newData);
                
                batch.actions.push({
                    type: 'control',
                    controlType,
                    setupIdx,
                    group: g,
                    index,
                    before,
                    after: newData
                });
            }
            
            recordUndo(batch);
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to row ${index + 1} (all groups)`);
        }
        
        // Paste column to group
        function pasteColumnToGroup(controlType, setupIdx, group, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const count = controlType === 'fader9' ? 1 : 8;
            const batch = { type: 'batch', description: `Paste to Group ${group + 1}`, actions: [] };
            
            for (let i = 0; i < count; i++) {
                const before = getControlData(controlType, setupIdx, group, i);
                let sourceData;
                
                if (clipboard.type === 'control') {
                    sourceData = clipboard.data;
                } else if (clipboard.type === 'row') {
                    sourceData = clipboard.data[0]; // Use first group's data
                } else if (clipboard.type === 'column') {
                    sourceData = clipboard.data[i];
                }
                
                const newData = transformControlData(sourceData, options, i);
                setControlData(controlType, setupIdx, group, i, newData);
                
                batch.actions.push({
                    type: 'control',
                    controlType,
                    setupIdx,
                    group,
                    index: i,
                    before,
                    after: newData
                });
            }
            
            recordUndo(batch);
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to Group ${group + 1}`);
        }
        
        // Set selection (for overview click/keyboard)
        function setSelection(controlType, group, index) {
            // Clear previous selection highlight
            clearSelectionHighlight();
            
            selection = {
                mode: 'single',
                controlType,
                group,
                index
            };
            
            // Apply new selection highlight
            updateSelectionHighlight();
        }
        
        // Clear selection
        function clearSelection() {
            clearSelectionHighlight();
            selection = { mode: 'none', controlType: null, group: null, index: null };
        }
        
        // Update visual highlight for current selection
        function updateSelectionHighlight() {
            if (selection.mode === 'none' || currentView !== 'overview') return;
            
            const cell = getOverviewCell(selection.controlType, selection.group, selection.index);
            if (cell) {
                cell.classList.add('selected');
                cell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        }
        
        // Clear visual highlight
        function clearSelectionHighlight() {
            const selected = document.querySelectorAll('.overview-table td.selected');
            selected.forEach(cell => cell.classList.remove('selected'));
        }
        
        // Get cell element by control type, group, index
        function getOverviewCell(controlType, group, index) {
            const table = document.querySelector('.overview-table');
            if (!table) return null;
            
            // Find cell with matching data attributes
            return table.querySelector(`td[data-type="${controlType}"][data-group="${group}"][data-index="${index}"]`);
        }
        
        // Get max index for control type
        function getMaxIndex(controlType) {
            return controlType === 'fader9' ? 0 : 7;
        }
        
        // Keyboard navigation
        function moveSelection(direction) {
            if (currentView !== 'overview') return;
            
            // If no selection, start at 0,0
            if (selection.mode === 'none') {
                setSelection(overviewTab === 'encoders' ? 'encoder' : 
                            overviewTab === 'push' ? 'push' :
                            overviewTab === 'green' ? 'green' : 'fader', 0, 0);
                return;
            }
            
            let { controlType, group, index } = selection;
            const maxIndex = getMaxIndex(controlType);
            
            switch (direction) {
                case 'left':
                    group = Math.max(0, group - 1);
                    break;
                case 'right':
                    group = Math.min(7, group + 1);
                    break;
                case 'up':
                    if (index > 0) {
                        index--;
                    } else if (controlType === 'fader9') {
                        // Move from fader9 row to fader row 8
                        controlType = 'fader';
                        index = 7;
                    }
                    break;
                case 'down':
                    if (index < maxIndex) {
                        index++;
                    } else if (controlType === 'fader' && overviewTab === 'faders') {
                        // Move from fader row 8 to fader9 row
                        controlType = 'fader9';
                        index = 0;
                    }
                    break;
            }
            
            setSelection(controlType, group, index);
        }
        
        // Handle Enter key - jump to focused view
        function handleEnterKey() {
            if (currentView === 'overview' && selection.mode !== 'none') {
                jumpToFocusedView(selection.controlType, selection.group, selection.index);
            }
        }
        
        // Context menu
        let contextMenu = null;
        
        function showContextMenu(e, controlType, group, index) {
            e.preventDefault();
            hideContextMenu();
            
            setSelection(controlType, group, index);
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.innerHTML = `
                <div class="context-menu-item" onclick="copyControl('${controlType}', ${currentSetup}, ${group}, ${index}); hideContextMenu();">
                    Copy Control
                </div>
                <div class="context-menu-item" onclick="copyRow('${controlType}', ${currentSetup}, ${index}); hideContextMenu();">
                    Copy Row (${controlType === 'fader9' ? 'Fad9' : (index + 1)} Ã— 8 groups)
                </div>
                <div class="context-menu-item" onclick="copyColumn('${controlType}', ${currentSetup}, ${group}); hideContextMenu();">
                    Copy Column (Group ${group + 1})
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item ${!clipboard || !canPaste(clipboard, controlType) ? 'disabled' : ''}" 
                     onclick="${clipboard && canPaste(clipboard, controlType) ? `pasteToControl('${controlType}', ${currentSetup}, ${group}, ${index}); hideContextMenu();` : ''}">
                    Paste
                </div>
                <div class="context-menu-item ${!clipboard || !canPaste(clipboard, controlType) ? 'disabled' : ''}" 
                     onclick="${clipboard && canPaste(clipboard, controlType) ? `showPasteSpecialDialog('${controlType}', ${group}, ${index}); hideContextMenu();` : ''}">
                    Paste Special...
                </div>
            `;
            
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            
            document.body.appendChild(menu);
            contextMenu = menu;
            
            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 0);
        }
        
        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }
        
        // Paste Special Dialog
        function showPasteSpecialDialog(controlType, group, index) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const sourceInfo = clipboard.type === 'control' 
                ? formatControlName(clipboard.controlType, clipboard.sourceGroup, clipboard.sourceIndex)
                : clipboard.type === 'row'
                    ? `Row ${clipboard.sourceIndex + 1} (8 groups)`
                    : `Group ${clipboard.sourceGroup + 1} column`;
            
            overlay.innerHTML = `
                <div class="modal-dialog paste-special-dialog">
                    <h3>Paste Special</h3>
                    <p class="paste-source">Source: ${sourceInfo}</p>
                    
                    <div class="paste-section">
                        <label class="paste-section-label">Paste to:</label>
                        <div class="paste-targets">
                            <label><input type="radio" name="pasteTarget" value="single" checked> Current cell</label>
                            <label><input type="radio" name="pasteTarget" value="row"> Entire row (all groups)</label>
                            <label><input type="radio" name="pasteTarget" value="column"> Entire column (Group ${group + 1})</label>
                        </div>
                    </div>
                    
                    <div class="paste-section">
                        <label class="paste-section-label">Transforms:</label>
                        <div class="paste-transforms">
                            <div class="transform-row">
                                <label>Channel offset:</label>
                                <input type="number" id="channelOffset" value="0" min="-15" max="15">
                            </div>
                            <div class="transform-row">
                                <label>CC/Number offset:</label>
                                <input type="number" id="numberOffset" value="0" min="-127" max="127">
                            </div>
                            <div class="transform-row">
                                <label>
                                    <input type="checkbox" id="autoIncrement"> Auto-increment CC by:
                                </label>
                                <input type="number" id="incrementBy" value="1" min="1" max="127" style="width: 60px;">
                            </div>
                            <div class="transform-row">
                                <label>Out-of-range:</label>
                                <select id="wrapMode">
                                    <option value="clamp">Clamp to limits</option>
                                    <option value="wrap">Wrap around</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-buttons">
                        <button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        <button class="btn btn-primary" onclick="executePasteSpecial('${controlType}', ${group}, ${index}); this.closest('.modal-overlay').remove();">Paste</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        function executePasteSpecial(controlType, group, index) {
            const target = document.querySelector('input[name="pasteTarget"]:checked').value;
            const options = {
                channelOffset: parseInt(document.getElementById('channelOffset').value) || 0,
                numberOffset: parseInt(document.getElementById('numberOffset').value) || 0,
                autoIncrement: document.getElementById('autoIncrement').checked,
                incrementBy: parseInt(document.getElementById('incrementBy').value) || 1,
                wrapMode: document.getElementById('wrapMode').value
            };
            
            switch (target) {
                case 'single':
                    pasteToControl(controlType, currentSetup, group, index, options);
                    break;
                case 'row':
                    pasteRowToGroups(controlType, currentSetup, index, options);
                    break;
                case 'column':
                    pasteColumnToGroup(controlType, currentSetup, group, options);
                    break;
            }
        }
        
        // Keyboard copy/paste for current selection or focused view
        function handleCopy() {
            if (currentView === 'focused') {
                // In focused view, copy the currently visible encoders (first one as default)
                // This is a simple approach - could be enhanced with actual selection
                copyControl('encoder', currentSetup, encoderGroup, 0);
            } else if (selection.mode !== 'none') {
                copyControl(selection.controlType, currentSetup, selection.group, selection.index);
            } else {
                showToast('Nothing selected to copy', 'warning');
            }
        }
        
        function handlePaste() {
            if (!clipboard) {
                showToast('Nothing to paste', 'warning');
                return;
            }
            
            if (currentView === 'focused') {
                // Paste to current encoder group, first encoder
                if (canPaste(clipboard, 'encoder')) {
                    pasteToControl('encoder', currentSetup, encoderGroup, 0);
                } else {
                    showToast('Clipboard contents not compatible with encoders', 'warning');
                }
            } else if (selection.mode !== 'none') {
                pasteToControl(selection.controlType, currentSetup, selection.group, selection.index);
            } else {
                showToast('Nothing selected to paste to', 'warning');
            }
        }
        
        // ============================================================
        // Keyboard Shortcuts
        // ============================================================
        
        document.addEventListener('keydown', (e) => {
            // Check if we're in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
            
            if (ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if (ctrlKey && e.key === 'z' && e.shiftKey) {
                e.preventDefault();
                redo();
            } else if (ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (ctrlKey && e.key === 'c' && !e.shiftKey && !e.altKey) {
                e.preventDefault();
                handleCopy();
            } else if (ctrlKey && e.key === 'v' && !e.shiftKey) {
                e.preventDefault();
                handlePaste();
            } else if (e.key === 'Escape') {
                hideContextMenu();
                clearSelection();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveSelection('left');
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveSelection('right');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                moveSelection('up');
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                moveSelection('down');
            } else if (e.key === 'Enter') {
                e.preventDefault();
                handleEnterKey();
            } else if (e.key === 'Tab' && currentView === 'overview') {
                e.preventDefault();
                // Tab moves right, Shift+Tab moves left
                moveSelection(e.shiftKey ? 'left' : 'right');
            }
        });
        
        // ============================================================
        // Init
        // ============================================================
        
        async function loadDefaultSysEx() {
            try {
                updateStatus('', 'Loading factory_default.syx...');
                const response = await fetch('factory_default.syx');
                if (!response.ok) {
                    console.log('No factory_default.syx found, waiting for manual import');
                    updateStatus('', 'No data loaded');
                    return;
                }
                
                const buffer = await response.arrayBuffer();
                rawBuffer = new Uint8Array(buffer);
                
                if (rawBuffer.length !== EXPECTED_SIZE) {
                    console.error(`Invalid file size: ${rawBuffer.length} bytes. Expected ${EXPECTED_SIZE} bytes.`);
                    rawBuffer = null;
                    updateStatus('', 'No data loaded');
                    return;
                }
                
                if (rawBuffer[0] !== 0xF0 || rawBuffer[rawBuffer.length - 1] !== 0xF7) {
                    console.error('Invalid SysEx file: Missing F0/F7 framing bytes.');
                    rawBuffer = null;
                    updateStatus('', 'No data loaded');
                    return;
                }
                
                sectionIndex = buildIndex(rawBuffer);
                
                // Enable UI
                document.getElementById('setupSelect').disabled = false;
                document.getElementById('setupSelect').value = '0';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('exportJsonBtn').disabled = false;
                
                currentSetup = 0;
                encoderGroup = 0;
                faderGroup = 0;
                isModified = false;
                dirtyBanks.clear();
                
                // Clear undo/redo stacks on fresh load
                undoStack.length = 0;
                redoStack.length = 0;
                updateUndoRedoUI();
                
                updateGroupTabs('encoderGroupTabs', 0);
                updateGroupTabs('faderGroupTabs', 0);
                updateGroupNames();
                updateStatus('loaded', 'Loaded: factory_default.syx');
                document.getElementById('fileInfo').textContent = `factory_default.syx (${rawBuffer.length.toLocaleString()} bytes)`;
                
                // Build initial conflict map
                rebuildConflictMap();
                
                renderFocusedView();
            } catch (err) {
                console.log('Could not auto-load factory_default.syx:', err.message);
                updateStatus('', 'No data loaded');
            }
        }
        
        async function initializeEditor() {
            // Check if user previously said "don't ask again"
            if (sessionStorage.getItem('uc4-skip-restore') === 'true') {
                clearSession();
                dirtyBanks.clear();
                await loadDefaultSysEx();
                return;
            }
            
            // Check for saved session with actual unsaved changes
            const savedSession = loadSession();
            
            // Only prompt if there are dirty banks (actual unsaved edits)
            if (savedSession && savedSession.dirtyBanks && savedSession.dirtyBanks.length > 0) {
                const timeSince = formatTimeSince(savedSession.timestamp);
                
                // Show restore prompt
                const result = await showRestoreDialog(timeSince, savedSession);
                
                if (result === 'restore') {
                    restoreSession(savedSession);
                    return;
                } else if (result === 'discard-permanently') {
                    clearSession();
                    dirtyBanks.clear();
                    // Don't prompt again this browser session
                    sessionStorage.setItem('uc4-skip-restore', 'true');
                } else {
                    clearSession();
                    dirtyBanks.clear();
                }
            } else if (savedSession) {
                // Session exists but no dirty banks = clean baseline, just clear it
                clearSession();
            }
            
            // Load factory defaults
            await loadDefaultSysEx();
        }
        
        initUI();
        initializeEditor();
    </script>
</body>
</html>
