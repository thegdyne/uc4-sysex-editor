<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UC4 SysEx Editor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Orbitron:wght@400;500;700&display=swap');
        
        :root {
            --bg-dark: #0a0a0c;
            --bg-panel: #111114;
            --bg-control: #18181c;
            --bg-input: #1e1e24;
            --border: #2a2a32;
            --border-light: #3a3a44;
            --text: #e0e0e8;
            --text-dim: #888898;
            --text-muted: #555560;
            --accent: #00d4aa;
            --accent-dim: #00a888;
            --warning: #ffaa00;
            --error: #ff4466;
            --encoder: #00aaff;
            --push: #aa66ff;
            --green-btn: #44dd66;
            --fader: #ff8844;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.4;
        }
        
        /* Header */
        .header {
            background: linear-gradient(180deg, var(--bg-panel) 0%, var(--bg-dark) 100%);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        .logo span {
            color: var(--text-dim);
            font-weight: 400;
        }
        
        .file-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .btn {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: var(--accent);
            color: var(--bg-dark);
            border-color: var(--accent);
            font-weight: 600;
        }
        
        .btn-primary:hover {
            background: var(--accent-dim);
            border-color: var(--accent-dim);
            color: var(--bg-dark);
        }
        
        .btn-divider {
            display: inline-block;
            width: 1px;
            height: 1.5rem;
            background: var(--border);
            margin: 0 0.5rem;
            vertical-align: middle;
        }
        
        .help-link {
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            background: transparent;
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .help-link:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .toast {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 0.75rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
        }
        
        .toast.error {
            border-color: var(--error);
            color: var(--error);
        }
        
        .toast.success {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .toast.warning {
            border-color: var(--warning);
            color: var(--warning);
        }
        
        .toast.info {
            border-color: var(--border-light);
            color: var(--text);
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Restore Dialog */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .modal-dialog {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
        }
        
        .modal-dialog h3 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent);
            margin-bottom: 1rem;
        }
        
        .modal-dialog p {
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }
        
        .modal-dialog .info {
            background: var(--bg-input);
            padding: 0.75rem;
            margin: 1rem 0;
            font-size: 0.8rem;
        }
        
        .modal-dialog label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-dim);
            margin: 1rem 0;
            cursor: pointer;
        }
        
        .modal-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        
        /* Group Name Editor Modal */
        .group-name-dialog input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            text-align: center;
            margin: 1rem 0;
        }
        
        .group-name-dialog input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .group-name-dialog .preview {
            font-size: 0.85rem;
            color: var(--text-dim);
            text-align: center;
            margin-bottom: 0.5rem;
        }
        
        .group-name-dialog .preview span {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            letter-spacing: 0.15em;
        }
        
        .group-name-dialog .hint {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            line-height: 1.6;
        }
        
        .group-name-dialog .error {
            color: var(--error);
            font-size: 0.8rem;
            text-align: center;
            min-height: 1.2em;
        }
        
        .group-name-dialog .warning {
            background: rgba(255, 170, 0, 0.15);
            border: 1px solid var(--warning);
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            color: var(--warning);
            margin-bottom: 1rem;
        }
        
        /* Editable group name styling */
        .group-name {
            cursor: pointer;
            padding: 0 0.25rem;
            border-radius: 2px;
            transition: background 0.15s;
        }
        
        .group-name:hover {
            background: var(--bg-control);
            color: var(--accent);
        }
        
        .group-name.has-warning {
            color: var(--warning);
        }
        
        .group-name-row td {
            cursor: pointer;
        }
        
        .group-name-row td:hover {
            background: var(--bg-control);
            color: var(--accent);
        }
        
        /* Overview Mode */
        .overview-container {
            padding: 1rem;
        }
        
        .overview-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .overview-tab {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .overview-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .overview-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .overview-grid {
            overflow-x: auto;
        }
        
        .overview-section {
            margin-bottom: 2rem;
        }
        
        .overview-section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 0 0 0.75rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .overview-section-title.encoders { color: var(--encoder); border-color: var(--encoder); }
        .overview-section-title.push { color: var(--push); border-color: var(--push); }
        .overview-section-title.green { color: var(--green-btn); border-color: var(--green-btn); }
        .overview-section-title.faders { color: var(--fader); border-color: var(--fader); }
        .overview-section-title.fader9 { color: var(--fader); border-color: var(--fader); }
        
        .overview-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        
        .overview-table th,
        .overview-table td {
            border: 1px solid var(--border);
            padding: 0.4rem 0.5rem;
            text-align: center;
            min-width: 80px;
        }
        
        .overview-table th {
            background: var(--bg-panel);
            color: var(--text-dim);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .overview-table th.group-header {
            color: var(--accent);
        }
        
        .overview-table th.row-header {
            text-align: left;
            width: 70px;
            min-width: 70px;
        }
        
        .overview-table td {
            background: var(--bg-input);
            cursor: pointer;
            transition: background 0.1s;
        }
        
        .overview-table td:hover {
            background: var(--bg-control);
        }
        
        .overview-table td.conflict {
            background: rgba(255, 170, 0, 0.2);
        }
        
        .overview-table td.conflict-dim {
            background: rgba(255, 170, 0, 0.1);
        }
        
        .overview-table td.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
            background: rgba(0, 255, 170, 0.15);
        }
        
        .overview-table td.qp-source {
            outline: 2px solid var(--warning);
            outline-offset: -2px;
            background: rgba(255, 170, 0, 0.15);
        }
        
        .overview-table td.selected.conflict {
            background: rgba(255, 170, 0, 0.3);
        }
        
        .overview-table td.selected.conflict-dim {
            background: rgba(255, 170, 0, 0.2);
        }
        
        .overview-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        
        .overview-cell .conflict-icon {
            color: var(--warning);
            font-size: 0.65rem;
        }
        
        .group-name-row td {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            color: var(--text-muted);
            background: var(--bg-panel) !important;
            padding: 0.2rem 0.5rem;
        }
        
        /* Conflict Filter Chips */
        .conflict-filters {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
        }
        
        .conflict-filters-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 0.5rem;
        }
        
        .filter-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.15s;
            user-select: none;
        }
        
        .filter-chip:hover {
            border-color: var(--accent);
        }
        
        .filter-chip.active {
            background: var(--warning);
            border-color: var(--warning);
            color: var(--bg-dark);
        }
        
        .filter-chip.active.dim {
            background: rgba(255, 170, 0, 0.3);
            border-color: var(--warning);
            color: var(--warning);
        }
        
        .filter-chip .count {
            font-weight: 600;
        }
        
        .filter-chip .checkmark {
            font-size: 0.8rem;
        }
        
        /* Conflict Panel */
        .conflict-panel {
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .conflict-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .conflict-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
        }
        
        .conflict-item:last-child {
            border-bottom: none;
        }
        
        .conflict-item .warning-icon {
            color: var(--warning);
            flex-shrink: 0;
        }
        
        .conflict-item.dim .warning-icon {
            opacity: 0.5;
        }
        
        .conflict-key {
            color: var(--accent);
            font-weight: 600;
            margin-right: 0.5rem;
        }
        
        .conflict-refs {
            color: var(--text-dim);
        }
        
        /* Context Menu */
        .context-menu {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            min-width: 200px;
            z-index: 1000;
            padding: 0.25rem 0;
        }
        
        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text);
        }
        
        .context-menu-item:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        .context-menu-item.disabled {
            color: var(--text-muted);
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: none;
            color: var(--text-muted);
        }
        
        .context-menu-separator {
            height: 1px;
            background: var(--border);
            margin: 0.25rem 0;
        }
        
        /* Quick Paste Toolbar */
        .quick-paste-toolbar {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.75rem;
        }
        
        .quick-paste-toolbar.collapsed {
            padding: 0.4rem 0.75rem;
        }
        
        .quick-paste-toolbar.collapsed .qp-expanded-content {
            display: none;
        }
        
        .qp-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .qp-label {
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.65rem;
        }
        
        .qp-mode-buttons {
            display: flex;
            gap: 2px;
        }
        
        .qp-mode-btn {
            font-family: inherit;
            font-size: 0.7rem;
            padding: 0.3rem 0.6rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
        }
        
        .qp-mode-btn:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .qp-mode-btn.active {
            font-weight: 600;
        }
        
        .qp-mode-btn.active[data-mode="off"] {
            background: var(--bg-input);
            border-color: var(--border-light);
            color: var(--text);
        }
        
        .qp-mode-btn.active[data-mode="copy"] {
            background: var(--encoder);
            border-color: var(--encoder);
            color: var(--bg-dark);
        }
        
        .qp-mode-btn.active[data-mode="paste"] {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
        }
        
        .qp-scope-btns {
            display: flex;
            gap: 2px;
        }
        
        .qp-scope-btn {
            font-family: inherit;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .qp-scope-btn:hover {
            border-color: var(--accent);
        }
        
        .qp-scope-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .qp-scope-btn.locked {
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .qp-scope-btn.locked.active {
            opacity: 1;
        }
        
        .qp-source-display {
            color: var(--text);
            padding: 0.25rem 0.5rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            min-width: 120px;
        }
        
        .qp-source-display.has-source {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .qp-source-display .lock-icon {
            margin-left: 0.25rem;
            font-size: 0.65rem;
        }
        
        .qp-ch-section {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .qp-ch-section select {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            min-width: 60px;
        }
        
        .qp-status {
            color: var(--text-muted);
            font-style: italic;
            margin-left: auto;
        }
        
        .qp-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .qp-action-btn {
            font-family: inherit;
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
        }
        
        .qp-action-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        /* Overview table mode styles */
        .overview-table.qp-copy-mode td {
            cursor: crosshair;
        }
        
        .overview-table.qp-paste-mode td {
            cursor: cell;
        }
        
        .overview-table.qp-paste-mode td.qp-incompatible {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        /* Cell/Column/Row hover highlighting */
        .overview-table td.qp-cell-hover,
        .overview-table td.qp-column-hover,
        .overview-table td.qp-row-hover {
            outline: 2px dashed var(--accent);
            outline-offset: -2px;
            background: rgba(0, 212, 170, 0.1);
        }
        
        /* Just pasted flash animation */
        @keyframes qpFlash {
            0% { background: var(--accent); }
            100% { background: var(--bg-input); }
        }
        
        .overview-table td.just-pasted {
            animation: qpFlash 0.4s ease-out;
        }
        
        /* Paste Special Dialog */
        .paste-special-dialog {
            max-width: 400px;
        }
        
        .paste-source {
            color: var(--accent);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }
        
        .paste-section {
            margin-bottom: 1rem;
        }
        
        .paste-section-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        
        .paste-targets label {
            display: block;
            padding: 0.25rem 0;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .paste-targets input[type="radio"] {
            margin-right: 0.5rem;
        }
        
        .paste-transforms {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .transform-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        
        .transform-row label {
            min-width: 140px;
        }
        
        .transform-row input[type="number"] {
            width: 80px;
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        
        .transform-row select {
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        
        /* Navigation */
        .nav-bar {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 2rem;
            flex-wrap: wrap;
        }
        
        .nav-section {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .nav-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .link-groups-toggle {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: pointer;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            transition: all 0.15s;
        }
        
        .link-groups-toggle:hover {
            border-color: var(--accent);
        }
        
        .link-groups-toggle input[type="checkbox"] {
            display: none;
        }
        
        .link-groups-toggle .link-icon {
            font-size: 0.9rem;
            opacity: 0.5;
            transition: opacity 0.15s;
        }
        
        .link-groups-toggle input:checked ~ .link-icon {
            opacity: 1;
        }
        
        .link-groups-toggle input:checked ~ .nav-label {
            color: var(--accent);
        }
        
        .select-wrapper {
            position: relative;
        }
        
        select {
            font-family: inherit;
            font-size: 0.8rem;
            padding: 0.4rem 2rem 0.4rem 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
            cursor: pointer;
            appearance: none;
            min-width: 100px;
        }
        
        select:hover, select:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .select-wrapper::after {
            content: 'â–¾';
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-dim);
            pointer-events: none;
            font-size: 0.7rem;
        }
        
        .group-tabs {
            display: flex;
            gap: 2px;
        }
        
        .group-tab {
            font-family: inherit;
            font-size: 0.75rem;
            width: 2rem;
            height: 2rem;
            border: 1px solid var(--border);
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .group-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .group-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
        }
        
        .group-name-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: var(--accent);
            padding: 0.4rem 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            min-width: 4rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.15s, background 0.15s;
        }
        
        .group-name-display:hover {
            border-color: var(--accent);
            background: var(--bg-control);
        }
        
        /* Main Content */
        .main-content {
            padding: 1.5rem;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .no-data {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }
        
        .no-data h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }
        
        .no-data p {
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }
        
        /* Control Sections */
        .control-section {
            margin-bottom: 2rem;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .section-title::after {
            content: 'â€“';
            margin-left: 0.75rem;
            color: var(--border);
            font-weight: 300;
        }
        
        .section-title.encoders { color: var(--encoder); }
        .section-title.push { color: var(--push); }
        .section-title.green { color: var(--green-btn); }
        .section-title.faders { color: var(--fader); }
        .section-title.fader9 { color: var(--fader); }
        
        .section-badge {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            padding: 0.2rem 0.6rem;
            background: transparent;
            color: var(--accent);
            letter-spacing: 0.05em;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.15s;
        }
        
        .section-badge:hover {
            background: var(--bg-control);
        }
        
        /* Control Grid */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            overflow: hidden;
        }
        
        .control-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 0.75rem;
            transition: border-color 0.15s;
            overflow: hidden;
            min-width: 0;
        }
        
        .control-card:hover {
            border-color: var(--border-light);
        }
        
        .control-card.encoder { border-left: 3px solid var(--encoder); }
        .control-card.push { border-left: 3px solid var(--push); }
        .control-card.green { border-left: 3px solid var(--green-btn); }
        .control-card.fader { border-left: 3px solid var(--fader); }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .control-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
        }
        
        .control-index {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.4rem;
            gap: 0.5rem;
            min-width: 0;
        }
        
        .param-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            width: 3.5rem;
            flex-shrink: 0;
            text-transform: uppercase;
        }
        
        .param-input {
            flex: 1;
            min-width: 0;
        }
        
        .param-input input,
        .param-input select {
            width: 100%;
            min-width: 0;
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
            box-sizing: border-box;
            text-overflow: ellipsis;
        }
        
        .param-input input:focus,
        .param-input select:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .param-input input[type="number"] {
            -moz-appearance: textfield;
        }
        
        .param-input input::-webkit-outer-spin-button,
        .param-input input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Fader 9 Special */
        .fader9-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-left: 3px solid var(--fader);
            padding: 0.75rem;
            margin-top: 1rem;
        }
        
        .fader9-card .control-header {
            background: linear-gradient(90deg, rgba(255,136,68,0.1) 0%, transparent 100%);
            margin: -0.75rem -0.75rem 0.75rem -0.75rem;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        
        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 0.5rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem;
            color: var(--text-dim);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        
        .status-dot.loaded {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }
        
        .status-dot.modified {
            background: var(--warning);
            box-shadow: 0 0 8px var(--warning);
        }
        
        /* Warnings */
        .warning-badge {
            font-size: 0.6rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid var(--warning);
            color: var(--warning);
            margin-left: 0.5rem;
        }
        
        /* Hidden file input */
        .hidden-input {
            display: none;
        }
        
        /* View Toggle */
        .view-toggle {
            display: inline-flex;
            gap: 0;
            border-radius: 0;
        }
        
        .view-btn {
            font-family: inherit;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            border: 1px solid var(--accent);
            margin-left: -1px;
            background: var(--bg-control);
            color: var(--text-dim);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.15s;
        }
        
        .view-btn:first-child {
            margin-left: 0;
        }
        
        .view-btn:hover {
            background: var(--bg-input);
            color: var(--accent);
        }
        
        .view-btn.active {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .nav-bar {
                flex-direction: column;
                gap: 1rem;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }
        
        /* Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading {
            animation: pulse 1s infinite;
        }
        
        /* ============================================================
           Tooltip System
           ============================================================ */
        
        .tooltip {
            position: fixed;
            min-width: 240px;
            max-width: 320px;
            padding: 0.75rem;
            background: var(--bg-panel);
            border: 1px solid var(--accent);
            color: var(--text);
            font-size: 0.75rem;
            line-height: 1.5;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s ease-out;
            pointer-events: none;
        }
        
        .tooltip.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .tooltip-content {
            position: relative;
            z-index: 1;
        }
        
        .tooltip-arrow {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--bg-panel);
            border: 1px solid var(--accent);
            transform: rotate(45deg);
        }
        
        .tooltip.above .tooltip-arrow {
            bottom: -7px;
            border-top: none;
            border-left: none;
        }
        
        .tooltip.below .tooltip-arrow {
            top: -7px;
            border-bottom: none;
            border-right: none;
        }
        
        .has-tooltip {
            border-bottom: 1px dotted var(--text-dim);
            cursor: help;
        }
        
        /* Clickable labels that open option panels */
        .has-options {
            color: var(--accent);
            cursor: pointer;
            border-bottom: 1px solid var(--accent-dim);
            transition: color 0.15s;
        }
        
        .has-options:hover {
            color: var(--text);
            border-bottom-color: var(--accent);
        }
        
        @media (prefers-reduced-motion: reduce) {
            .tooltip {
                transition: none;
            }
        }
        
        /* Info Panel */
        .info-panel {
            position: fixed;
            min-width: 280px;
            max-width: 400px;
            max-height: 80vh;
            background: var(--bg-panel);
            border: 1px solid var(--accent);
            z-index: 10001;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .info-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg-control);
        }
        
        .info-panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .info-panel-close {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
            padding: 0;
            border: 1px solid var(--accent);
            border-radius: 4px;
            background: rgba(0, 212, 170, 0.1);
            color: var(--accent);
            cursor: pointer;
            font-size: 1.3rem;
            font-weight: bold;
            line-height: 1;
            transition: all 0.15s;
        }
        
        .info-panel-close:hover {
            background: var(--accent);
            color: var(--bg-dark);
        }
        
        .info-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        
        .info-panel-option {
            display: flex;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            transition: background 0.1s;
        }
        
        .info-panel-option:hover {
            background: var(--bg-control);
        }
        
        .info-panel-option.focused {
            background: var(--bg-input);
            outline: 1px solid var(--accent-dim);
            outline-offset: -1px;
        }
        
        .info-panel-marker {
            width: 20px;
            flex-shrink: 0;
            color: var(--accent);
            font-size: 0.75rem;
        }
        
        .info-panel-option-content {
            flex: 1;
            min-width: 0;
        }
        
        .info-panel-option-name {
            font-weight: 600;
            color: var(--text);
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }
        
        .info-panel-option-desc {
            color: var(--text-dim);
            font-size: 0.7rem;
            line-height: 1.4;
        }
        
        /* Touch dismiss overlay */
        .touch-dismiss-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            background: transparent;
        }
    </style>
</head>
<body>
    <div id="toastContainer" class="toast-container"></div>
    
    <!-- Tooltip element (single global instance) -->
    <div id="tooltip" class="tooltip" role="tooltip" aria-hidden="true">
        <div class="tooltip-content"></div>
        <div class="tooltip-arrow"></div>
    </div>
    
    <!-- Info Panel element (single global instance) -->
    <div id="infoPanel" class="info-panel" style="display: none;">
        <div class="info-panel-header">
            <span class="info-panel-title"></span>
            <button class="info-panel-close" aria-label="Close">&times;</button>
        </div>
        <div class="info-panel-content"></div>
    </div>
    
    <header class="header">
        <div class="logo">UC4 <span>SysEx Editor</span></div>
        <div class="view-toggle">
            <button class="view-btn active" id="focusedViewBtn" onclick="setView('focused')">Focused</button>
            <button class="view-btn" id="overviewBtn" onclick="setView('overview')">Overview</button>
        </div>
        <div class="file-actions">
            <input type="file" id="sysexInput" accept=".syx" class="hidden-input">
            <button class="btn" onclick="document.getElementById('sysexInput').click()">Import SysEx</button>
            <button class="btn" id="exportBtn" onclick="exportSysEx()" disabled>Export SysEx</button>
            <input type="file" id="jsonInput" accept=".json" class="hidden-input">
            <button class="btn" onclick="document.getElementById('jsonInput').click()">Import JSON</button>
            <button class="btn" id="exportJsonBtn" onclick="exportJSON()" disabled>Export JSON</button>
            <span class="btn-divider"></span>
            <button class="btn" id="undoBtn" onclick="undo()" disabled title="Undo (Ctrl+Z)">â†¶ Undo</button>
            <button class="btn" id="redoBtn" onclick="redo()" disabled title="Redo (Ctrl+Y)">â†· Redo</button>
            <button class="btn" id="resetBtn" onclick="confirmReset()" title="Reset to imported SysEx or defaults">âŸ² Reset</button>
            <span class="btn-divider"></span>
            <a href="UC4_EDITOR_GUIDE.html" class="btn help-link" target="_blank" title="Usage Guide">? Guide</a>
        </div>
    </header>
    
    <nav class="nav-bar">
        <div class="nav-section">
            <span class="nav-label">Setup</span>
            <div class="select-wrapper">
                <select id="setupSelect" onchange="selectSetup(this.value)" disabled>
                    <option value="">--</option>
                </select>
            </div>
        </div>
        
        <div class="nav-section">
            <label class="link-groups-toggle" title="Change both groups together">
                <input type="checkbox" id="linkGroupsCheckbox" onchange="toggleLinkGroups(this.checked)">
                <span class="link-icon">ðŸ”—</span>
                <span class="nav-label">Link</span>
            </label>
        </div>
        
        <div class="nav-section">
            <span class="nav-label">Encoder Grp</span>
            <div class="group-tabs" id="encoderGroupTabs">
                <!-- Generated by JS -->
            </div>
            <div class="group-name-display" id="encoderGroupName" onclick="showGroupNameEditor(currentSetup, encoderGroup)" title="Click to edit group name">----</div>
        </div>
        
        <div class="nav-section">
            <span class="nav-label">Fader/Btn Grp</span>
            <div class="group-tabs" id="faderGroupTabs">
                <!-- Generated by JS -->
            </div>
            <div class="group-name-display" id="faderGroupName" onclick="showGroupNameEditor(currentSetup, faderGroup)" title="Click to edit group name">----</div>
        </div>
    </nav>
    
    <main class="main-content" id="mainContent">
        <div class="no-data">
            <h2>No SysEx Data Loaded</h2>
            <p>Import a UC4 SysEx dump to begin editing.</p>
            <p>Expected file size: 100,640 bytes (all 18 setups)</p>
        </div>
    </main>
    
    <footer class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">No data loaded</span>
        </div>
        <div>
            <span id="fileInfo">--</span>
        </div>
    </footer>

    <script>
        // ============================================================
        // UC4 SysEx Editor - Core Logic
        // ============================================================
        
        // State
        let rawBuffer = null;
        let originalBuffer = null;  // Stores the imported SysEx for reset
        let sectionIndex = null;
        let currentSetup = 0;
        let encoderGroup = 0;
        let faderGroup = 0;
        let currentView = 'focused';
        let isModified = false;
        let suppressModified = false;
        let dirtyBanks = new Set();
        
        // Undo/Redo State
        const undoStack = [];
        const redoStack = [];
        const MAX_UNDO = 100;
        const COALESCE_WINDOW = 1000; // 1 second
        
        // Session Persistence State
        const STORAGE_KEY = 'uc4-editor-session';
        const SESSION_VERSION = 1;
        const AUTO_SAVE_DELAY = 2000; // 2 seconds
        let autoSaveTimer = null;
        
        // Conflict Detection State
        const CONFLICT_REBUILD_DELAY = 200; // 200ms
        let conflictRebuildTimer = null;
        let conflicts = { concurrent: new Map(), mutuallyExclusive: new Map() };
        let conflictsByControl = new Map(); // Quick lookup: "type-group-index" -> [conflict keys]
        
        // Conflict filter state
        let showConcurrentConflicts = true;
        let showMutuallyExclusiveConflicts = false;
        
        // Copy/Paste State
        let clipboard = null;
        let selection = {
            mode: 'none', // 'none' | 'single' | 'row' | 'column'
            controlType: null,
            group: null,
            index: null
        };
        
        // Quick Paste State (v1.0)
        const quickPaste = {
            mode: 'off',           // 'off' | 'copy' | 'paste'
            scope: 'cell',         // 'cell' | 'column' | 'row'
            source: null,          // { controlType, group, index, data, lockedScope, count }
            chMultiplier: 0,       // Channel offset multiplier (-8 to +8)
            ccMultiplier: 0,       // CC offset multiplier (-8 to +8)
            pasteCount: 0,         // Total pastes this session
            doubleClickToastShown: false
        };
        
        // Link Groups State
        let linkGroups = false;
        
        // Parameters that affect conflict detection
        const CONFLICT_PARAMS = new Set([
            'channel', 'type', 'cc', 'note', 'typeNibble', 
            'upper', 'lower', 'mode', 'min', 'max'
        ]);
        
        // Constants
        const EXPECTED_SIZE = 100640;
        const NUM_SETUPS = 18;
        const NUM_GROUPS = 8;
        
        // Debug flags (set to true for verbose console output)
        const DEBUG_GROUPNAMES = false;  // Log group name reads for setupIdx >= 8
        
        // Section IDs
        const SECTIONS = {
            ENCODER_CHAN_TYPE: 0x1C,
            ENCODER_ACC_DISP: 0x1D,
            PUSH_CHAN_TYPE: 0x1D,
            PUSH_CC: 0x1D,
            PUSH_LOWER: 0x1D,
            PUSH_UPPER: 0x1E,
            PUSH_MODE: 0x1E,
            GREEN_CHAN_TYPE: 0x1E,
            GREEN_CC: 0x1E,
            GREEN_LOWER: 0x1F,
            GREEN_UPPER: 0x1F,
            GREEN_MODE: 0x1F,
            FADER_CHAN_TYPE: 0x1F,
            FADER_CC: 0x20,
            FADER_MIN: 0x20,
            FADER_MAX: 0x20,
            FADER_MODE: 0x20,
            FADER9: 0x17,
            GROUP_NAMES: 0x14
        };
        
        const BANKS = {
            ENC_CHAN_TYPE: 0x00,
            ENC_CC: 0x40,
            ENC_MIN: 0x80,
            ENC_MAX: 0xC0,
            ENC_ACC_DISP: 0x00,
            PUSH_CHAN_TYPE: 0x40,
            PUSH_CC: 0x80,
            PUSH_LOWER: 0xC0,
            PUSH_UPPER: 0x00,
            PUSH_MODE: 0x40,
            GREEN_CHAN_TYPE: 0x80,
            GREEN_CC: 0xC0,
            GREEN_LOWER: 0x00,
            GREEN_UPPER: 0x40,
            GREEN_MODE: 0x80,
            FADER_CHAN_TYPE: 0xC0,
            FADER_CC: 0x00,
            FADER_MIN: 0x40,
            FADER_MAX: 0x80,
            FADER_MODE: 0xC0,
            FADER9: 0x00,
            GROUP_NAMES: 0x80
        };
        
        // ============================================================
        // Group Name Character Mapping (Single Source of Truth)
        // Per UC4_GROUP_NAME_EDITING_SPEC_v2
        // ============================================================
        
        // Single source of truth - value to glyph (32-element array, indices 0-31)
        // GLYPH_TABLE: Hardware-verified via SysEx dumps (2026-01-14)
        // Canonical range 0-31, verified positions marked with âœ“
        // Factory Ableton: Snd1=[27,22,13,1], trAC=[28,26,10,12], GLOb=[16,20,23,11]
        // Hardware tests: H1=17, H2/h=30, n_big=21(U), n_small=22(n), Q_9like=25(q)
        const GLYPH_TABLE = {
            0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9',  // âœ“ all
            10: 'A', 11: 'b', 12: 'C', 13: 'd', 14: 'E', 15: 'F', 16: 'G', 17: 'H',  // âœ“ A,b,C,d,G,H
            18: 'I', 19: 'J', 20: 'L', 21: 'U', 22: 'n', 23: 'O', 24: 'P', 25: 'q',  // âœ“ L,U,n,O,P,q
            26: 'r', 27: 'S', 28: 't', 29: 'Y', 30: 'h', 31: ' '  // âœ“ r,S,t,h; Y assumed at 29
        };
        
        // Non-canonical glyphs (outside 0-31 range, used in some presets)
        const NON_CANONICAL_GLYPHS = {
            33: '-',  // dash (verified: glyph_dash.syx)
            34: '_',  // underscore/lowbar (verified: glyph_lowbar.syx)
            35: 'âŒ',  // segment: top-left
            36: 'âˆ',  // segment: two top verticals
            37: 'âŒŠ',  // segment: two bottom horizontals
            38: ' '   // space variant (verified: glyph_blank.syx, Ableton RAC_/PAn_)
        };
        
        // Invariant check (run once at startup)
        for (let i = 0; i < 32; i++) {
            if (!(i in GLYPH_TABLE)) {
                throw new Error(`GLYPH_TABLE missing entry for value ${i}`);
            }
        }
        
        // Derived: glyph to value (built from GLYPH_TABLE + NON_CANONICAL_GLYPHS)
        const VALUE_TABLE = {};
        for (const [val, glyph] of Object.entries(GLYPH_TABLE)) {
            VALUE_TABLE[glyph] = parseInt(val);
        }
        // Add non-canonical (prefer canonical space at 31 over 38)
        VALUE_TABLE['-'] = 33;
        VALUE_TABLE['_'] = 34;
        
        // Input normalization: user input -> display glyph
        const INPUT_NORMALIZE = {
            // Lowercase that map to lowercase glyphs (7-seg limitation)
            'B': 'b', 'b': 'b',
            'D': 'd', 'd': 'd',
            'N': 'n', 'n': 'n',
            'T': 't', 't': 't',
            'R': 'r', 'r': 'r',
            'Q': 'q', 'q': 'q',  // q looks like 9 on 7-seg
            // Lowercase h maps to position 30 (distinct from H at 17)
            'h': 'h',
            'H': 'H',
            // Lowercase that map to uppercase glyphs
            'a': 'A', 'A': 'A',
            'c': 'C', 'C': 'C',
            'e': 'E', 'E': 'E',
            'f': 'F', 'F': 'F',
            'g': 'G', 'G': 'G',
            'i': 'I', 'I': 'I',
            'j': 'J', 'J': 'J',
            'l': 'L', 'L': 'L',
            'o': 'O', 'O': 'O',
            'p': 'P', 'P': 'P',
            's': 'S', 'S': 'S',
            'u': 'U', 'U': 'U',
            'y': 'Y', 'Y': 'Y',
            // Letters impossible on 7-seg, mapped to closest visual equivalent
            'V': 'U', 'v': 'U',  // V looks like U on 7-seg
            'W': 'U', 'w': 'U',  // W has no equivalent, U is closest
            'M': 'n', 'm': 'n',  // M approximated as n
            'K': 'H', 'k': 'H',  // K approximated as H
            'X': 'H', 'x': 'H',  // X approximated as H
            'Z': '2', 'z': '2',  // Z looks like 2 on 7-seg (classic trick)
            // Direct mappings
            '0': '0', '1': '1', '2': '2', '3': '3', '4': '4',
            '5': '5', '6': '6', '7': '7', '8': '8', '9': '9',
            '-': '-', '_': '_', ' ': ' '
        };
        
        function normalizeInputChar(char) {
            return INPUT_NORMALIZE[char] ?? null;  // null = invalid
        }
        
        function encodeGlyph(glyph) {
            return VALUE_TABLE[glyph] ?? null;  // null = not in table
        }
        
        function decodeGroupNameByte(val) {
            // UC4 glyph codes are NOT ASCII - they're indices into the 7-seg character set
            // Base set: 0-31, Extended set: 33-38 (verified from hardware)
            if (val >= 0 && val <= 31) {
                return { glyph: GLYPH_TABLE[val], canonical: true };
            } else if (val in NON_CANONICAL_GLYPHS) {
                return { glyph: NON_CANONICAL_GLYPHS[val], canonical: false };
            } else {
                // Unknown glyph code - show replacement character, NOT ASCII
                return { glyph: '\uFFFD', canonical: false };
            }
        }
        
        // Type definitions
        const ENCODER_TYPES = ['CCr1', 'CCr2', 'CCAb', 'PrGC', 'CCAh', 'Pbnd', 'AFtt'];
        const FADER_TYPES = ['CCAb', 'PrGC', 'Pbnd', 'AFtt'];
        const BUTTON_TYPES = {0x00: 'OFF', 0x10: 'Note', 0x20: 'CC', 0x30: 'PrGC', 0x40: 'AFtt'};
        const BUTTON_TYPE_VALUES = [0x00, 0x10, 0x20, 0x30, 0x40];
        const ACC_MODES = ['Acc0', 'Acc1', 'Acc2', 'Acc3'];
        const DISPLAY_MODES = ['OFF', 'Std', 'bPoL'];
        const BUTTON_DISPLAY_MODES = ['OFF', 'Std'];
        const GREEN_DISPLAY_MODES = ['OFF', 'Std', 'EXt'];
        const BUTTON_MODES = ['Momentary', 'Toggle'];
        const FADER_MODES = ['Jump', 'Snap'];
        
        // ============================================================
        // Tooltip Content (per UC4_FOCUSED_TOOLTIPS_SPEC_v6)
        // ============================================================
        
        const TOOLTIPS = {
            // Parameter labels - keyed by controlType.paramName
            labels: {
                'encoder.chan': "MIDI channel (1-16). Controls which channel receives encoder messages.",
                'encoder.cc': "Controller number (0-127). The MIDI CC number sent when encoder is turned. For CCAh mode, also occupies CC+32 for the LSB.",
                'encoder.type': "Message type sent when encoder is turned.",
                'encoder.acc': "Acceleration sensitivity. Higher values = faster response to quick turns.",
                'encoder.disp': "Display mode. How values appear on the UC4's 7-segment display.",
                'encoder.min': "Minimum output value (0-127). Encoder won't send values below this.",
                'encoder.max': "Maximum output value (0-127). Encoder won't send values above this.",
                
                'fader.chan': "MIDI channel (1-16). Controls which channel receives fader messages.",
                'fader.cc': "Controller number (0-127). The MIDI CC number sent when fader is moved.",
                'fader.type': "Message type sent when fader is moved.",
                'fader.mode': "Pickup behaviour. How the fader responds when position doesn't match current value.",
                'fader.disp': "Display mode. How values appear on the UC4's 7-segment display.",
                'fader.min': "Value sent at bottom position (0-127). Fader travel maps to Minâ†’Max range.",
                'fader.max': "Value sent at top position (0-127). Set Min > Max to invert fader direction.",
                
                'fader9.chan': "MIDI channel (1-16). Controls which channel receives expression pedal messages.",
                'fader9.cc': "Controller number (0-127). Typically CC 11 (Expression) or CC 7 (Volume).",
                'fader9.mode': "Pickup behaviour. Jump sends immediately; Snap waits to catch current value.",
                'fader9.min': "Value sent at heel position (0-127).",
                'fader9.max': "Value sent at toe position (0-127). Set Min > Max to invert pedal direction.",
                
                'push.chan': "MIDI channel (1-16). Controls which channel receives button messages.",
                'push.note': "Note or CC number (0-127). The MIDI note/CC sent when button is pressed.",
                'push.type': "Message type sent when button is pressed/released.",
                'push.mode': "Button behaviour. Momentary sends on press/release; Toggle latches on/off.",
                'push.lo': "Lower/release value (0-127). Sent on release (Momentary) or when toggled off.",
                'push.hi': "Upper/press value (0-127). Sent on press (Momentary) or when toggled on.",
                
                'green.chan': "MIDI channel (1-16). Controls which channel receives button messages.",
                'green.note': "Note or CC number (0-127). Also used for LED feedback on same number.",
                'green.type': "Message type sent when button is pressed/released.",
                'green.mode': "Button behaviour. Momentary sends on press/release; Toggle latches on/off.",
                'green.led': "LED illumination mode. Controls when the green button lights up.",
                'green.lo': "Lower/release value (0-127). Sent on release (Momentary) or when toggled off.",
                'green.hi': "Upper/press value (0-127). Sent on press (Momentary) or when toggled on."
            },
            
            // Dropdown options - keyed by optionGroup.optionValue
            options: {
                // Encoder types
                'encoderType.CCr1': "Relative mode 1. Sends 1 for clockwise, 127 for counter-clockwise. Best for Ableton Live, Bitwig. Endless rotation.",
                'encoderType.CCr2': "Relative mode 2. Sends 65 for clockwise, 63 for counter-clockwise. Alternative relative format. Endless rotation.",
                'encoderType.CCAb': "Absolute 7-bit CC. Standard MIDI CC (0-127). Value jumps to match encoder position. Factory default.",
                'encoderType.PrGC': "Program Change. Sends MIDI program change (0-127 internally, some instruments display 1-128). Turn to increment/decrement.",
                'encoderType.CCAh': "Absolute 14-bit high-resolution CC. Uses CC N (MSB) and CC N+32 (LSB) for 16384 steps. CC must be 0-31. Best for sensitive parameters.",
                'encoderType.Pbnd': "Pitch Bend. Sends 14-bit Pitch Bend message on the selected MIDI channel (-8192 to +8191). No CC number needed.",
                'encoderType.AFtt': "Aftertouch (Channel Pressure). Sends channel pressure (0-127). Use for expression control.",
                
                // Fader types
                'faderType.CCAb': "Absolute 7-bit CC. Standard MIDI CC (0-127). Factory default. Most common choice.",
                'faderType.PrGC': "Program Change. Sends MIDI program change (0-127). Fader position selects program.",
                'faderType.Pbnd': "Pitch Bend. Sends 14-bit Pitch Bend message on the selected MIDI channel. Full range mapped to fader travel. No CC number needed.",
                'faderType.AFtt': "Aftertouch (Channel Pressure). Sends channel pressure. Fader controls expression amount.",
                
                // Acceleration (shared global group)
                'acc.0': "No acceleration. 1:1 response regardless of turn speed. Most precise, slowest to traverse full range.",
                'acc.1': "Low acceleration. Slight speed boost for faster turns. Good balance of precision and speed.",
                'acc.2': "Medium acceleration. Moderate speed boost. Faster traversal with some precision trade-off.",
                'acc.3': "Maximum acceleration. Fastest response to quick turns. Best for quickly sweeping values. Factory default.",
                
                // Display modes (shared global group)
                'display.OFF': "Display disabled. 7-segment shows nothing when this control is active.",
                'display.Std': "Standard display. Shows current value 0-127 on the 7-segment. Factory default.",
                'display.bPoL': "Bipolar display. Shows value as Â±63, centered at 64. Good for pan or bipolar parameters.",
                
                // Fader modes (shared by faders 1-8 and fader 9)
                'faderMode.Jump': "Immediate response. Sends current position when moved. May cause value jumps.",
                'faderMode.Snap': "Pickup mode. Only sends after position catches current value. Prevents jumps.",
                
                // Button types (shared by push and green buttons)
                'buttonType.OFF': "Button disabled. No MIDI message sent when pressed.",
                'buttonType.Note': "Note On/Off. Sends Note On (Hi velocity) on press, Note Off (Lo) on release. Factory default. Best for triggering clips/samples in DAWs.",
                'buttonType.CC': "Control Change. Sends CC with Hi value on press, Lo on release. Good for momentary effects.",
                'buttonType.PrGC': "Program Change. Sends program change (0-127) on press. Lo value typically ignored.",
                'buttonType.AFtt': "Aftertouch. Sends channel pressure Hi on press, Lo on release.",
                
                // Button modes (shared by push and green buttons)
                'buttonMode.Momentary': "Gate mode. Hi on press, Lo on release. Active only while held.",
                'buttonMode.Toggle': "Latch mode. First press sends Hi, next press sends Lo. Alternates each press.",
                
                // Green LED modes
                'greenLed.OFF': "LED always off. Button never illuminates.",
                'greenLed.Std': "Standard. LED reflects button state AND responds to incoming MIDI feedback. Factory default.",
                'greenLed.EXt': "External only. LED controlled only by incoming MIDI. Button presses don't change LED. Best for DAW sync."
            }
        };
        
        // Option group to panel title mapping
        const OPTION_GROUP_TITLES = {
            'encoderType': 'Encoder Type Options',
            'faderType': 'Fader Type Options',
            'acc': 'Acceleration Options',
            'display': 'Display Options',
            'faderMode': 'Fader Mode Options',
            'buttonType': 'Button Type Options',
            'buttonMode': 'Button Mode Options',
            'greenLed': 'LED Options'
        };
        
        // ============================================================
        // SysEx Parsing
        // ============================================================
        
        function decodeValue(buf, offset, idx) {
            const pos = offset + idx * 3;
            if (pos + 2 >= buf.length || buf[pos] !== 0x4D) return null;
            return ((buf[pos + 1] & 0x0F) << 4) | (buf[pos + 2] & 0x0F);
        }
        
        function encodeValue(buf, offset, idx, value) {
            const pos = offset + idx * 3;
            buf[pos] = 0x4D;
            buf[pos + 1] = 0x20 | ((value >> 4) & 0x0F);
            buf[pos + 2] = 0x10 | (value & 0x0F);
        }
        
        function buildIndex(buf) {
            // FIXED: Build flat index - each (secId, bank) appears once
            // Setup addressing is computed in getValue/setValue
            const index = {};
            
            for (let i = 0; i < buf.length - 10; i++) {
                if (buf[i] === 0x49 && (i === 0 || buf[i-1] !== 0x4D) && buf[i+3] === 0x4A) {
                    const secId = ((buf[i+1] & 0x0F) << 4) | (buf[i+2] & 0x0F);
                    const bank = ((buf[i+4] & 0x0F) << 4) | (buf[i+5] & 0x0F);
                    const dataOffset = i + 6;
                    
                    let pos = dataOffset;
                    while (pos < buf.length && buf[pos] === 0x4D) pos += 3;
                    const valueCount = (pos - dataOffset) / 3;
                    const checksumOffset = pos;
                    
                    if (!index[secId]) index[secId] = {};
                    index[secId][bank] = { dataOffset, valueCount, checksumOffset };
                }
            }
            
            return index;
        }
        
        // Compute actual section and bank for a given setupIdx
        // Different control types use different addressing schemes
        function computeActualLocation(setupIdx, secId, bank, valueIdx) {
            let actualSecId, actualBank, actualValueIdx;
            
            if (secId === 0x17) {
                // Fader9: 4 setups per section, bank encodes setup within section
                actualSecId = 0x17 + Math.floor(setupIdx / 4);
                actualBank = (setupIdx % 4) * 0x40;
                actualValueIdx = valueIdx;
            } else if (secId === 0x14 && bank === 0x80) {
                // Group Names: Complex storage pattern (empirically verified via hardware diff)
                // Section 0x14 (banks 0x80/0xC0 only): Setups 0-3 (2 per bank)
                // Section 0x15+ (all 4 banks): 8 setups per section (2 per bank)
                
                if (setupIdx < 4) {
                    // Setups 0-3: Section 0x14, banks 0x80/0xC0
                    actualSecId = 0x14;
                    const bankIdx = Math.floor(setupIdx / 2);  // 0 or 1
                    actualBank = 0x80 + bankIdx * 0x40;  // 0x80 or 0xC0
                    const valueOffset = (setupIdx % 2) * 32;
                    actualValueIdx = valueIdx + valueOffset;
                } else {
                    // Setups 4+: Section 0x15+, using all 4 banks (0x00, 0x40, 0x80, 0xC0)
                    const localSetup = setupIdx - 4;
                    actualSecId = 0x15 + Math.floor(localSetup / 8);
                    const localInSection = localSetup % 8;
                    const bankIdx = Math.floor(localInSection / 2);  // 0, 1, 2, or 3
                    actualBank = bankIdx * 0x40;  // 0x00, 0x40, 0x80, or 0xC0
                    const valueOffset = (localInSection % 2) * 32;
                    actualValueIdx = valueIdx + valueOffset;
                }
            } else {
                // All others (Encoder, Push, Green, Fader): stride-of-5 pattern
                actualSecId = secId + (setupIdx * 5);
                actualBank = bank;
                actualValueIdx = valueIdx;
            }
            
            return { actualSecId, actualBank, actualValueIdx };
        }
        
        function recalcBankChecksum(buf, dataStart) {
            let sum = 0;
            let pos = dataStart;
            
            while (pos < buf.length && buf[pos] === 0x4D) {
                sum += ((buf[pos + 1] & 0x0F) << 4) | (buf[pos + 2] & 0x0F);
                pos += 3;
            }
            
            sum = sum & 0xFFFF;
            
            if (pos + 5 < buf.length && buf[pos] === 0x4B && buf[pos + 3] === 0x4C) {
                buf[pos + 1] = 0x20 | ((sum >> 12) & 0x0F);
                buf[pos + 2] = 0x10 | ((sum >> 8) & 0x0F);
                buf[pos + 4] = 0x20 | ((sum >> 4) & 0x0F);
                buf[pos + 5] = 0x10 | (sum & 0x0F);
            }
        }
        
        function getValue(setupIdx, secId, bank, valueIdx) {
            if (!sectionIndex) return null;
            
            const loc = computeActualLocation(setupIdx, secId, bank, valueIdx);
            
            const sec = sectionIndex[loc.actualSecId];
            if (!sec) return null;
            const bnk = sec[loc.actualBank];
            if (!bnk) return null;
            return decodeValue(rawBuffer, bnk.dataOffset, loc.actualValueIdx);
        }
        
        function setValue(setupIdx, secId, bank, valueIdx, value) {
            if (!sectionIndex) return;
            
            const loc = computeActualLocation(setupIdx, secId, bank, valueIdx);
            const sec = sectionIndex[loc.actualSecId];
            if (!sec) return;
            const bnk = sec[loc.actualBank];
            if (!bnk) return;
            
            encodeValue(rawBuffer, bnk.dataOffset, loc.actualValueIdx, value);
            dirtyBanks.add(`${setupIdx}-${loc.actualSecId}-${loc.actualBank}`);
            if (!suppressModified) markModified();
        }
        
        // ============================================================
        // Control Value Helpers
        // ============================================================
        
        function getEncoderData(setupIdx, group, enc) {
            const idx = group * 8 + enc;
            const chanType = getValue(setupIdx, 0x1C, 0x00, idx) || 0x20;
            const accDisp = getValue(setupIdx, 0x1D, 0x00, idx) || 0x31;
            
            return {
                channel: (chanType & 0x0F) + 1,
                type: (chanType >> 4) & 0x0F,
                cc: getValue(setupIdx, 0x1C, 0x40, idx) || 0,
                min: getValue(setupIdx, 0x1C, 0x80, idx) || 0,
                max: getValue(setupIdx, 0x1C, 0xC0, idx) || 127,
                acc: (accDisp >> 4) & 0x0F,
                display: accDisp & 0x0F
            };
        }
        
        function setEncoderData(setupIdx, group, enc, data) {
            const idx = group * 8 + enc;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            const accDisp = ((data.acc & 0x0F) << 4) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1C, 0x00, idx, chanType);
            setValue(setupIdx, 0x1C, 0x40, idx, data.cc);
            setValue(setupIdx, 0x1C, 0x80, idx, data.min);
            setValue(setupIdx, 0x1C, 0xC0, idx, data.max);
            setValue(setupIdx, 0x1D, 0x00, idx, accDisp);
        }
        
        function getPushData(setupIdx, group, btn) {
            const idx = group * 8 + btn;
            const chanType = getValue(setupIdx, 0x1D, 0x40, idx) || 0x10;
            const modeDisp = getValue(setupIdx, 0x1E, 0x40, idx) || 0x00;
            
            return {
                channel: (chanType & 0x0F) + 1,
                typeNibble: chanType & 0xF0,
                cc: getValue(setupIdx, 0x1D, 0x80, idx) || 0,
                lower: getValue(setupIdx, 0x1D, 0xC0, idx) || 0,
                upper: getValue(setupIdx, 0x1E, 0x00, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setPushData(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = (data.typeNibble & 0xF0) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1D, 0x40, idx, chanType);
            setValue(setupIdx, 0x1D, 0x80, idx, data.cc);
            setValue(setupIdx, 0x1D, 0xC0, idx, data.lower);
            setValue(setupIdx, 0x1E, 0x00, idx, data.upper);
            setValue(setupIdx, 0x1E, 0x40, idx, modeDisp);
        }
        
        function getGreenData(setupIdx, group, btn) {
            const idx = group * 8 + btn;
            const chanType = getValue(setupIdx, 0x1E, 0x80, idx) || 0x10;
            const modeDisp = getValue(setupIdx, 0x1F, 0x80, idx) || 0x01;
            
            return {
                channel: (chanType & 0x0F) + 1,
                typeNibble: chanType & 0xF0,
                cc: getValue(setupIdx, 0x1E, 0xC0, idx) || 64,
                lower: getValue(setupIdx, 0x1F, 0x00, idx) || 0,
                upper: getValue(setupIdx, 0x1F, 0x40, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setGreenData(setupIdx, group, btn, data) {
            const idx = group * 8 + btn;
            const chanType = (data.typeNibble & 0xF0) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1E, 0x80, idx, chanType);
            setValue(setupIdx, 0x1E, 0xC0, idx, data.cc);
            setValue(setupIdx, 0x1F, 0x00, idx, data.lower);
            setValue(setupIdx, 0x1F, 0x40, idx, data.upper);
            setValue(setupIdx, 0x1F, 0x80, idx, modeDisp);
        }
        
        function getFaderData(setupIdx, group, fader) {
            const idx = group * 8 + fader;
            const chanType = getValue(setupIdx, 0x1F, 0xC0, idx) || 0x00;
            const modeDisp = getValue(setupIdx, 0x20, 0xC0, idx) || 0x01;
            
            return {
                channel: (chanType & 0x0F) + 1,
                type: (chanType >> 4) & 0x0F,
                cc: getValue(setupIdx, 0x20, 0x00, idx) || 32,
                min: getValue(setupIdx, 0x20, 0x40, idx) || 0,
                max: getValue(setupIdx, 0x20, 0x80, idx) || 127,
                mode: (modeDisp & 0x10) ? 1 : 0,
                display: modeDisp & 0x0F
            };
        }
        
        function setFaderData(setupIdx, group, fader, data) {
            const idx = group * 8 + fader;
            const chanType = ((data.type & 0x0F) << 4) | ((data.channel - 1) & 0x0F);
            const modeDisp = (data.mode ? 0x10 : 0x00) | (data.display & 0x0F);
            
            setValue(setupIdx, 0x1F, 0xC0, idx, chanType);
            setValue(setupIdx, 0x20, 0x00, idx, data.cc);
            setValue(setupIdx, 0x20, 0x40, idx, data.min);
            setValue(setupIdx, 0x20, 0x80, idx, data.max);
            setValue(setupIdx, 0x20, 0xC0, idx, modeDisp);
        }
        
        function getFader9Data(setupIdx, group) {
            // Fader 9: 5 values per group in section 0x17 bank 0x00
            const baseIdx = group * 5;
            const modeVal = getValue(setupIdx, 0x17, 0x00, baseIdx + 4) || 1;
            
            return {
                channel: (getValue(setupIdx, 0x17, 0x00, baseIdx) || 0) + 1,
                cc: getValue(setupIdx, 0x17, 0x00, baseIdx + 1) || 112,
                min: getValue(setupIdx, 0x17, 0x00, baseIdx + 2) || 0,
                max: getValue(setupIdx, 0x17, 0x00, baseIdx + 3) || 127,
                mode: (modeVal & 0x10) ? 1 : 0
            };
        }
        
        function setFader9Data(setupIdx, group, data) {
            const baseIdx = group * 5;
            const modeVal = data.mode ? 0x11 : 0x01;
            
            setValue(setupIdx, 0x17, 0x00, baseIdx, (data.channel - 1) & 0x0F);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 1, data.cc);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 2, data.min);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 3, data.max);
            setValue(setupIdx, 0x17, 0x00, baseIdx + 4, modeVal);
        }
        
        // ============================================================
        // Group Name Functions (per UC4_GROUP_NAME_EDITING_SPEC_v2)
        // ============================================================
        
        // Returns raw values + decoded string + warning flag
        function getGroupNameData(setupIdx, group) {
            // Group names are stored PER-SETUP in section 0x14 bank 0x80
            const baseIdx = group * 4;
            const values = [];
            const chars = [];
            let hasNonCanonical = false;
            
            // Debug: log computed addresses for problematic setups
            if (DEBUG_GROUPNAMES && setupIdx >= 8) {
                const loc = computeActualLocation(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, baseIdx);
                console.log(`[DEBUG] Setup ${setupIdx + 1}, Group ${group + 1}: logical=(0x14, 0x80, ${baseIdx}) â†’ physical=(0x${loc.actualSecId.toString(16)}, 0x${loc.actualBank.toString(16)}, ${loc.actualValueIdx})`);
            }
            
            for (let i = 0; i < 4; i++) {
                const val = getValue(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, baseIdx + i);
                
                if (val === null) {
                    // Read failed - return null to indicate failure
                    if (DEBUG_GROUPNAMES && setupIdx >= 8) {
                        console.log(`[DEBUG] Setup ${setupIdx + 1}, Group ${group + 1}, char ${i}: READ FAILED (null)`);
                    }
                    return null;
                }
                
                values.push(val);
                
                const decoded = decodeGroupNameByte(val);
                chars.push(decoded.glyph);
                if (!decoded.canonical) {
                    hasNonCanonical = true;
                }
            }
            
            // Debug: log raw values for problematic setups
            if (DEBUG_GROUPNAMES && setupIdx >= 8) {
                console.log(`[DEBUG] Setup ${setupIdx + 1}, Group ${group + 1}: raw bytes=[${values.join(', ')}] (0x${values.map(v => v.toString(16).padStart(2, '0')).join(', 0x')}) â†’ "${chars.join('')}"`);
            }
            
            return {
                values: values,           // Raw bytes [v0, v1, v2, v3]
                display: chars.join(''),  // Decoded string for display
                hasNonCanonical: hasNonCanonical  // True if any bytes outside 0-31 range
            };
        }
        
        // Convenience wrapper for display-only contexts
        function getGroupName(setupIdx, group) {
            const data = getGroupNameData(setupIdx, group);
            if (data === null) {
                return `GrP${group + 1}`;  // Only fallback on complete read failure
            }
            return data.display;
        }
        
        // Debug function - call from console: debugGroupNames(setupIdx)
        function debugGroupNames(setupIdx) {
            console.log(`=== Group Names for Setup ${setupIdx + 1} ===`);
            for (let g = 0; g < 8; g++) {
                const data = getGroupNameData(setupIdx, g);
                if (data === null) {
                    console.log(`  Group ${g + 1}: READ FAILED`);
                } else {
                    console.log(`  Group ${g + 1}: values=[${data.values.join(', ')}] display="${data.display}" nonCanonical=${data.hasNonCanonical}`);
                }
            }
            // Also show the computed location for first group
            const loc = computeActualLocation(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, 0);
            console.log(`  Location: section=0x${loc.actualSecId.toString(16)}, bank=0x${loc.actualBank.toString(16)}, valueIdx=${loc.actualValueIdx}`);
        }
        
        // Debug function - call from console: debugEncoderAddressing()
        // Verifies that each setup reads from different sections
        function debugEncoderAddressing() {
            console.log('=== Encoder Address Mapping (first 6 setups) ===');
            console.log('Encoder data uses stride-of-5: Setup N reads from section (0x1C + N*5)');
            for (let s = 0; s < 6; s++) {
                const loc = computeActualLocation(s, 0x1C, 0x00, 0);
                const exists = sectionIndex && sectionIndex[loc.actualSecId] && sectionIndex[loc.actualSecId][loc.actualBank];
                const enc0 = getValue(s, 0x1C, 0x00, 0);
                console.log(`  Setup ${s+1}: actualSecId=0x${loc.actualSecId.toString(16)} ${exists ? 'âœ“' : 'âœ—'} enc[0,0] chanType=0x${(enc0 || 0).toString(16)}`);
            }
        }
        
        // Debug function - call from console: debugSectionIndex()
        // Shows all sections/banks present in the loaded SysEx
        function debugSectionIndex() {
            if (!sectionIndex) {
                console.log('No SysEx loaded');
                return;
            }
            console.log('=== Section Index (what exists in SysEx) ===');
            const sections = Object.keys(sectionIndex).map(s => parseInt(s)).sort((a,b) => a-b);
            for (const secId of sections) {
                const banks = Object.keys(sectionIndex[secId]).map(b => parseInt(b)).sort((a,b) => a-b);
                for (const bank of banks) {
                    const info = sectionIndex[secId][bank];
                    console.log(`  Section 0x${secId.toString(16).padStart(2,'0')} Bank 0x${bank.toString(16).padStart(2,'0')}: offset=${info.dataOffset}, values=${info.valueCount}`);
                }
            }
            console.log('');
            console.log('=== Group Name Address Mapping (all 18 setups) ===');
            for (let s = 0; s < 18; s++) {
                const loc = computeActualLocation(s, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, 0);
                const exists = sectionIndex[loc.actualSecId] && sectionIndex[loc.actualSecId][loc.actualBank];
                console.log(`  Setup ${(s+1).toString().padStart(2)}: logical=(0x14, 0x80) â†’ physical=(0x${loc.actualSecId.toString(16)}, 0x${loc.actualBank.toString(16)}) ${exists ? 'âœ“ EXISTS' : 'âœ— MISSING'}`);
            }
        }
        
        // Debug function - call from console: debugAllGroupNames()
        // Shows all group names for all setups
        function debugAllGroupNames() {
            console.log('=== All Group Names (all 18 setups) ===');
            for (let s = 0; s < 18; s++) {
                const names = [];
                for (let g = 0; g < 8; g++) {
                    const data = getGroupNameData(s, g);
                    names.push(data ? `"${data.display}"` : 'NULL');
                }
                console.log(`  Setup ${(s+1).toString().padStart(2)}: ${names.join(', ')}`);
            }
        }
        
        // Write 4 byte values to group name
        function setGroupName(setupIdx, group, values) {
            // values must be array of exactly 4 byte values
            if (!Array.isArray(values) || values.length !== 4) {
                console.error('Group name must be exactly 4 byte values');
                return false;
            }
            
            const baseIdx = group * 4;
            
            for (let i = 0; i < 4; i++) {
                const val = values[i];
                if (typeof val !== 'number' || val < 0 || val > 255) {
                    console.error(`Invalid byte value ${val} at position ${i}`);
                    return false;
                }
                setValue(setupIdx, SECTIONS.GROUP_NAMES, BANKS.GROUP_NAMES, baseIdx + i, val);
            }
            
            return true;
        }
        
        // Convert user input string to byte values
        function stringToGroupNameValues(input) {
            // Normalize and pad to 4 characters
            let normalized = '';
            for (const char of input.substring(0, 4)) {
                // Reject any character with codepoint > 127 (includes Unicode whitespace, NBSP, etc.)
                if (char.charCodeAt(0) > 127) {
                    return { error: `Invalid character: ${char} (non-ASCII)` };
                }
                const norm = normalizeInputChar(char);
                if (norm === null) {
                    return { error: `Invalid character: ${char}` };
                }
                normalized += norm;
            }
            
            // Pad with spaces
            while (normalized.length < 4) {
                normalized += ' ';
            }
            
            // Convert to values (Rule 5: Encoding Totality)
            const values = [];
            for (const glyph of normalized) {
                const val = encodeGlyph(glyph);
                if (val === null) {
                    // This should never happen if normalization is correct
                    return { error: `Internal error: glyph not encodable: ${glyph}` };
                }
                values.push(val);
            }
            
            return { values, display: normalized };
        }
        
        // Change group name with undo support (stores raw bytes)
        function changeGroupNameWithUndo(setupIdx, group, newValues) {
            const oldData = getGroupNameData(setupIdx, group);
            if (oldData === null) return false;
            
            const oldValues = oldData.values;
            
            // Check if actually changed (byte-based comparison)
            if (oldValues.every((v, i) => v === newValues[i])) {
                return false;
            }
            
            // Get display strings for description
            const oldDisplay = oldData.display;
            const newDisplay = newValues.map(v => decodeGroupNameByte(v).glyph).join('');
            
            // Record undo action with RAW BYTE VALUES (not strings)
            const action = {
                type: 'group-name',
                description: `Rename group ${group + 1}: "${oldDisplay}" â†’ "${newDisplay}"`,
                setupIdx,
                group,
                beforeValues: Array.from(oldValues),   // [v0, v1, v2, v3]
                afterValues: Array.from(newValues)    // [v0, v1, v2, v3]
            };
            
            recordUndo(action);
            setGroupName(setupIdx, group, newValues);
            markModified();
            
            return true;
        }
        
        // Render group name with warning badge for non-canonical bytes
        function renderGroupNameWithWarning(setupIdx, group) {
            const data = getGroupNameData(setupIdx, group);
            
            if (data === null) {
                return `<span class="group-name">GrP${group + 1}</span>`;
            }
            
            const displayText = data.display === '    ' ? '----' : escapeHtml(data.display);
            
            if (data.hasNonCanonical) {
                return `<span class="group-name has-warning" title="Contains non-standard codes; preserved unless overwritten">${displayText} âš </span>`;
            }
            
            return `<span class="group-name">${displayText}</span>`;
        }
        
        // HTML escape helper
        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
        
        // ============================================================
        // UI Rendering
        // ============================================================
        
        function initUI() {
            // Generate group tabs
            for (let i = 0; i < NUM_GROUPS; i++) {
                const encTab = document.createElement('button');
                encTab.className = 'group-tab' + (i === 0 ? ' active' : '');
                encTab.textContent = i + 1;
                encTab.onclick = () => selectEncoderGroup(i);
                document.getElementById('encoderGroupTabs').appendChild(encTab);
                
                const fadTab = document.createElement('button');
                fadTab.className = 'group-tab' + (i === 0 ? ' active' : '');
                fadTab.textContent = i + 1;
                fadTab.onclick = () => selectFaderGroup(i);
                document.getElementById('faderGroupTabs').appendChild(fadTab);
            }
            
            // Populate setup dropdown
            const setupSelect = document.getElementById('setupSelect');
            for (let i = 0; i < NUM_SETUPS; i++) {
                const opt = document.createElement('option');
                opt.value = i;
                if (i < 16) {
                    opt.textContent = `Setup ${i + 1}`;
                } else if (i === 16) {
                    opt.textContent = 'Setup 17 (Ableton 1-8)';
                } else {
                    opt.textContent = 'Setup 18 (Ableton 9-16)';
                }
                setupSelect.appendChild(opt);
            }
        }
        
        function renderFocusedView() {
            const main = document.getElementById('mainContent');
            main.innerHTML = '';
            
            // Get group names for display
            const encoderGroupName = getGroupName(currentSetup, encoderGroup);
            const faderGroupName = getGroupName(currentSetup, faderGroup);
            
            // Faders section (uses fader group)
            const faderSection = createSection('Faders', 'faders', faderGroupName, faderGroup);
            const faderGrid = document.createElement('div');
            faderGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                faderGrid.appendChild(createFaderCard(i));
            }
            faderSection.appendChild(faderGrid);
            main.appendChild(faderSection);
            
            // Fader 9 section (uses fader group)
            const fader9Section = createSection('Fader 9', 'fader9', faderGroupName, faderGroup);
            fader9Section.appendChild(createFader9Card());
            main.appendChild(fader9Section);
            
            // Green Buttons section (uses fader group)
            const greenSection = createSection('Green Buttons', 'green', faderGroupName, faderGroup);
            const greenGrid = document.createElement('div');
            greenGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                greenGrid.appendChild(createGreenCard(i));
            }
            greenSection.appendChild(greenGrid);
            main.appendChild(greenSection);
            
            // Encoders section (uses encoder group)
            const encSection = createSection('Encoders', 'encoders', encoderGroupName, encoderGroup);
            const encGrid = document.createElement('div');
            encGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                encGrid.appendChild(createEncoderCard(i));
            }
            encSection.appendChild(encGrid);
            main.appendChild(encSection);
            
            // Push Buttons section (uses encoder group - they're on the encoders)
            const pushSection = createSection('Push Buttons', 'push', encoderGroupName, encoderGroup);
            const pushGrid = document.createElement('div');
            pushGrid.className = 'control-grid';
            
            for (let i = 0; i < 8; i++) {
                pushGrid.appendChild(createPushCard(i));
            }
            pushSection.appendChild(pushGrid);
            main.appendChild(pushSection);
        }
        
        function createSection(title, className, badge, groupIdx) {
            const section = document.createElement('section');
            section.className = 'control-section';
            
            const header = document.createElement('div');
            header.className = 'section-header';
            
            const h2 = document.createElement('h2');
            h2.className = 'section-title ' + className;
            h2.textContent = title;
            header.appendChild(h2);
            
            const span = document.createElement('span');
            span.className = 'section-badge';
            span.textContent = badge;
            span.title = 'Click to edit group name';
            span.style.cursor = 'pointer';
            span.onclick = () => showGroupNameEditor(currentSetup, groupIdx);
            header.appendChild(span);
            
            section.appendChild(header);
            return section;
        }
        
        function createEncoderCard(idx) {
            const data = getEncoderData(currentSetup, encoderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card encoder';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Encoder ${idx + 1}</span>
                    <span class="control-index">E${encoderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.chan">Chan</span>
                    <div class="param-input">
                        <select data-param="channel" onchange="updateEncoder(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.cc">CC</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updateEncoder(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="encoderType">Type</span>
                    <div class="param-input">
                        <select data-option-group="encoderType" onchange="updateEncoder(${idx}, 'type', this.value)">
                            ${ENCODER_TYPES.map((t, i) => 
                                `<option value="${i}" ${data.type === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="acc">Acc</span>
                    <div class="param-input">
                        <select data-option-group="acc" onchange="updateEncoder(${idx}, 'acc', this.value)">
                            ${ACC_MODES.map((t, i) => 
                                `<option value="${i}" ${data.acc === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="display">Disp</span>
                    <div class="param-input">
                        <select data-option-group="display" onchange="updateEncoder(${idx}, 'display', this.value)">
                            ${DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.min">Min</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.min}"
                            onchange="updateEncoder(${idx}, 'min', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="encoder.max">Max</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.max}"
                            onchange="updateEncoder(${idx}, 'max', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createPushCard(idx) {
            const data = getPushData(currentSetup, encoderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card push';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Push ${idx + 1}</span>
                    <span class="control-index">P${encoderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.chan">Chan</span>
                    <div class="param-input">
                        <select onchange="updatePush(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.note">Note</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updatePush(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonType">Type</span>
                    <div class="param-input">
                        <select data-option-group="buttonType" onchange="updatePush(${idx}, 'typeNibble', this.value)">
                            ${BUTTON_TYPE_VALUES.map(v => 
                                `<option value="${v}" ${data.typeNibble === v ? 'selected' : ''}>${BUTTON_TYPES[v]}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonMode">Mode</span>
                    <div class="param-input">
                        <select data-option-group="buttonMode" onchange="updatePush(${idx}, 'mode', this.value)">
                            ${BUTTON_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.lo">Lo</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.lower}"
                            onchange="updatePush(${idx}, 'lower', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="push.hi">Hi</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.upper}"
                            onchange="updatePush(${idx}, 'upper', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createGreenCard(idx) {
            const data = getGreenData(currentSetup, faderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card green';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Button ${idx + 1}</span>
                    <span class="control-index">B${faderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.chan">Chan</span>
                    <div class="param-input">
                        <select onchange="updateGreen(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.note">Note</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updateGreen(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonType">Type</span>
                    <div class="param-input">
                        <select data-option-group="buttonType" onchange="updateGreen(${idx}, 'typeNibble', this.value)">
                            ${BUTTON_TYPE_VALUES.map(v => 
                                `<option value="${v}" ${data.typeNibble === v ? 'selected' : ''}>${BUTTON_TYPES[v]}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="buttonMode">Mode</span>
                    <div class="param-input">
                        <select data-option-group="buttonMode" onchange="updateGreen(${idx}, 'mode', this.value)">
                            ${BUTTON_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="greenLed">LED</span>
                    <div class="param-input">
                        <select data-option-group="greenLed" onchange="updateGreen(${idx}, 'display', this.value)">
                            ${GREEN_DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.lo">Lo</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.lower}"
                            onchange="updateGreen(${idx}, 'lower', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="green.hi">Hi</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.upper}"
                            onchange="updateGreen(${idx}, 'upper', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createFaderCard(idx) {
            const data = getFaderData(currentSetup, faderGroup, idx);
            const card = document.createElement('div');
            card.className = 'control-card fader';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Fader ${idx + 1}</span>
                    <span class="control-index">F${faderGroup + 1}.${idx + 1}</span>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.chan">Chan</span>
                    <div class="param-input">
                        <select onchange="updateFader(${idx}, 'channel', this.value)">
                            ${Array.from({length: 16}, (_, i) => 
                                `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.cc">CC</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.cc}"
                            onchange="updateFader(${idx}, 'cc', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="faderType">Type</span>
                    <div class="param-input">
                        <select data-option-group="faderType" onchange="updateFader(${idx}, 'type', this.value)">
                            ${FADER_TYPES.map((t, i) => 
                                `<option value="${i}" ${data.type === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="faderMode">Mode</span>
                    <div class="param-input">
                        <select data-option-group="faderMode" onchange="updateFader(${idx}, 'mode', this.value)">
                            ${FADER_MODES.map((t, i) => 
                                `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-options" data-info-group="display">Disp</span>
                    <div class="param-input">
                        <select data-option-group="display" onchange="updateFader(${idx}, 'display', this.value)">
                            ${DISPLAY_MODES.map((t, i) => 
                                `<option value="${i}" ${data.display === i ? 'selected' : ''}>${t}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.min">Min</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.min}"
                            onchange="updateFader(${idx}, 'min', this.value)">
                    </div>
                </div>
                <div class="param-row">
                    <span class="param-label has-tooltip" data-tooltip-key="fader.max">Max</span>
                    <div class="param-input">
                        <input type="number" min="0" max="127" value="${data.max}"
                            onchange="updateFader(${idx}, 'max', this.value)">
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function createFader9Card() {
            const data = getFader9Data(currentSetup, faderGroup);
            const card = document.createElement('div');
            card.className = 'fader9-card';
            
            card.innerHTML = `
                <div class="control-header">
                    <span class="control-name">Fader 9</span>
                    <span class="control-index">F${faderGroup + 1}.9</span>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.75rem;">
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.chan">Chan</span>
                        <div class="param-input">
                            <select onchange="updateFader9('channel', this.value)">
                                ${Array.from({length: 16}, (_, i) => 
                                    `<option value="${i + 1}" ${data.channel === i + 1 ? 'selected' : ''}>${i + 1}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.cc">CC</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.cc}"
                                onchange="updateFader9('cc', this.value)">
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-options" data-info-group="faderMode">Mode</span>
                        <div class="param-input">
                            <select data-option-group="faderMode" onchange="updateFader9('mode', this.value)">
                                ${FADER_MODES.map((t, i) => 
                                    `<option value="${i}" ${data.mode === i ? 'selected' : ''}>${t}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.min">Min</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.min}"
                                onchange="updateFader9('min', this.value)">
                        </div>
                    </div>
                    <div class="param-row">
                        <span class="param-label has-tooltip" data-tooltip-key="fader9.max">Max</span>
                        <div class="param-input">
                            <input type="number" min="0" max="127" value="${data.max}"
                                onchange="updateFader9('max', this.value)">
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }
        
        function renderOverview() {
            const main = document.getElementById('mainContent');
            main.innerHTML = '';
            
            const container = document.createElement('div');
            container.className = 'overview-container';
            
            // Quick Paste Toolbar (guarded for safety)
            if (typeof createQuickPasteToolbar === 'function') {
                container.appendChild(createQuickPasteToolbar());
            }
            
            // Tab bar
            const tabs = document.createElement('div');
            tabs.className = 'overview-tabs';
            tabs.innerHTML = `
                <button class="overview-tab ${overviewTab === 'all' ? 'active' : ''}" onclick="setOverviewTab('all')">All</button>
                <button class="overview-tab ${overviewTab === 'faders' ? 'active' : ''}" onclick="setOverviewTab('faders')">Faders</button>
                <button class="overview-tab ${overviewTab === 'green' ? 'active' : ''}" onclick="setOverviewTab('green')">Green Buttons</button>
                <button class="overview-tab ${overviewTab === 'encoders' ? 'active' : ''}" onclick="setOverviewTab('encoders')">Encoders</button>
                <button class="overview-tab ${overviewTab === 'push' ? 'active' : ''}" onclick="setOverviewTab('push')">Push Buttons</button>
            `;
            container.appendChild(tabs);
            
            // Conflict filter chips
            const filters = document.createElement('div');
            filters.className = 'conflict-filters';
            filters.innerHTML = `
                <span class="conflict-filters-label">Conflicts:</span>
                <div class="filter-chip ${showConcurrentConflicts ? 'active' : ''}" onclick="toggleConcurrentFilter()">
                    <span class="checkmark">${showConcurrentConflicts ? 'âœ“' : ''}</span>
                    Concurrent
                    <span class="count" id="concurrentCount">${conflicts.concurrent.size}</span>
                </div>
                <div class="filter-chip ${showMutuallyExclusiveConflicts ? 'active dim' : ''}" onclick="toggleMEFilter()">
                    <span class="checkmark">${showMutuallyExclusiveConflicts ? 'âœ“' : ''}</span>
                    Mutually-Exclusive
                    <span class="count" id="meCount">${conflicts.mutuallyExclusive.size}</span>
                </div>
            `;
            container.appendChild(filters);
            
            // Grid based on active tab
            const grid = document.createElement('div');
            grid.className = 'overview-grid';
            
            switch (overviewTab) {
                case 'all':
                    // Show all control types stacked: Faders 1-8, Fader 9, Green, Encoders, Push
                    grid.appendChild(createOverviewSection('Faders 1-8', createFaderOverviewTable(), 'faders'));
                    grid.appendChild(createOverviewSection('Fader 9', createFader9OverviewTable(), 'fader9'));
                    grid.appendChild(createOverviewSection('Green Buttons', createButtonOverviewTable('green', getGreenData, 'B'), 'green'));
                    grid.appendChild(createOverviewSection('Encoders', createEncoderOverviewTable(), 'encoders'));
                    grid.appendChild(createOverviewSection('Push Buttons', createButtonOverviewTable('push', getPushData, 'P'), 'push'));
                    break;
                case 'encoders':
                    grid.appendChild(createEncoderOverviewTable());
                    break;
                case 'push':
                    grid.appendChild(createButtonOverviewTable('push', getPushData, 'P'));
                    break;
                case 'green':
                    grid.appendChild(createButtonOverviewTable('green', getGreenData, 'B'));
                    break;
                case 'faders':
                    grid.appendChild(createOverviewSection('Faders 1-8', createFaderOverviewTable(), 'faders'));
                    grid.appendChild(createOverviewSection('Fader 9', createFader9OverviewTable(), 'fader9'));
                    break;
            }
            
            container.appendChild(grid);
            
            // Conflict panel (show only if there are conflicts to display)
            const visibleConflicts = [];
            if (showConcurrentConflicts) {
                for (const [key, entry] of conflicts.concurrent) {
                    visibleConflicts.push({ key, entry, type: 'concurrent' });
                }
            }
            if (showMutuallyExclusiveConflicts) {
                for (const [key, entry] of conflicts.mutuallyExclusive) {
                    visibleConflicts.push({ key, entry, type: 'me' });
                }
            }
            
            if (visibleConflicts.length > 0) {
                const panel = document.createElement('div');
                panel.className = 'conflict-panel';
                panel.innerHTML = `
                    <div class="conflict-panel-header">
                        <span>âš  ${visibleConflicts.length} Conflict${visibleConflicts.length !== 1 ? 's' : ''}</span>
                    </div>
                `;
                
                for (const { key, entry, type } of visibleConflicts.slice(0, 20)) {
                    const item = document.createElement('div');
                    item.className = `conflict-item ${type === 'me' ? 'dim' : ''}`;
                    const refsStr = entry.refs.map(formatControlRef).join(', ');
                    item.innerHTML = `
                        <span class="warning-icon">âš  </span>
                        <span class="conflict-key">${formatConflictKey(key)}:</span>
                        <span class="conflict-refs">${refsStr}</span>
                    `;
                    panel.appendChild(item);
                }
                
                if (visibleConflicts.length > 20) {
                    const more = document.createElement('div');
                    more.className = 'conflict-item';
                    more.innerHTML = `<span class="conflict-refs">...and ${visibleConflicts.length - 20} more</span>`;
                    panel.appendChild(more);
                }
                
                container.appendChild(panel);
            }
            
            main.appendChild(container);
            
            // Update cursor classes on all tables (guarded for safety)
            if (typeof updateOverviewTableCursor === 'function') {
                updateOverviewTableCursor();
            }
        }
        
        // Overview state
        let overviewTab = 'all';
        
        function setOverviewTab(tab) {
            overviewTab = tab;
            renderOverview();
        }
        
        // MIDI Channel Helpers
        function chDisp(ch0) { return (ch0 | 0) + 1; }
        
        function formatEncoderCell(data) {
            const typeMap = {
                0: 'r1', 1: 'r2', 2: 'CC', 3: 'PC', 4: 'Hi', 5: 'PB', 6: 'AT'
            };
            const type = typeMap[data.type] || '??';
            const ch = chDisp(data.channel - 1);  // data.channel is already 1-based
            
            // Program Change: show range
            if (data.type === 3) {
                const lo = Math.min(data.min, data.max);
                const hi = Math.max(data.min, data.max);
                return `${ch}:PC ${lo}-${hi}`;
            }
            
            // Pitch bend and aftertouch have no CC number
            if (data.type === 5 || data.type === 6) {
                return `${ch}:${type}`;
            }
            
            return `${ch}:${type} ${data.cc}`;
        }
        
        function formatFaderCell(data) {
            const typeMap = { 0: 'CC', 1: 'PC', 2: 'PB', 3: 'AT' };
            const type = typeMap[data.type] || '??';
            const ch = chDisp(data.channel - 1);
            
            // Program Change: show range
            if (data.type === 1) {
                const lo = Math.min(data.min, data.max);
                const hi = Math.max(data.min, data.max);
                return `${ch}:PC ${lo}-${hi}`;
            }
            
            // Pitch bend and aftertouch have no CC number
            if (data.type === 2 || data.type === 3) {
                return `${ch}:${type}`;
            }
            
            return `${ch}:${type} ${data.cc}`;
        }
        
        function formatButtonCell(data) {
            if (data.typeNibble === 0x00) return '--';
            
            const typeMap = { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' };
            const type = typeMap[data.typeNibble] || '??';
            const ch = chDisp(data.channel - 1);
            const mode = data.mode ? 'T' : 'M';
            
            if (data.typeNibble === 0x40) {
                return `${ch}:${type} [${mode}]`;
            }
            
            return `${ch}:${type} ${data.cc} [${mode}]`;
        }
        
        function createOverviewSection(title, table, colorClass = '') {
            const section = document.createElement('div');
            section.className = 'overview-section';
            
            const header = document.createElement('h3');
            header.className = 'overview-section-title' + (colorClass ? ' ' + colorClass : '');
            header.textContent = title;
            section.appendChild(header);
            
            section.appendChild(table);
            return section;
        }
        
        function createEncoderOverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row (clickable to edit)
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<td onclick="showGroupNameEditor(${currentSetup}, ${g})" title="Click to edit">${renderGroupNameWithWarning(currentSetup, g)}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Data rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">Enc ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getEncoderData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = 'encoder';
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType('encoder', g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === 'encoder' && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    // Check if this cell is QP source
                    if (isQuickPasteSource('encoder', g, i)) {
                        cell.classList.add('qp-source');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatEncoderCell(data)}</div>`;
                    cell.onclick = () => { 
                        if (!handleQuickPasteCellClick('encoder', g, i)) {
                            setSelection('encoder', g, i); 
                        }
                    };
                    cell.ondblclick = () => {
                        if (!handleQuickPasteDoubleClick('encoder', g, i)) {
                            jumpToFocusedView('encoder', g, i);
                        }
                    };
                    cell.onmouseenter = () => handleOverviewMouseEnter('encoder', g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, 'encoder', g, i);
                    cell.title = createEncoderTooltip(data, g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        function createButtonOverviewTable(type, getData, prefix) {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row (clickable to edit)
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<td onclick="showGroupNameEditor(${currentSetup}, ${g})" title="Click to edit">${renderGroupNameWithWarning(currentSetup, g)}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Data rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">${prefix} ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = type;
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType(type, g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === type && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    // Check if this cell is QP source
                    if (isQuickPasteSource(type, g, i)) {
                        cell.classList.add('qp-source');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatButtonCell(data)}</div>`;
                    cell.onclick = () => { 
                        if (!handleQuickPasteCellClick(type, g, i)) {
                            setSelection(type, g, i); 
                        }
                    };
                    cell.ondblclick = () => {
                        if (!handleQuickPasteDoubleClick(type, g, i)) {
                            jumpToFocusedView(type, g, i);
                        }
                    };
                    cell.onmouseenter = () => handleOverviewMouseEnter(type, g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, type, g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        function createFaderOverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            let headerHtml = '<tr><th class="row-header"></th>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<th class="group-header">Group ${g + 1}</th>`;
            }
            headerHtml += '</tr>';
            
            // Group name row (clickable to edit)
            headerHtml += '<tr class="group-name-row"><td></td>';
            for (let g = 0; g < 8; g++) {
                headerHtml += `<td onclick="showGroupNameEditor(${currentSetup}, ${g})" title="Click to edit">${renderGroupNameWithWarning(currentSetup, g)}</td>`;
            }
            headerHtml += '</tr>';
            
            table.innerHTML = headerHtml;
            
            // Fader 1-8 rows
            for (let i = 0; i < 8; i++) {
                const row = document.createElement('tr');
                row.innerHTML = `<th class="row-header">Fad ${i + 1}</th>`;
                
                for (let g = 0; g < 8; g++) {
                    const data = getFaderData(currentSetup, g, i);
                    const cell = document.createElement('td');
                    
                    // Add data attributes for keyboard navigation
                    cell.dataset.type = 'fader';
                    cell.dataset.group = g;
                    cell.dataset.index = i;
                    
                    // Check for conflicts
                    const conflictType = getControlConflictType('fader', g, i);
                    if (conflictType === 'concurrent') {
                        cell.className = 'conflict';
                    } else if (conflictType === 'mutuallyExclusive') {
                        cell.className = 'conflict-dim';
                    }
                    
                    // Check if this cell is selected
                    if (selection.mode !== 'none' && 
                        selection.controlType === 'fader' && 
                        selection.group === g && 
                        selection.index === i) {
                        cell.classList.add('selected');
                    }
                    
                    // Check if this cell is QP source
                    if (isQuickPasteSource('fader', g, i)) {
                        cell.classList.add('qp-source');
                    }
                    
                    const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                    cell.innerHTML = `<div class="overview-cell">${warningIcon}${formatFaderCell(data)}</div>`;
                    cell.onclick = () => { 
                        if (!handleQuickPasteCellClick('fader', g, i)) {
                            setSelection('fader', g, i); 
                        }
                    };
                    cell.ondblclick = () => {
                        if (!handleQuickPasteDoubleClick('fader', g, i)) {
                            jumpToFocusedView('fader', g, i);
                        }
                    };
                    cell.onmouseenter = () => handleOverviewMouseEnter('fader', g, i);
                    cell.oncontextmenu = (e) => showContextMenu(e, 'fader', g, i);
                    row.appendChild(cell);
                }
                
                table.appendChild(row);
            }
            
            return table;
        }
        
        // Fader 9 separate table
        function createFader9OverviewTable() {
            const table = document.createElement('table');
            table.className = 'overview-table';
            
            // Header row
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th></th>';
            for (let g = 0; g < 8; g++) {
                const name = getGroupName(currentSetup, g);
                headerRow.innerHTML += `<th class="group-header">Group ${g + 1}<br><span class="group-name">${name}</span></th>`;
            }
            table.appendChild(headerRow);
            
            // Fader 9 row
            const f9row = document.createElement('tr');
            f9row.innerHTML = `<th class="row-header">Fad 9</th>`;
            
            for (let g = 0; g < 8; g++) {
                const data = getFader9Data(currentSetup, g);
                const cell = document.createElement('td');
                
                // Add data attributes for keyboard navigation
                cell.dataset.type = 'fader9';
                cell.dataset.group = g;
                cell.dataset.index = 0;
                
                // Check for conflicts
                const conflictType = getControlConflictType('fader9', g, 0);
                if (conflictType === 'concurrent') {
                    cell.className = 'conflict';
                } else if (conflictType === 'mutuallyExclusive') {
                    cell.className = 'conflict-dim';
                }
                
                // Check if this cell is selected
                if (selection.mode !== 'none' && 
                    selection.controlType === 'fader9' && 
                    selection.group === g) {
                    cell.classList.add('selected');
                }
                
                // Check if this cell is QP source
                if (isQuickPasteSource('fader9', g, 0)) {
                    cell.classList.add('qp-source');
                }
                
                // Fader 9 only has CC type
                const ch = chDisp(data.channel - 1);
                const warningIcon = conflictType ? '<span class="conflict-icon">âš  </span>' : '';
                cell.innerHTML = `<div class="overview-cell">${warningIcon}${ch}:CC ${data.cc}</div>`;
                cell.onclick = () => { 
                    if (!handleQuickPasteCellClick('fader9', g, 0)) {
                        setSelection('fader9', g, 0); 
                    }
                };
                cell.ondblclick = () => {
                    if (!handleQuickPasteDoubleClick('fader9', g, 0)) {
                        jumpToFocusedView('fader9', g, 0);
                    }
                };
                cell.onmouseenter = () => handleOverviewMouseEnter('fader9', g, 0);
                cell.oncontextmenu = (e) => showContextMenu(e, 'fader9', g, 0);
                f9row.appendChild(cell);
            }
            
            table.appendChild(f9row);
            
            return table;
        }
        
        function createEncoderTooltip(data, group, index) {
            const types = ['CCr1', 'CCr2', 'CCAb', 'PrGC', 'CCAh', 'Pbnd', 'AFtt'];
            const accs = ['Acc0', 'Acc1', 'Acc2', 'Acc3'];
            const disps = ['OFF', 'Std', 'bPoL'];
            
            return `Encoder ${index + 1}, Group ${group + 1}
Channel: ${data.channel}
Type: ${types[data.type] || '?'}
CC#: ${data.cc}
Min: ${data.min}, Max: ${data.max}
Acc: ${accs[data.acc] || '?'}, Display: ${disps[data.display] || '?'}`;
        }
        
        function jumpToFocusedView(type, group, index) {
            // Switch to the appropriate group
            if (type === 'encoder' || type === 'push') {
                selectEncoderGroup(group);
            } else {
                selectFaderGroup(group);
            }
            
            // Switch to focused view
            setView('focused');
            
            // Scroll to the control (after view renders)
            setTimeout(() => {
                const cards = document.querySelectorAll('.control-card');
                // Find the right card based on type and index
                // This is approximate - we'd need better selectors in production
            }, 100);
        }
        
        // ============================================================
        // Update Functions (with undo support)
        // ============================================================
        
        function updateEncoder(idx, param, value) {
            const data = getEncoderData(currentSetup, encoderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return; // No change
            
            data[param] = after;
            setEncoderData(currentSetup, encoderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'encoder',
                setupIdx: currentSetup,
                group: encoderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updatePush(idx, param, value) {
            const data = getPushData(currentSetup, encoderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setPushData(currentSetup, encoderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'push',
                setupIdx: currentSetup,
                group: encoderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateGreen(idx, param, value) {
            const data = getGreenData(currentSetup, faderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setGreenData(currentSetup, faderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'green',
                setupIdx: currentSetup,
                group: faderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateFader(idx, param, value) {
            const data = getFaderData(currentSetup, faderGroup, idx);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setFaderData(currentSetup, faderGroup, idx, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'fader',
                setupIdx: currentSetup,
                group: faderGroup,
                index: idx,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        function updateFader9(param, value) {
            const data = getFader9Data(currentSetup, faderGroup);
            const before = data[param];
            const after = parseInt(value, 10);
            
            if (before === after) return;
            
            data[param] = after;
            setFader9Data(currentSetup, faderGroup, data);
            
            recordUndoCoalesced({
                type: 'value',
                controlType: 'fader9',
                setupIdx: currentSetup,
                group: faderGroup,
                index: 0,
                param,
                before,
                after
            });
            
            if (CONFLICT_PARAMS.has(param)) {
                scheduleConflictRebuild();
            }
        }
        
        // ============================================================
        // Navigation
        // ============================================================
        
        function selectSetup(idx) {
            currentSetup = parseInt(idx);
            updateGroupNames();
            // Rebuild conflict map for new setup
            rebuildConflictMap();
            renderCurrentView();
        }
        
        function toggleLinkGroups(checked) {
            linkGroups = checked;
            // If linking and groups are different, sync fader to encoder
            if (linkGroups && encoderGroup !== faderGroup) {
                faderGroup = encoderGroup;
                updateGroupTabs('faderGroupTabs', faderGroup);
                document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, faderGroup);
                renderCurrentView();
            }
        }
        
        function selectEncoderGroup(idx, fromLink = false) {
            encoderGroup = idx;
            updateGroupTabs('encoderGroupTabs', idx);
            document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, idx);
            
            // If linked and not already called from fader, update fader too
            if (linkGroups && !fromLink) {
                faderGroup = idx;
                updateGroupTabs('faderGroupTabs', idx);
                document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, idx);
            }
            
            renderCurrentView();
        }
        
        function selectFaderGroup(idx, fromLink = false) {
            faderGroup = idx;
            updateGroupTabs('faderGroupTabs', idx);
            document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, idx);
            
            // If linked and not already called from encoder, update encoder too
            if (linkGroups && !fromLink) {
                encoderGroup = idx;
                updateGroupTabs('encoderGroupTabs', idx);
                document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, idx);
            }
            
            renderCurrentView();
        }
        
        function updateGroupTabs(containerId, activeIdx) {
            const tabs = document.getElementById(containerId).querySelectorAll('.group-tab');
            tabs.forEach((tab, i) => {
                tab.classList.toggle('active', i === activeIdx);
            });
        }
        
        function updateGroupNames() {
            document.getElementById('encoderGroupName').textContent = getGroupName(currentSetup, encoderGroup);
            document.getElementById('faderGroupName').textContent = getGroupName(currentSetup, faderGroup);
        }
        
        function setView(view) {
            currentView = view;
            document.getElementById('focusedViewBtn').classList.toggle('active', view === 'focused');
            document.getElementById('overviewBtn').classList.toggle('active', view === 'overview');
            
            // Clear selection when leaving overview
            if (view === 'focused') {
                clearSelection();
            }
            
            renderCurrentView();
        }
        
        function renderCurrentView() {
            if (!rawBuffer) return;
            if (currentView === 'focused') {
                renderFocusedView();
            } else {
                renderOverview();
            }
        }
        
        // ============================================================
        // File Operations
        // ============================================================
        
        document.getElementById('sysexInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const buffer = await file.arrayBuffer();
                rawBuffer = new Uint8Array(buffer);
                
                if (rawBuffer.length !== EXPECTED_SIZE) {
                    alert(`Invalid file size: ${rawBuffer.length} bytes. Expected ${EXPECTED_SIZE} bytes.`);
                    rawBuffer = null;
                    return;
                }
                
                // Validate SysEx framing
                if (rawBuffer[0] !== 0xF0 || rawBuffer[rawBuffer.length - 1] !== 0xF7) {
                    alert('Invalid SysEx file: Missing F0/F7 framing bytes.');
                    rawBuffer = null;
                    return;
                }
                
                sectionIndex = buildIndex(rawBuffer);
                
                // Store original for reset
                originalBuffer = new Uint8Array(rawBuffer);
                
                // Clear previous session - new import is clean slate
                clearSession();
                
                // Clear undo/redo stacks
                undoStack.length = 0;
                redoStack.length = 0;
                updateUndoRedoUI();
                
                // Enable UI
                document.getElementById('setupSelect').disabled = false;
                document.getElementById('setupSelect').value = '0';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('exportJsonBtn').disabled = false;
                
                currentSetup = 0;
                encoderGroup = 0;
                faderGroup = 0;
                isModified = false;
                dirtyBanks.clear();
                
                updateGroupTabs('encoderGroupTabs', 0);
                updateGroupTabs('faderGroupTabs', 0);
                updateGroupNames();
                updateStatus('loaded', `Loaded: ${file.name}`);
                document.getElementById('fileInfo').textContent = `${file.name} (${rawBuffer.length.toLocaleString()} bytes)`;
                
                // Build initial conflict map
                rebuildConflictMap();
                
                renderFocusedView();
            } catch (err) {
                alert('Error loading file: ' + err.message);
                console.error(err);
            }
            
            e.target.value = '';
        });
        
        function exportSysEx() {
            if (!rawBuffer) return;
            
            // Recalculate all dirty checksums
            // dirtyBanks contains "${setupIdx}-${actualSecId}-${actualBank}"
            for (const key of dirtyBanks) {
                const [, secId, bank] = key.split('-').map(Number);
                const sec = sectionIndex[secId];
                if (sec && sec[bank]) {
                    recalcBankChecksum(rawBuffer, sec[bank].dataOffset);
                }
            }
            dirtyBanks.clear();
            
            const blob = new Blob([rawBuffer], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'uc4_edited.syx';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Clear session - user saved their work
            clearSession();
            isModified = false;
            updateStatus('loaded', 'Exported successfully');
            showToast('SysEx exported', 'success');
        }
        
        function exportJSON() {
            if (!rawBuffer) return;
            
            const data = {
                format: 'uc4-editor',
                version: '1.0',
                exported: new Date().toISOString(),
                setups: []
            };
            
            for (let s = 0; s < NUM_SETUPS; s++) {
                const setup = {
                    index: s,
                    groups: []
                };
                
                for (let g = 0; g < NUM_GROUPS; g++) {
                    const group = {
                        index: g,
                        name: getGroupName(s, g),
                        encoders: [],
                        pushButtons: [],
                        greenButtons: [],
                        faders: [],
                        fader9: getFader9Data(s, g)
                    };
                    
                    for (let i = 0; i < 8; i++) {
                        group.encoders.push(getEncoderData(s, g, i));
                        group.pushButtons.push(getPushData(s, g, i));
                        group.greenButtons.push(getGreenData(s, g, i));
                        group.faders.push(getFaderData(s, g, i));
                    }
                    
                    setup.groups.push(group);
                }
                
                data.setups.push(setup);
            }
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'uc4_config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        document.getElementById('jsonInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!rawBuffer) {
                alert('Please import a SysEx file first to use as a base.');
                e.target.value = '';
                return;
            }
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (data.format !== 'uc4-editor') {
                    alert('Invalid JSON format. Expected UC4 Editor export.');
                    return;
                }
                
                // Apply JSON data to buffer
                for (const setup of data.setups) {
                    for (const group of setup.groups) {
                        for (let i = 0; i < 8; i++) {
                            if (group.encoders[i]) setEncoderData(setup.index, group.index, i, group.encoders[i]);
                            if (group.pushButtons[i]) setPushData(setup.index, group.index, i, group.pushButtons[i]);
                            if (group.greenButtons[i]) setGreenData(setup.index, group.index, i, group.greenButtons[i]);
                            if (group.faders[i]) setFaderData(setup.index, group.index, i, group.faders[i]);
                        }
                        if (group.fader9) setFader9Data(setup.index, group.index, group.fader9);
                        
                        // Import group name if present (Phase 3b per spec)
                        if (group.name && typeof group.name === 'string') {
                            const result = stringToGroupNameValues(group.name);
                            if (result.error) {
                                // Detailed error message per spec requirements
                                console.warn(
                                    `JSON Import Error: Setup ${setup.index + 1}, Group ${group.index + 1}: ` +
                                    `${result.error} in name "${group.name}"`
                                );
                                // Don't fail entire import, just skip this name
                            } else {
                                setGroupName(setup.index, group.index, result.values);
                            }
                        }
                    }
                }
                
                updateStatus('modified', 'JSON imported - changes pending');
                renderCurrentView();
            } catch (err) {
                alert('Error loading JSON: ' + err.message);
                console.error(err);
            }
            
            e.target.value = '';
        });
        
        // ============================================================
        // Status
        // ============================================================
        
        function markModified() {
            isModified = true;
            updateStatus('modified', 'Modified - remember to export');
            scheduleAutoSave();
        }
        
        function updateStatus(state, text) {
            const dot = document.getElementById('statusDot');
            const txt = document.getElementById('statusText');
            
            dot.className = 'status-dot ' + state;
            txt.textContent = text;
        }
        
        // ============================================================
        // Toast Notifications
        // ============================================================
        
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // ============================================================
        // Group Name Editor Modal (per UC4_GROUP_NAME_EDITING_SPEC_v2)
        // ============================================================
        
        function showGroupNameEditor(setupIdx, group) {
            const data = getGroupNameData(setupIdx, group);
            const currentDisplay = data ? data.display : `GrP${group + 1}`;
            const hasNonCanonical = data?.hasNonCanonical || false;
            const originalValues = data?.values || null;  // Store for comparison
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay';
            dialog.id = 'groupNameModal';
            dialog.dataset.originalValues = JSON.stringify(originalValues);  // Stash for save comparison
            dialog.dataset.setupIdx = setupIdx;
            dialog.dataset.group = group;
            
            // Trim trailing spaces for input field (trim-right view)
            const inputValue = currentDisplay.replace(/\s+$/, '');
            
            dialog.innerHTML = `
                <div class="modal-dialog group-name-dialog">
                    <h3>Edit Group ${group + 1} Name</h3>
                    <p class="info">Setup ${setupIdx + 1}</p>
                    
                    ${hasNonCanonical ? '<p class="warning">âš  Contains non-standard codes; editor will preserve them unless you overwrite the name.</p>' : ''}
                    
                    <input type="text" 
                           id="groupNameInput" 
                           value="${escapeHtml(inputValue)}"
                           maxlength="4"
                           autocomplete="off"
                           spellcheck="false">
                    
                    <p class="preview">UC4 will show: <span id="groupNamePreview">${escapeHtml(currentDisplay).replace(/ /g, 'Â·')}</span></p>
                    
                    <p class="hint">Valid: 0-9 A b C d E F G H I J L n O t P S r U Y - _ space</p>
                    <p class="error" id="groupNameError"></p>
                    
                    <div class="modal-actions">
                        <button class="btn" onclick="closeGroupNameDialog()">Cancel</button>
                        <button class="btn btn-primary" id="groupNameSaveBtn" onclick="saveGroupNameFromDialog()">Save</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            const input = document.getElementById('groupNameInput');
            input.focus();
            input.select();
            
            // Live validation
            input.addEventListener('input', validateGroupNameInput);
            
            // Keyboard shortcuts
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !document.getElementById('groupNameSaveBtn').disabled) {
                    saveGroupNameFromDialog();
                } else if (e.key === 'Escape') {
                    closeGroupNameDialog();
                }
            });
            
            // Click outside to close
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    closeGroupNameDialog();
                }
            });
            
            validateGroupNameInput();
        }
        
        function validateGroupNameInput() {
            const input = document.getElementById('groupNameInput');
            const preview = document.getElementById('groupNamePreview');
            const error = document.getElementById('groupNameError');
            const saveBtn = document.getElementById('groupNameSaveBtn');
            
            const result = stringToGroupNameValues(input.value);
            
            if (result.error) {
                error.textContent = result.error;
                saveBtn.disabled = true;
                preview.textContent = '----';
            } else {
                error.textContent = '';
                saveBtn.disabled = false;
                // Show what UC4 will actually display (Â· for spaces)
                preview.textContent = result.display.replace(/ /g, 'Â·');
            }
        }
        
        function saveGroupNameFromDialog() {
            const modal = document.getElementById('groupNameModal');
            const input = document.getElementById('groupNameInput');
            const setupIdx = parseInt(modal.dataset.setupIdx);
            const group = parseInt(modal.dataset.group);
            const originalValues = JSON.parse(modal.dataset.originalValues);
            
            const result = stringToGroupNameValues(input.value);
            
            if (result.error) {
                showToast(result.error, 'error');
                return;
            }
            
            // Handle read failure case (Rule 7: Read failure handling)
            if (originalValues === null) {
                // Re-read to see if it's still failing
                const reread = getGroupNameData(setupIdx, group);
                if (reread === null) {
                    showToast('Cannot save: unable to read group name bytes', 'error');
                    return;
                }
                // Read succeeded now, proceed with comparison against fresh data
                const currentValues = reread.values;
                const bytesChanged = result.values.some((v, i) => v !== currentValues[i]);
                if (!bytesChanged) {
                    closeGroupNameDialog();
                    return;
                }
                // Apply with fresh originalValues for undo
                changeGroupNameWithUndo(setupIdx, group, result.values);
            } else {
                // BYTE-BASED COMPARISON: Check if values actually changed
                const newValues = result.values;
                const bytesChanged = newValues.some((v, i) => v !== originalValues[i]);
                
                if (!bytesChanged) {
                    // No-op: bytes unchanged, just close without undo action
                    closeGroupNameDialog();
                    return;
                }
                
                // Bytes changed: apply with undo
                changeGroupNameWithUndo(setupIdx, group, result.values);
            }
            
            closeGroupNameDialog();
            
            // Update all UI locations
            renderCurrentView();
            updateGroupNameDisplays();
            
            showToast(`Group ${group + 1} renamed`, 'success');
        }
        
        function closeGroupNameDialog() {
            const modal = document.getElementById('groupNameModal');
            if (modal) {
                modal.remove();
            }
            // Note: Cancel does NOT write any bytes (R9 compliance)
        }
        
        // Update group name displays in focused view nav
        function updateGroupNameDisplays() {
            const encoderGroupNameEl = document.getElementById('encoderGroupName');
            const faderGroupNameEl = document.getElementById('faderGroupName');
            
            if (encoderGroupNameEl) {
                encoderGroupNameEl.textContent = getGroupName(currentSetup, encoderGroup);
            }
            if (faderGroupNameEl) {
                faderGroupNameEl.textContent = getGroupName(currentSetup, faderGroup);
            }
        }
        
        // ============================================================
        // Undo/Redo System
        // ============================================================
        
        function recordUndo(action) {
            if (!action.description) {
                action.description = generateDescription(action);
            }
            action.timestamp = Date.now();
            
            undoStack.push(action);
            
            // Clear redo stack (new action invalidates redo history)
            redoStack.length = 0;
            
            // Trim if over limit
            while (undoStack.length > MAX_UNDO) {
                undoStack.shift();
            }
            
            updateUndoRedoUI();
        }
        
        function recordUndoCoalesced(action) {
            const last = undoStack[undoStack.length - 1];
            
            // Check if we should coalesce with previous action
            if (last && 
                last.type === 'value' &&
                action.type === 'value' &&
                last.controlType === action.controlType &&
                last.setupIdx === action.setupIdx &&
                last.group === action.group &&
                last.index === action.index &&
                last.param === action.param &&
                (Date.now() - last.timestamp) < COALESCE_WINDOW) {
                
                // Update the existing action's 'after' value
                last.after = action.after;
                last.timestamp = Date.now();
                // Keep original 'before' value
                return;
            }
            
            // Otherwise record as new action
            recordUndo(action);
        }
        
        function generateDescription(action) {
            const formatControlName = (type, group, index) => {
                const g = group + 1;
                const i = index + 1;
                switch (type) {
                    case 'encoder': return `Encoder G${g}.${i}`;
                    case 'push': return `Push G${g}.${i}`;
                    case 'green': return `Green G${g}.${i}`;
                    case 'fader': return `Fader G${g}.${i}`;
                    case 'fader9': return `Fader9 G${g}`;
                    default: return `${type} G${g}.${i}`;
                }
            };
            
            switch (action.type) {
                case 'value':
                    return `Change ${formatControlName(action.controlType, action.group, action.index)} ${action.param}`;
                case 'control':
                    return `Update ${formatControlName(action.controlType, action.group, action.index)}`;
                case 'batch':
                    return action.description || 'Batch operation';
                default:
                    return 'Unknown action';
            }
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            const action = undoStack.pop();
            
            // Apply reverse
            applyAction(action, true);
            
            redoStack.push(action);
            updateUndoRedoUI();
            renderCurrentView();
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            const action = redoStack.pop();
            
            // Apply forward
            applyAction(action, false);
            
            undoStack.push(action);
            updateUndoRedoUI();
            renderCurrentView();
        }
        
        function confirmReset() {
            const hasOriginal = originalBuffer !== null;
            const message = hasOriginal 
                ? 'Reset all changes back to the imported SysEx?\n\nThis will discard all modifications.'
                : 'Load default UC4 configuration?\n\nNo SysEx was imported, so this will load factory defaults.';
            
            if (confirm(message)) {
                performReset();
            }
        }
        
        function performReset() {
            if (originalBuffer) {
                // Reset to imported SysEx
                rawBuffer = new Uint8Array(originalBuffer);
                sectionIndex = buildIndex(rawBuffer);
            } else {
                // Load default - create a basic UC4 config
                // For now, just show a message since we don't have a default template
                showToast('No SysEx imported - import a SysEx file first', 'warning');
                return;
            }
            
            // Clear undo/redo stacks
            undoStack.length = 0;
            redoStack.length = 0;
            updateUndoRedoUI();
            
            // Reset state
            isModified = false;
            dirtyBanks.clear();
            
            // Clear Quick Paste source
            quickPaste.source = null;
            quickPaste.pasteCount = 0;
            
            // Rebuild conflict map
            rebuildConflictMap();
            
            // Re-render
            renderCurrentView();
            updateStatus('loaded', 'Reset to imported SysEx');
            showToast('Reset to imported SysEx', 'success');
        }
        
        function applyAction(action, reverse) {
            suppressModified = true;
            try {
                switch (action.type) {
                    case 'value': {
                        const value = reverse ? action.before : action.after;
                        applyValueChange(action, value);
                        break;
                    }
                        
                    case 'control': {
                        const data = reverse ? action.before : action.after;
                        setControlDataSilent(action.controlType, action.setupIdx, action.group, action.index, data);
                        break;
                    }
                        
                    case 'batch': {
                        for (const subAction of action.actions) {
                            const subData = reverse ? subAction.before : subAction.after;
                            setControlDataSilent(subAction.controlType, subAction.setupIdx, subAction.group, subAction.index, subData);
                        }
                        break;
                    }
                    
                    case 'group-name': {
                        const values = reverse ? action.beforeValues : action.afterValues;
                        setGroupName(action.setupIdx, action.group, values);
                        break;
                    }
                }
            } finally {
                suppressModified = false;
            }
            
            // After any change
            markModified();
            
            // Only rebuild conflicts if action affects routing params
            if (actionAffectsConflicts(action)) {
                scheduleConflictRebuild();
            }
        }
        
        function applyValueChange(action, value) {
            const getData = getControlDataByType(action.controlType);
            const setData = setControlDataByType(action.controlType);
            
            if (!getData || !setData) return;
            
            const data = getData(action.setupIdx, action.group, action.index);
            data[action.param] = value;
            setData(action.setupIdx, action.group, action.index, data);
        }
        
        function getControlDataByType(type) {
            switch (type) {
                case 'encoder': return getEncoderData;
                case 'push': return getPushData;
                case 'green': return getGreenData;
                case 'fader': return getFaderData;
                case 'fader9': return (s, g, i) => getFader9Data(s, g);
                default: return null;
            }
        }
        
        function setControlDataByType(type) {
            switch (type) {
                case 'encoder': return setEncoderData;
                case 'push': return setPushData;
                case 'green': return setGreenData;
                case 'fader': return setFaderData;
                case 'fader9': return (s, g, i, d) => setFader9Data(s, g, d);
                default: return null;
            }
        }
        
        // Silent setters that don't trigger markModified (for undo/redo)
        function setControlDataSilent(type, setupIdx, group, index, data) {
            const setData = setControlDataByType(type);
            if (!setData) return;

            suppressModified = true;
            try {
                setData(setupIdx, group, index, data);
            } finally {
                suppressModified = false;
            }
        }
        
        function actionAffectsConflicts(action) {
            if (action.type === 'value') {
                return CONFLICT_PARAMS.has(action.param);
            }
            // control and batch actions are conservative - always rebuild
            return true;
        }
        
        function updateUndoRedoUI() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
            
            // Update tooltips
            if (undoStack.length > 0) {
                undoBtn.title = `Undo: ${undoStack[undoStack.length - 1].description}`;
            } else {
                undoBtn.title = 'Undo (Ctrl+Z)';
            }
            
            if (redoStack.length > 0) {
                redoBtn.title = `Redo: ${redoStack[redoStack.length - 1].description}`;
            } else {
                redoBtn.title = 'Redo (Ctrl+Y)';
            }
        }
        
        // ============================================================
        // Session Persistence
        // ============================================================
        
        function scheduleAutoSave() {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
                saveSession();
            }, AUTO_SAVE_DELAY);
        }
        
        function saveSession() {
            if (!rawBuffer) return;
            
            try {
                const sessionData = {
                    version: SESSION_VERSION,
                    timestamp: Date.now(),
                    buffer: Array.from(rawBuffer),
                    uiState: {
                        currentSetup,
                        encoderGroup,
                        faderGroup,
                        currentView
                    },
                    dirtyBanks: Array.from(dirtyBanks)
                };
                
                localStorage.setItem(STORAGE_KEY, JSON.stringify(sessionData));
            } catch (e) {
                console.warn('Session save failed:', e);
                if (e.name === 'QuotaExceededError') {
                    showToast('Autosave failed (storage full)', 'error');
                }
            }
        }
        
        function loadSession() {
            try {
                const json = localStorage.getItem(STORAGE_KEY);
                if (!json) return null;
                
                const session = JSON.parse(json);
                
                // Version check
                if (session.version !== SESSION_VERSION) {
                    console.warn('Session version mismatch, discarding');
                    clearSession();
                    return null;
                }
                
                // Buffer integrity checks
                if (!session.buffer || session.buffer.length !== EXPECTED_SIZE) {
                    console.warn('Invalid buffer length, discarding');
                    clearSession();
                    return null;
                }
                
                // SysEx framing check
                if (session.buffer[0] === 0xF0) {
                    if (session.buffer[session.buffer.length - 1] !== 0xF7) {
                        console.warn('Invalid SysEx framing, discarding');
                        clearSession();
                        return null;
                    }
                }
                
                return session;
            } catch (e) {
                console.error('Failed to parse session:', e);
                clearSession();
                return null;
            }
        }
        
        function clearSession() {
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (e) {
                console.warn('Failed to clear session:', e);
            }
        }
        
        function restoreSession(session) {
            rawBuffer = new Uint8Array(session.buffer);
            sectionIndex = buildIndex(rawBuffer);
            
            // Allow Reset to function after restore
            originalBuffer = new Uint8Array(rawBuffer);
            
            // Restore UI state
            currentSetup = session.uiState.currentSetup || 0;
            encoderGroup = session.uiState.encoderGroup || 0;
            faderGroup = session.uiState.faderGroup || 0;
            currentView = session.uiState.currentView || 'focused';
            
            // Restore dirty banks
            dirtyBanks = new Set(session.dirtyBanks || []);
            isModified = dirtyBanks.size > 0;
            
            // Enable UI
            document.getElementById('setupSelect').disabled = false;
            document.getElementById('setupSelect').value = currentSetup.toString();
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('exportJsonBtn').disabled = false;
            
            updateGroupTabs('encoderGroupTabs', encoderGroup);
            updateGroupTabs('faderGroupTabs', faderGroup);
            updateGroupNames();
            
            // Build conflict map for restored setup
            rebuildConflictMap();
            
            setView(currentView);
            
            if (isModified) {
                updateStatus('modified', 'Session restored - changes pending');
            } else {
                updateStatus('loaded', 'Session restored');
            }
            
            document.getElementById('fileInfo').textContent = `Restored session (${rawBuffer.length.toLocaleString()} bytes)`;
            
            showToast('Session restored', 'success');
        }
        
        function formatTimeSince(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            const days = Math.floor(hours / 24);
            return `${days} day${days > 1 ? 's' : ''} ago`;
        }
        
        function showRestoreDialog(timeSince, session) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                
                const dirtyCount = session.dirtyBanks ? session.dirtyBanks.length : 0;
                const setupInfo = session.uiState ? `Setup ${(session.uiState.currentSetup || 0) + 1}` : 'Unknown setup';
                
                overlay.innerHTML = `
                    <div class="modal-dialog">
                        <h3>Restore Previous Session?</h3>
                        <p>Found unsaved changes from ${timeSince}.</p>
                        <div class="info">
                            ${setupInfo}<br>
                            ${dirtyCount} modified bank${dirtyCount !== 1 ? 's' : ''}
                        </div>
                        <label>
                            <input type="checkbox" id="skipRestoreCheck">
                            Don't ask again this session
                        </label>
                        <div class="modal-actions">
                            <button class="btn" id="discardBtn">Discard & Load Factory</button>
                            <button class="btn btn-primary" id="restoreBtn">Restore Session</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                document.getElementById('restoreBtn').onclick = () => {
                    overlay.remove();
                    resolve('restore');
                };
                
                document.getElementById('discardBtn').onclick = () => {
                    const skipCheck = document.getElementById('skipRestoreCheck').checked;
                    overlay.remove();
                    if (skipCheck) {
                        resolve('discard-permanently');
                    } else {
                        resolve('discard');
                    }
                };
            });
        }
        
        // ============================================================
        // Conflict Detection
        // ============================================================
        
        function scheduleConflictRebuild() {
            clearTimeout(conflictRebuildTimer);
            conflictRebuildTimer = setTimeout(() => {
                rebuildConflictMap();
                updateConflictUI();
            }, CONFLICT_REBUILD_DELAY);
        }
        
        function rebuildConflictMap() {
            if (!rawBuffer) return;
            
            const result = buildConflictMap(currentSetup);
            conflicts = result;
            
            // Build reverse lookup for quick cell highlighting
            conflictsByControl.clear();
            
            for (const [key, entry] of conflicts.concurrent) {
                for (const ref of entry.refs) {
                    const controlKey = `${ref.type}-${ref.group}-${ref.index}`;
                    if (!conflictsByControl.has(controlKey)) {
                        conflictsByControl.set(controlKey, { concurrent: [], mutuallyExclusive: [] });
                    }
                    conflictsByControl.get(controlKey).concurrent.push(key);
                }
            }
            
            for (const [key, entry] of conflicts.mutuallyExclusive) {
                for (const ref of entry.refs) {
                    const controlKey = `${ref.type}-${ref.group}-${ref.index}`;
                    if (!conflictsByControl.has(controlKey)) {
                        conflictsByControl.set(controlKey, { concurrent: [], mutuallyExclusive: [] });
                    }
                    conflictsByControl.get(controlKey).mutuallyExclusive.push(key);
                }
            }
        }
        
        function buildConflictMap(setupIdx) {
            const assignments = new Map(); // conflictKey -> [controlRef, ...]
            
            // Collect all assignments
            for (let group = 0; group < 8; group++) {
                // Encoders
                for (let i = 0; i < 8; i++) {
                    const data = getEncoderData(setupIdx, group, i);
                    const keys = getEncoderConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'encoder', group, index: i,
                            groupSelector: 'encoder',
                            subtype: ['r1', 'r2', 'CC', 'PC', 'Hi', 'PB', 'AT'][data.type] || 'CC'
                        });
                    }
                }
                
                // Push buttons (same group selector as encoders)
                for (let i = 0; i < 8; i++) {
                    const data = getPushData(setupIdx, group, i);
                    const keys = getButtonConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'push', group, index: i,
                            groupSelector: 'encoder',
                            subtype: { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' }[data.typeNibble] || '?'
                        });
                    }
                }
                
                // Green buttons (fader/button group selector)
                for (let i = 0; i < 8; i++) {
                    const data = getGreenData(setupIdx, group, i);
                    const keys = getButtonConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'green', group, index: i,
                            groupSelector: 'fader',
                            subtype: { 0x10: 'N', 0x20: 'CC', 0x30: 'PC', 0x40: 'AT' }[data.typeNibble] || '?'
                        });
                    }
                }
                
                // Faders 1-8
                for (let i = 0; i < 8; i++) {
                    const data = getFaderData(setupIdx, group, i);
                    const keys = getFaderConflictKeys(data);
                    for (const key of keys) {
                        if (!assignments.has(key)) assignments.set(key, []);
                        assignments.get(key).push({
                            type: 'fader', group, index: i,
                            groupSelector: 'fader',
                            subtype: ['CC', 'PC', 'PB', 'AT'][data.type] || 'CC'
                        });
                    }
                }
                
                // Fader 9
                const f9data = getFader9Data(setupIdx, group);
                const f9key = `${f9data.channel}-cc-${f9data.cc}`;
                if (!assignments.has(f9key)) assignments.set(f9key, []);
                assignments.get(f9key).push({
                    type: 'fader9', group, index: 0,
                    groupSelector: 'fader',
                    subtype: 'CC'
                });
            }
            
            // Build key-centric conflict structure
            const result = {
                concurrent: new Map(),
                mutuallyExclusive: new Map()
            };
            
            for (const [key, refs] of assignments) {
                if (refs.length < 2) continue;
                
                // Check if ANY pair in this key is concurrent
                let hasConcurrent = false;
                for (let i = 0; i < refs.length && !hasConcurrent; i++) {
                    for (let j = i + 1; j < refs.length && !hasConcurrent; j++) {
                        if (isConcurrentConflict(refs[i], refs[j])) {
                            hasConcurrent = true;
                        }
                    }
                }
                
                // Whole key goes into one bucket
                if (hasConcurrent) {
                    result.concurrent.set(key, { key, refs });
                } else {
                    result.mutuallyExclusive.set(key, { key, refs });
                }
            }
            
            return result;
        }
        
        function isConcurrentConflict(a, b) {
            // Different selector domains = can be active simultaneously = concurrent
            if (a.groupSelector !== b.groupSelector) {
                return true;
            }
            // Same selector domain + same group = concurrent (both active when that group selected)
            // Same selector domain + different groups = mutually exclusive
            return a.group === b.group;
        }
        
        function getEncoderConflictKeys(data) {
            const ch = data.channel; // Already 1-based from getEncoderData
            switch (data.type) {
                case 0: // CCr1
                case 1: // CCr2
                case 2: // CCAb
                    return [`${ch}-cc-${data.cc}`];
                case 3: { // PrGC - encoder sweeps a program range
                    const lo = Math.max(0, Math.min(127, data.min | 0));
                    const hi = Math.max(0, Math.min(127, data.max | 0));
                    const a = Math.min(lo, hi), b = Math.max(lo, hi);
                    const keys = [];
                    for (let p = a; p <= b; p++) keys.push(`${ch}-pc-${p}`);
                    return keys;
                }
                case 4: // CCAh (14-bit) - occupies CC and CC+32
                    if (data.cc < 0 || data.cc > 31) return [];
                    return [`${ch}-cc-${data.cc}`, `${ch}-cc-${data.cc + 32}`];
                case 5: // Pbnd
                    return [`${ch}-pb-null`];
                case 6: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getButtonConflictKeys(data) {
            if (data.typeNibble === 0x00) return []; // OFF
            const ch = data.channel; // Already 1-based
            switch (data.typeNibble) {
                case 0x10: // Note
                    return [`${ch}-note-${data.cc}`];
                case 0x20: // CC
                    return [`${ch}-cc-${data.cc}`];
                case 0x30: // PrGC - button sends upper on press, lower on release
                    const keys = [`${ch}-pc-${data.upper}`];
                    if (data.lower !== data.upper) {
                        keys.push(`${ch}-pc-${data.lower}`);
                    }
                    return keys;
                case 0x40: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getFaderConflictKeys(data) {
            const ch = data.channel; // Already 1-based
            switch (data.type) {
                case 0: // CCAb
                    return [`${ch}-cc-${data.cc}`];
                case 1: { // PrGC - fader sweeps a program range
                    const lo = Math.max(0, Math.min(127, data.min | 0));
                    const hi = Math.max(0, Math.min(127, data.max | 0));
                    const a = Math.min(lo, hi), b = Math.max(lo, hi);
                    const keys = [];
                    for (let p = a; p <= b; p++) keys.push(`${ch}-pc-${p}`);
                    return keys;
                }
                case 2: // Pbnd
                    return [`${ch}-pb-null`];
                case 3: // AFtt
                    return [`${ch}-at-null`];
                default:
                    return [];
            }
        }
        
        function getControlConflictType(type, group, index) {
            const controlKey = `${type}-${group}-${index}`;
            const conflicts = conflictsByControl.get(controlKey);
            if (!conflicts) return null;
            
            if (showConcurrentConflicts && conflicts.concurrent.length > 0) {
                return 'concurrent';
            }
            if (showMutuallyExclusiveConflicts && conflicts.mutuallyExclusive.length > 0) {
                return 'mutuallyExclusive';
            }
            return null;
        }
        
        function formatConflictKey(key) {
            // Parse key like "1-cc-64" or "2-pb-null"
            const parts = key.split('-');
            const ch = parts[0];
            const type = parts[1];
            const num = parts[2];
            
            const typeNames = {
                'cc': 'CC',
                'note': 'Note',
                'pc': 'PC',
                'pb': 'PB',
                'at': 'AT'
            };
            
            if (num === 'null') {
                return `Ch${ch} ${typeNames[type] || type}`;
            }
            return `Ch${ch} ${typeNames[type] || type} ${num}`;
        }
        
        function formatControlRef(ref) {
            const typeNames = {
                'encoder': 'Enc',
                'push': 'Push',
                'green': 'Grn',
                'fader': 'Fad',
                'fader9': 'F9'
            };
            const name = typeNames[ref.type] || ref.type;
            return `${name} G${ref.group + 1}.${ref.index + 1} (${ref.subtype})`;
        }
        
        function updateConflictUI() {
            // Update filter chip counts
            updateConflictFilterCounts();
            
            // Re-render overview if in that view
            if (currentView === 'overview') {
                renderOverview();
            }
        }
        
        function updateConflictFilterCounts() {
            const concurrentCount = document.getElementById('concurrentCount');
            const meCount = document.getElementById('meCount');
            
            if (concurrentCount) {
                concurrentCount.textContent = conflicts.concurrent.size;
            }
            if (meCount) {
                meCount.textContent = conflicts.mutuallyExclusive.size;
            }
        }
        
        function toggleConcurrentFilter() {
            showConcurrentConflicts = !showConcurrentConflicts;
            updateConflictUI();
        }
        
        function toggleMEFilter() {
            showMutuallyExclusiveConflicts = !showMutuallyExclusiveConflicts;
            updateConflictUI();
        }
        
        // ============================================================
        // Copy/Paste Operations
        // ============================================================
        
        // Generic control data accessors
        function getControlData(controlType, setupIdx, group, index) {
            switch (controlType) {
                case 'encoder': return getEncoderData(setupIdx, group, index);
                case 'push': return getPushData(setupIdx, group, index);
                case 'green': return getGreenData(setupIdx, group, index);
                case 'fader': return getFaderData(setupIdx, group, index);
                case 'fader9': return getFader9Data(setupIdx, group);
                default: return null;
            }
        }
        
        function setControlData(controlType, setupIdx, group, index, data) {
            switch (controlType) {
                case 'encoder': return setEncoderData(setupIdx, group, index, data);
                case 'push': return setPushData(setupIdx, group, index, data);
                case 'green': return setGreenData(setupIdx, group, index, data);
                case 'fader': return setFaderData(setupIdx, group, index, data);
                case 'fader9': return setFader9Data(setupIdx, group, data);
            }
        }
        
        function formatControlName(controlType, group, index) {
            const typeNames = {
                'encoder': 'Enc',
                'push': 'Push',
                'green': 'Grn',
                'fader': 'Fad',
                'fader9': 'Fad9'
            };
            const name = typeNames[controlType] || controlType;
            if (controlType === 'fader9') {
                return `${name} G${group + 1}`;
            }
            return `${name} G${group + 1}.${index + 1}`;
        }
        
        // Copy operations
        function copyControl(controlType, setupIdx, group, index) {
            const data = getControlData(controlType, setupIdx, group, index);
            if (!data) return;
            
            clipboard = {
                type: 'control',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: group,
                sourceIndex: index,
                data: { ...data }
            };
            showToast(`Copied ${formatControlName(controlType, group, index)}`);
        }
        
        function copyRow(controlType, setupIdx, index) {
            const data = [];
            for (let g = 0; g < 8; g++) {
                data.push({ ...getControlData(controlType, setupIdx, g, index) });
            }
            clipboard = {
                type: 'row',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: null,
                sourceIndex: index,
                data
            };
            const typeName = { encoder: 'Enc', push: 'Push', green: 'Grn', fader: 'Fad', fader9: 'Fad9' }[controlType];
            showToast(`Copied ${typeName} ${index + 1} row (all groups)`);
        }
        
        function copyColumn(controlType, setupIdx, group) {
            const count = controlType === 'fader9' ? 1 : 8;
            const data = [];
            for (let i = 0; i < count; i++) {
                data.push({ ...getControlData(controlType, setupIdx, group, i) });
            }
            clipboard = {
                type: 'column',
                controlType,
                sourceSetup: setupIdx,
                sourceGroup: group,
                sourceIndex: null,
                data
            };
            const typeName = { encoder: 'Encoders', push: 'Push Btns', green: 'Green Btns', fader: 'Faders', fader9: 'Fader 9' }[controlType];
            showToast(`Copied Group ${group + 1} ${typeName}`);
        }
        
        // Check paste compatibility
        function canPaste(clip, targetControlType) {
            if (!clip) return false;
            // Must be same control type
            return clip.controlType === targetControlType;
        }
        
        // Apply offset with wrap/clamp
        function applyOffset(value, delta, min, max, wrapMode) {
            const v = value + delta;
            if (wrapMode === 'wrap') {
                const range = max - min + 1;
                return min + (((v - min) % range) + range) % range;
            } else {
                return Math.max(min, Math.min(max, v)); // clamp
            }
        }
        
        // Transform copied data with options
        function transformControlData(data, options) {
            let newData = { ...data };
            
            // Apply channel offset (channel is 1-based: 1-16)
            if (options.channelOffset && options.channelOffset !== 0) {
                const newCh = applyOffset(newData.channel, options.channelOffset, 1, 16, options.wrapMode);
                newData.channel = newCh;
            }
            
            // Apply CC/number offset
            if (options.numberOffset && options.numberOffset !== 0) {
                if (newData.cc !== undefined) {
                    newData.cc = applyOffset(newData.cc, options.numberOffset, 0, 127, options.wrapMode);
                }
            }
            
            return newData;
        }
        
        // Paste to single control
        function pasteToControl(controlType, setupIdx, group, index, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const before = getControlData(controlType, setupIdx, group, index);
            let sourceData;
            
            if (clipboard.type === 'control') {
                sourceData = clipboard.data;
            } else if (clipboard.type === 'row') {
                sourceData = clipboard.data[group]; // Use data for this group
            } else if (clipboard.type === 'column') {
                sourceData = clipboard.data[index]; // Use data for this index
            } else {
                showToast('Unsupported clipboard type for single paste', 'warning');
                return;
            }
            
            const newData = transformControlData(sourceData, options, 0);
            setControlData(controlType, setupIdx, group, index, newData);
            
            recordUndo({
                type: 'control',
                description: `Paste to ${formatControlName(controlType, group, index)}`,
                controlType,
                setupIdx,
                group,
                index,
                before,
                after: newData
            });
            
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to ${formatControlName(controlType, group, index)}`);
        }
        
        // Paste row to all groups
        function pasteRowToGroups(controlType, setupIdx, index, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const batch = { type: 'batch', description: `Paste row ${index + 1}`, actions: [] };
            
            for (let g = 0; g < 8; g++) {
                const before = getControlData(controlType, setupIdx, g, index);
                let sourceData;
                
                if (clipboard.type === 'control') {
                    sourceData = clipboard.data;
                } else if (clipboard.type === 'row') {
                    sourceData = clipboard.data[g];
                } else if (clipboard.type === 'column') {
                    sourceData = clipboard.data[0]; // Use first item for all
                }
                
                const newData = transformControlData(sourceData, options, g);
                setControlData(controlType, setupIdx, g, index, newData);
                
                batch.actions.push({
                    type: 'control',
                    controlType,
                    setupIdx,
                    group: g,
                    index,
                    before,
                    after: newData
                });
            }
            
            recordUndo(batch);
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to row ${index + 1} (all groups)`);
        }
        
        // Paste column to group
        function pasteColumnToGroup(controlType, setupIdx, group, options = {}) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const count = controlType === 'fader9' ? 1 : 8;
            const batch = { type: 'batch', description: `Paste to Group ${group + 1}`, actions: [] };
            
            for (let i = 0; i < count; i++) {
                const before = getControlData(controlType, setupIdx, group, i);
                let sourceData;
                
                if (clipboard.type === 'control') {
                    sourceData = clipboard.data;
                } else if (clipboard.type === 'row') {
                    sourceData = clipboard.data[0]; // Use first group's data
                } else if (clipboard.type === 'column') {
                    sourceData = clipboard.data[i];
                }
                
                const newData = transformControlData(sourceData, options, i);
                setControlData(controlType, setupIdx, group, i, newData);
                
                batch.actions.push({
                    type: 'control',
                    controlType,
                    setupIdx,
                    group,
                    index: i,
                    before,
                    after: newData
                });
            }
            
            recordUndo(batch);
            markModified();
            scheduleConflictRebuild();
            renderCurrentView();
            showToast(`Pasted to Group ${group + 1}`);
        }
        
        // Set selection (for overview click/keyboard)
        function setSelection(controlType, group, index) {
            // Clear previous selection highlight
            clearSelectionHighlight();
            
            selection = {
                mode: 'single',
                controlType,
                group,
                index
            };
            
            // Apply new selection highlight
            updateSelectionHighlight();
        }
        
        // Clear selection
        function clearSelection() {
            clearSelectionHighlight();
            selection = { mode: 'none', controlType: null, group: null, index: null };
        }
        
        // Update visual highlight for current selection
        function updateSelectionHighlight() {
            if (selection.mode === 'none' || currentView !== 'overview') return;
            
            const cell = getOverviewCell(selection.controlType, selection.group, selection.index);
            if (cell) {
                cell.classList.add('selected');
                cell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        }
        
        // Clear visual highlight
        function clearSelectionHighlight() {
            const selected = document.querySelectorAll('.overview-table td.selected');
            selected.forEach(cell => cell.classList.remove('selected'));
        }
        
        // Get cell element by control type, group, index
        function getOverviewCell(controlType, group, index) {
            // Search all overview tables (Fader 9 is now in its own table)
            const tables = document.querySelectorAll('.overview-table');
            for (const table of tables) {
                const cell = table.querySelector(`td[data-type="${controlType}"][data-group="${group}"][data-index="${index}"]`);
                if (cell) return cell;
            }
            return null;
        }
        
        // Get max index for control type
        function getMaxIndex(controlType) {
            return controlType === 'fader9' ? 0 : 7;
        }
        
        // Check if cell is part of Quick Paste source
        function isQuickPasteSource(controlType, group, index) {
            if (!quickPaste.source || quickPaste.source.controlType !== controlType) return false;
            
            const scope = quickPaste.source.lockedScope;
            const srcGroup = quickPaste.source.group;
            const srcIndex = quickPaste.source.index;
            
            if (scope === 'cell') {
                return group === srcGroup && index === srcIndex;
            } else if (scope === 'column') {
                return group === srcGroup;
            } else if (scope === 'row') {
                return index === srcIndex;
            }
            return false;
        }
        
        // Keyboard navigation
        function moveSelection(direction) {
            if (currentView !== 'overview') return;
            
            // If no selection, start at 0,0 with appropriate control type
            if (selection.mode === 'none') {
                let startType = 'encoder';
                if (overviewTab === 'push') startType = 'push';
                else if (overviewTab === 'green') startType = 'green';
                else if (overviewTab === 'faders') startType = 'fader';
                // 'all' and 'encoders' both start with encoder
                setSelection(startType, 0, 0);
                return;
            }
            
            let { controlType, group, index } = selection;
            const maxIndex = getMaxIndex(controlType);
            
            // Define control type order for 'all' tab navigation
            const allTypeOrder = ['encoder', 'push', 'green', 'fader', 'fader9'];
            
            switch (direction) {
                case 'left':
                    group = Math.max(0, group - 1);
                    break;
                case 'right':
                    group = Math.min(7, group + 1);
                    break;
                case 'up':
                    if (index > 0) {
                        index--;
                    } else if (overviewTab === 'all') {
                        // Move to previous control type section
                        const currentTypeIdx = allTypeOrder.indexOf(controlType);
                        if (currentTypeIdx > 0) {
                            controlType = allTypeOrder[currentTypeIdx - 1];
                            index = getMaxIndex(controlType);
                        }
                    } else if (controlType === 'fader9') {
                        // Move from fader9 row to fader row 8
                        controlType = 'fader';
                        index = 7;
                    }
                    break;
                case 'down':
                    if (index < maxIndex) {
                        index++;
                    } else if (overviewTab === 'all') {
                        // Move to next control type section
                        const currentTypeIdx = allTypeOrder.indexOf(controlType);
                        if (currentTypeIdx < allTypeOrder.length - 1) {
                            controlType = allTypeOrder[currentTypeIdx + 1];
                            index = 0;
                        }
                    } else if (controlType === 'fader' && overviewTab === 'faders') {
                        // Move from fader row 8 to fader9 row
                        controlType = 'fader9';
                        index = 0;
                    }
                    break;
            }
            
            setSelection(controlType, group, index);
        }
        
        // Handle Enter key - jump to focused view
        function handleEnterKey() {
            if (currentView === 'overview' && selection.mode !== 'none') {
                jumpToFocusedView(selection.controlType, selection.group, selection.index);
            }
        }
        
        // Context menu
        let contextMenu = null;
        
        function showContextMenu(e, controlType, group, index) {
            e.preventDefault();
            hideContextMenu();
            
            setSelection(controlType, group, index);
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.innerHTML = `
                <div class="context-menu-item" onclick="copyControl('${controlType}', ${currentSetup}, ${group}, ${index}); hideContextMenu();">
                    Copy Control
                </div>
                <div class="context-menu-item" onclick="copyRow('${controlType}', ${currentSetup}, ${index}); hideContextMenu();">
                    Copy Row (${controlType === 'fader9' ? 'Fad9' : (index + 1)} * 8 groups)
                </div>
                <div class="context-menu-item" onclick="copyColumn('${controlType}', ${currentSetup}, ${group}); hideContextMenu();">
                    Copy Column (Group ${group + 1})
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item ${!clipboard || !canPaste(clipboard, controlType) ? 'disabled' : ''}" 
                     onclick="${clipboard && canPaste(clipboard, controlType) ? `pasteToControl('${controlType}', ${currentSetup}, ${group}, ${index}); hideContextMenu();` : ''}">
                    Paste
                </div>
                <div class="context-menu-item ${!clipboard || !canPaste(clipboard, controlType) ? 'disabled' : ''}" 
                     onclick="${clipboard && canPaste(clipboard, controlType) ? `showPasteSpecialDialog('${controlType}', ${group}, ${index}); hideContextMenu();` : ''}">
                    Paste Special...
                </div>
            `;
            
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            
            document.body.appendChild(menu);
            contextMenu = menu;
            
            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 0);
        }
        
        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }
        
        // Paste Special Dialog
        function showPasteSpecialDialog(controlType, group, index) {
            if (!clipboard || !canPaste(clipboard, controlType)) {
                showToast('Nothing compatible to paste', 'warning');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const sourceInfo = clipboard.type === 'control' 
                ? formatControlName(clipboard.controlType, clipboard.sourceGroup, clipboard.sourceIndex)
                : clipboard.type === 'row'
                    ? `Row ${clipboard.sourceIndex + 1} (8 groups)`
                    : `Group ${clipboard.sourceGroup + 1} column`;
            
            overlay.innerHTML = `
                <div class="modal-dialog paste-special-dialog">
                    <h3>Paste Special</h3>
                    <p class="paste-source">Source: ${sourceInfo}</p>
                    
                    <div class="paste-section">
                        <label class="paste-section-label">Paste to:</label>
                        <div class="paste-targets">
                            <label><input type="radio" name="pasteTarget" value="single" checked> Current cell</label>
                            <label><input type="radio" name="pasteTarget" value="row"> Entire row (all groups)</label>
                            <label><input type="radio" name="pasteTarget" value="column"> Entire column (Group ${group + 1})</label>
                        </div>
                    </div>
                    
                    <div class="paste-section">
                        <label class="paste-section-label">Transforms:</label>
                        <div class="paste-transforms">
                            <div class="transform-row">
                                <label>Channel offset:</label>
                                <input type="number" id="channelOffset" value="0" min="-15" max="15">
                            </div>
                            <div class="transform-row">
                                <label>CC/Number offset:</label>
                                <input type="number" id="numberOffset" value="0" min="-127" max="127">
                            </div>
                            <div class="transform-row">
                                <label>
                                    <input type="checkbox" id="autoIncrement"> Auto-increment CC by:
                                </label>
                                <input type="number" id="incrementBy" value="1" min="1" max="127" style="width: 60px;">
                            </div>
                            <div class="transform-row">
                                <label>Out-of-range:</label>
                                <select id="wrapMode">
                                    <option value="clamp">Clamp to limits</option>
                                    <option value="wrap">Wrap around</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-buttons">
                        <button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        <button class="btn btn-primary" onclick="executePasteSpecial('${controlType}', ${group}, ${index}); this.closest('.modal-overlay').remove();">Paste</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        function executePasteSpecial(controlType, group, index) {
            const target = document.querySelector('input[name="pasteTarget"]:checked').value;
            const options = {
                channelOffset: parseInt(document.getElementById('channelOffset').value) || 0,
                numberOffset: parseInt(document.getElementById('numberOffset').value) || 0,
                autoIncrement: document.getElementById('autoIncrement').checked,
                incrementBy: parseInt(document.getElementById('incrementBy').value) || 1,
                wrapMode: document.getElementById('wrapMode').value
            };
            
            switch (target) {
                case 'single':
                    pasteToControl(controlType, currentSetup, group, index, options);
                    break;
                case 'row':
                    pasteRowToGroups(controlType, currentSetup, index, options);
                    break;
                case 'column':
                    pasteColumnToGroup(controlType, currentSetup, group, options);
                    break;
            }
        }
        
        // Keyboard copy/paste for current selection or focused view
        function handleCopy() {
            if (currentView === 'focused') {
                // In focused view, copy the currently visible encoders (first one as default)
                // This is a simple approach - could be enhanced with actual selection
                copyControl('encoder', currentSetup, encoderGroup, 0);
            } else if (selection.mode !== 'none') {
                copyControl(selection.controlType, currentSetup, selection.group, selection.index);
            } else {
                showToast('Nothing selected to copy', 'warning');
            }
        }
        
        function handlePaste() {
            if (!clipboard) {
                showToast('Nothing to paste', 'warning');
                return;
            }
            
            if (currentView === 'focused') {
                // Paste to current encoder group, first encoder
                if (canPaste(clipboard, 'encoder')) {
                    pasteToControl('encoder', currentSetup, encoderGroup, 0);
                } else {
                    showToast('Clipboard contents not compatible with encoders', 'warning');
                }
            } else if (selection.mode !== 'none') {
                pasteToControl(selection.controlType, currentSetup, selection.group, selection.index);
            } else {
                showToast('Nothing selected to paste to', 'warning');
            }
        }
        
        // ============================================================
        // Quick Paste System (v1.0)
        // ============================================================
        
        function createQuickPasteToolbar() {
            const toolbar = document.createElement('div');
            toolbar.id = 'quickPasteToolbar';
            toolbar.className = `quick-paste-toolbar ${quickPaste.mode === 'off' ? 'collapsed' : ''}`;
            
            const isExpanded = quickPaste.mode !== 'off';
            const hasSource = quickPaste.source !== null;
            
            // Build channel multiplier options (-8 to +8, default 1)
            let chOptions = '';
            for (let i = -8; i <= 8; i++) {
                const label = i === 0 ? '0' : (i > 0 ? `+${i}` : `${i}`);
                chOptions += `<option value="${i}" ${quickPaste.chMultiplier === i ? 'selected' : ''}>${label}</option>`;
            }
            
            // Build CC multiplier options (-8 to +8, default 1)
            let ccOptions = '';
            for (let i = -8; i <= 8; i++) {
                const label = i === 0 ? '0' : (i > 0 ? `+${i}` : `${i}`);
                ccOptions += `<option value="${i}" ${quickPaste.ccMultiplier === i ? 'selected' : ''}>${label}</option>`;
            }
            
            // Source display
            let sourceText = 'No source';
            if (hasSource) {
                const s = quickPaste.source;
                const scopeNames = { cell: 'Cell', column: 'Column', row: 'Row' };
                const typeNames = { encoder: 'Enc', push: 'Push', green: 'Grn', fader: 'Fad', fader9: 'F9' };
                const typeName = typeNames[s.controlType] || s.controlType;
                
                if (s.lockedScope === 'cell') {
                    sourceText = `${typeName} G${s.group + 1}.${s.index + 1}`;
                } else if (s.lockedScope === 'column') {
                    sourceText = `${typeName} Column G${s.group + 1} (${s.count})`;
                } else if (s.lockedScope === 'row') {
                    sourceText = `${typeName} Row ${s.index + 1} (${s.count})`;
                }
            }
            
            // Status text
            let statusText = '';
            if (quickPaste.mode === 'off') {
                statusText = 'Press Q to start Quick Paste';
            } else if (quickPaste.mode === 'copy') {
                statusText = hasSource ? 'Click cell to copy new source, or switch to Paste' : 'Click a cell to set source';
            } else if (quickPaste.mode === 'paste') {
                statusText = hasSource ? `Click to paste â€¢ ${quickPaste.pasteCount} pasted` : 'Switch to Copy mode first';
            }
            
            toolbar.innerHTML = `
                <div class="qp-section">
                    <span class="qp-label">Mode</span>
                    <div class="qp-mode-buttons">
                        <button class="qp-mode-btn ${quickPaste.mode === 'off' ? 'active' : ''}" data-mode="off" onclick="setQuickPasteMode('off')">Off</button>
                        <button class="qp-mode-btn ${quickPaste.mode === 'copy' ? 'active' : ''}" data-mode="copy" onclick="setQuickPasteMode('copy')">Copy</button>
                        <button class="qp-mode-btn ${quickPaste.mode === 'paste' ? 'active' : ''}" data-mode="paste" onclick="setQuickPasteMode('paste')">Paste</button>
                    </div>
                </div>
                
                <div class="qp-expanded-content qp-section">
                    <span class="qp-label">Scope</span>
                    <div class="qp-scope-btns">
                        <button class="qp-scope-btn ${quickPaste.scope === 'cell' ? 'active' : ''}" 
                                onclick="setQuickPasteScope('cell')" title="Single cell [1]">Cell</button>
                        <button class="qp-scope-btn ${quickPaste.scope === 'column' ? 'active' : ''}" 
                                onclick="setQuickPasteScope('column')" title="Entire column/group [2]">Column</button>
                        <button class="qp-scope-btn ${quickPaste.scope === 'row' ? 'active' : ''}" 
                                onclick="setQuickPasteScope('row')" title="Entire row [3]">Row</button>
                    </div>
                </div>
                
                <div class="qp-expanded-content qp-section">
                    <span class="qp-label">Source</span>
                    <div class="qp-source-display ${hasSource ? 'has-source' : ''}">${sourceText}</div>
                </div>
                
                <div class="qp-expanded-content qp-section qp-ch-section">
                    <span class="qp-label">Ch</span>
                    <select id="qpChMult" onchange="setQuickPasteChMult(this.value)" title="Channel offset = group diff * this value">${chOptions}</select>
                </div>
                
                <div class="qp-expanded-content qp-section qp-ch-section">
                    <span class="qp-label">CC</span>
                    <select id="qpCCMult" onchange="setQuickPasteCCMult(this.value)" title="CC offset = group diff * this value">${ccOptions}</select>
                </div>
                
                <div class="qp-expanded-content qp-actions">
                    <button class="qp-action-btn" onclick="clearQuickPasteSource()" ${!hasSource ? 'disabled' : ''}>Clear Source</button>
                </div>
                
                <div class="qp-expanded-content qp-status">${statusText}</div>
            `;
            
            return toolbar;
        }
        
        function setQuickPasteMode(mode) {
            const prevMode = quickPaste.mode;
            quickPaste.mode = mode;
            
            // Clear source when going to off mode
            if (mode === 'off') {
                quickPaste.source = null;
                quickPaste.pasteCount = 0;
            }
            
            // Clear hover highlight tracking when leaving paste mode
            if (prevMode === 'paste' && mode !== 'paste') {
                lastHoverKey = null;
                clearHoverHighlight();
            }
            
            // Collapse/expand toolbar
            const toolbar = document.getElementById('quickPasteToolbar');
            if (toolbar) {
                toolbar.classList.toggle('collapsed', mode === 'off');
            }
            
            // Update table cursor class
            updateOverviewTableCursor();
            
            // Re-render toolbar
            renderOverview();
        }
        
        function setQuickPasteScope(scope) {
            // If scope is changing and we have a source, clear it
            if (quickPaste.source && quickPaste.scope !== scope) {
                quickPaste.source = null;
                showToast(`Scope â†’ ${scope.charAt(0).toUpperCase() + scope.slice(1)} (source cleared)`, 'info');
            }
            
            quickPaste.scope = scope;
            renderOverview();
        }
        
        function setQuickPasteChMult(value) {
            quickPaste.chMultiplier = parseInt(value, 10);
        }
        
        function setQuickPasteCCMult(value) {
            quickPaste.ccMultiplier = parseInt(value, 10);
        }
        
        function clearQuickPasteSource() {
            quickPaste.source = null;
            quickPaste.pasteCount = 0;
            renderOverview();
        }
        
        
        function updateOverviewTableCursor() {
            const tables = document.querySelectorAll('.overview-table');
            tables.forEach(table => {
                table.classList.remove('qp-copy-mode', 'qp-paste-mode');
                if (quickPaste.mode === 'copy') {
                    table.classList.add('qp-copy-mode');
                } else if (quickPaste.mode === 'paste') {
                    table.classList.add('qp-paste-mode');
                }
            });
        }
        
        // Perform Quick Copy based on scope
        function performQuickCopy(controlType, group, index) {
            const scope = quickPaste.scope;
            const colCount = controlType === 'fader9' ? 1 : 8;
            
            let data;
            let count;
            
            if (scope === 'cell') {
                data = { ...getControlData(controlType, currentSetup, group, index) };
                count = 1;
            } else if (scope === 'column') {
                data = [];
                for (let i = 0; i < colCount; i++) {
                    data.push({ ...getControlData(controlType, currentSetup, group, i) });
                }
                count = colCount;
            } else if (scope === 'row') {
                data = [];
                for (let g = 0; g < 8; g++) {
                    data.push({ ...getControlData(controlType, currentSetup, g, index) });
                }
                count = 8;
            }
            
            quickPaste.source = {
                controlType,
                group,
                index,
                data,
                lockedScope: scope,
                count
            };
            
            quickPaste.pasteCount = 0;
            
            // Auto-switch to paste mode
            quickPaste.mode = 'paste';
            
            const scopeNames = { cell: 'Cell', column: 'Column', row: 'Row' };
            showToast(`Copied ${scopeNames[scope]} - ready to paste`, 'success');
            
            renderOverview();
        }
        
        // Perform Quick Paste based on locked scope
        function performQuickPaste(controlType, group, index) {
            if (!quickPaste.source) {
                showToast('No source to paste', 'warning');
                return;
            }
            
            // Same-type enforcement
            if (controlType !== quickPaste.source.controlType) {
                showToast(`Can't paste ${quickPaste.source.controlType} to ${controlType}`, 'error');
                return;
            }
            
            const scope = quickPaste.source.lockedScope;
            const colCount = controlType === 'fader9' ? 1 : 8;
            
            // Calculate offset based on group difference * multiplier
            const sourceGroup = quickPaste.source.group;
            const groupDiff = group - sourceGroup;
            
            const options = {
                channelOffset: groupDiff * quickPaste.chMultiplier,
                numberOffset: groupDiff * quickPaste.ccMultiplier,
                wrapMode: 'clamp'
            };
            
            // Record undo based on scope
            if (scope === 'cell') {
                // Single cell paste
                const before = getControlData(controlType, currentSetup, group, index);
                const newData = transformControlData(quickPaste.source.data, options);
                setControlData(controlType, currentSetup, group, index, newData);
                
                recordUndo({
                    type: 'control',
                    description: `Quick Paste to ${formatControlName(controlType, group, index)}`,
                    controlType,
                    setupIdx: currentSetup,
                    group,
                    index,
                    before,
                    after: newData
                });
                
                flashCell(controlType, group, index);
                
            } else if (scope === 'column') {
                // Column paste to target group
                const batch = { 
                    type: 'batch', 
                    description: `Quick Paste Column to G${group + 1}`, 
                    actions: [] 
                };
                
                for (let i = 0; i < colCount; i++) {
                    const before = getControlData(controlType, currentSetup, group, i);
                    const sourceData = quickPaste.source.data[i] || quickPaste.source.data[0];
                    const newData = transformControlData(sourceData, options);
                    setControlData(controlType, currentSetup, group, i, newData);
                    
                    batch.actions.push({
                        type: 'control',
                        controlType,
                        setupIdx: currentSetup,
                        group,
                        index: i,
                        before,
                        after: newData
                    });
                    
                    flashCell(controlType, group, i);
                }
                
                recordUndo(batch);
                
            } else if (scope === 'row') {
                // Row paste to all groups at target index
                // For row paste, offset is based on row difference (index), not group
                const sourceIndex = quickPaste.source.index;
                const rowDiff = index - sourceIndex;
                
                const rowOptions = {
                    channelOffset: rowDiff * quickPaste.chMultiplier,
                    numberOffset: rowDiff * quickPaste.ccMultiplier,
                    wrapMode: 'clamp'
                };
                
                const batch = { 
                    type: 'batch', 
                    description: `Quick Paste Row ${index + 1}`, 
                    actions: [] 
                };
                
                for (let g = 0; g < 8; g++) {
                    const before = getControlData(controlType, currentSetup, g, index);
                    const sourceData = quickPaste.source.data[g] || quickPaste.source.data[0];
                    const newData = transformControlData(sourceData, rowOptions);
                    setControlData(controlType, currentSetup, g, index, newData);
                    
                    batch.actions.push({
                        type: 'control',
                        controlType,
                        setupIdx: currentSetup,
                        group: g,
                        index,
                        before,
                        after: newData
                    });
                    
                    flashCell(controlType, g, index);
                }
                
                recordUndo(batch);
            }
            
            quickPaste.pasteCount++;
            
            markModified();
            scheduleConflictRebuild();
            renderOverview();
        }
        
        // Flash cell to indicate paste
        function flashCell(controlType, group, index) {
            const cell = getOverviewCell(controlType, group, index);
            if (cell) {
                cell.classList.add('just-pasted');
                setTimeout(() => cell.classList.remove('just-pasted'), 400);
            }
        }
        
        // Handle Quick Paste cell click
        function handleQuickPasteCellClick(controlType, group, index) {
            if (quickPaste.mode === 'copy') {
                performQuickCopy(controlType, group, index);
                return true;
            }
            
            if (quickPaste.mode === 'paste') {
                performQuickPaste(controlType, group, index);
                return true;
            }
            
            return false;
        }
        
        // Handle Quick Paste double-click (blocked in paste mode)
        function handleQuickPasteDoubleClick(controlType, group, index) {
            if (quickPaste.mode === 'paste') {
                if (!quickPaste.doubleClickToastShown) {
                    showToast('Double-click disabled in Paste mode', 'info');
                    quickPaste.doubleClickToastShown = true;
                }
                return true; // Block the action
            }
            
            if (quickPaste.mode === 'copy') {
                // Treat as single click
                performQuickCopy(controlType, group, index);
                return true;
            }
            
            return false;
        }
        
        // Hover highlighting for Quick Paste (column/row preview)
        let lastHoverKey = null;
        
        function handleOverviewMouseEnter(controlType, group, index) {
            // Only show hover highlight in paste mode with a source
            if (quickPaste.mode !== 'paste' || !quickPaste.source) return;
            
            // Only highlight compatible types
            if (controlType !== quickPaste.source.controlType) return;
            
            const scope = quickPaste.source.lockedScope;
            const key = `${controlType}-${group}-${index}-${scope}`;
            
            // Skip if same cell (avoid redundant DOM updates)
            if (key === lastHoverKey) return;
            lastHoverKey = key;
            
            clearHoverHighlight();
            
            const colCount = (controlType === 'fader9') ? 1 : 8;
            
            if (scope === 'column') {
                // Highlight all cells in this group's column
                for (let i = 0; i < colCount; i++) {
                    const cell = getOverviewCell(controlType, group, i);
                    if (cell) cell.classList.add('qp-column-hover');
                }
            } else if (scope === 'row') {
                // Highlight all cells across groups at this index
                for (let g = 0; g < 8; g++) {
                    const cell = getOverviewCell(controlType, g, index);
                    if (cell) cell.classList.add('qp-row-hover');
                }
            } else if (scope === 'cell') {
                // Highlight single target cell
                const cell = getOverviewCell(controlType, group, index);
                if (cell) cell.classList.add('qp-cell-hover');
            }
            // Cell scope uses default CSS hover, no extra highlighting needed
        }
        
        function handleOverviewMouseLeave(controlType, group, index) {
            // Clear highlight when leaving cells
            if (quickPaste.mode !== 'paste') return;
            
            // Small delay to prevent flicker when moving between cells
            setTimeout(() => {
                // Only clear if we haven't entered a new cell
                const currentKey = lastHoverKey;
                if (currentKey && currentKey.startsWith(`${controlType}-${group}-${index}-`)) {
                    // Still on same logical cell, might be between sub-elements
                }
            }, 10);
        }
        
        function clearHoverHighlight() {
            const highlighted = document.querySelectorAll('.qp-column-hover, .qp-row-hover, .qp-cell-hover');
            highlighted.forEach(cell => {
                cell.classList.remove('qp-column-hover', 'qp-row-hover', 'qp-cell-hover');
            });
        }
        
        // ============================================================
        // Tooltip System
        // ============================================================
        
        const tooltipState = {
            showTimer: null,
            hideTimer: null,
            fadeTimer: null,
            autoDismissTimer: null,
            currentLabel: null,
            hoverLabel: null,
            isTouch: false,
            touchDismissOverlay: null
        };
        
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = tooltip.querySelector('.tooltip-content');
        const tooltipArrow = tooltip.querySelector('.tooltip-arrow');
        
        // Detect touch device
        tooltipState.isTouch = ('ontouchstart' in window) || (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
        
        function getTooltipText(key) {
            return TOOLTIPS.labels[key] || null;
        }
        
        function showTooltip(labelEl, key, immediate = false) {
            const text = getTooltipText(key);
            if (!text) return;
            
            // Close any open info panel
            hideInfoPanel();
            
            // Clear any pending operations
            clearTooltipTimers();
            
            tooltipState.currentLabel = labelEl;
            
            const doShow = () => {
                // Set content first (for ARIA)
                tooltipContent.textContent = text;
                
                // Position tooltip
                positionTooltip(labelEl);
                
                // Set ARIA before showing
                tooltip.setAttribute('aria-hidden', 'false');
                
                // Show tooltip
                tooltip.classList.add('visible');
                
                // Touch auto-dismiss
                if (tooltipState.isTouch) {
                    tooltipState.autoDismissTimer = setTimeout(() => {
                        hideTooltip();
                    }, 5000);
                }
            };
            
            if (immediate) {
                doShow();
            } else {
                tooltipState.showTimer = setTimeout(doShow, 400);
            }
        }
        
        function hideTooltip(immediate = false) {
            clearTooltipTimers();
            
            const doHide = () => {
                // Remove visible class immediately
                tooltip.classList.remove('visible');
                
                // Wait for fade then set aria-hidden
                const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                const fadeTime = prefersReducedMotion ? 0 : 120;
                
                tooltipState.fadeTimer = setTimeout(() => {
                    tooltip.setAttribute('aria-hidden', 'true');
                    tooltipState.currentLabel = null;
                }, fadeTime);
            };
            
            if (immediate) {
                tooltip.classList.remove('visible');
                tooltip.setAttribute('aria-hidden', 'true');
                tooltipState.currentLabel = null;
                removeTouchDismissOverlay();
            } else {
                tooltipState.hideTimer = setTimeout(doHide, 100);
            }
        }
        
        function clearTooltipTimers() {
            if (tooltipState.showTimer) {
                clearTimeout(tooltipState.showTimer);
                tooltipState.showTimer = null;
            }
            if (tooltipState.hideTimer) {
                clearTimeout(tooltipState.hideTimer);
                tooltipState.hideTimer = null;
            }
            if (tooltipState.fadeTimer) {
                clearTimeout(tooltipState.fadeTimer);
                tooltipState.fadeTimer = null;
            }
            if (tooltipState.autoDismissTimer) {
                clearTimeout(tooltipState.autoDismissTimer);
                tooltipState.autoDismissTimer = null;
            }
        }
        
        function positionTooltip(labelEl) {
            const rect = labelEl.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const gap = 8;
            const padding = 16;
            
            // Measure tooltip
            tooltip.style.left = '0px';
            tooltip.style.top = '0px';
            tooltip.classList.remove('above', 'below');
            tooltip.classList.add('above'); // Default
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Calculate initial position (above, left-aligned)
            let left = rect.left;
            let top = rect.top - tooltipHeight - gap;
            let placement = 'above';
            
            // Check if fits above
            if (top < padding) {
                // Flip below
                top = rect.bottom + gap;
                placement = 'below';
            }
            
            // Right overflow
            if (left + tooltipWidth > viewportWidth - padding) {
                left = viewportWidth - padding - tooltipWidth;
            }
            
            // Left overflow
            if (left < padding) {
                left = padding;
            }
            
            // Apply position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.remove('above', 'below');
            tooltip.classList.add(placement);
            
            // Position arrow
            const triggerCenterX = rect.left + (rect.width / 2);
            let arrowX = triggerCenterX - left;
            
            // Clamp arrow to tooltip content (post-layout width)
            const contentWidth = tooltipContent.offsetWidth;
            const minArrowX = 16;
            const maxArrowX = contentWidth - 16;
            arrowX = Math.max(minArrowX, Math.min(arrowX, maxArrowX));
            
            tooltipArrow.style.left = (arrowX - 6) + 'px'; // Offset by half arrow width
        }
        
        // Mouse event handlers for labels
        function handleLabelMouseEnter(e) {
            if (tooltipState.isTouch) return;
            
            const label = e.target.closest('.has-tooltip');
            if (!label) return;
            
            const key = label.dataset.tooltipKey;
            if (!key) return;
            
            tooltipState.hoverLabel = label;
            
            // Cancel any pending hide
            if (tooltipState.hideTimer) {
                clearTimeout(tooltipState.hideTimer);
                tooltipState.hideTimer = null;
            }
            
            // If already showing this label, no action needed
            if (tooltipState.currentLabel === label && tooltip.classList.contains('visible')) {
                return;
            }
            
            showTooltip(label, key);
        }
        
        function handleLabelMouseLeave(e) {
            if (tooltipState.isTouch) return;
            
            const label = e.target.closest('.has-tooltip');
            if (!label) return;
            
            tooltipState.hoverLabel = null;
            hideTooltip();
        }
        
        // Touch handlers
        function handleLabelTouch(e) {
            if (!tooltipState.isTouch) return;
            
            const label = e.target.closest('.has-tooltip');
            if (!label) return;
            
            e.preventDefault();
            
            const key = label.dataset.tooltipKey;
            if (!key) return;
            
            // Toggle behavior
            if (tooltipState.currentLabel === label && tooltip.classList.contains('visible')) {
                hideTooltip(true);
                removeTouchDismissOverlay();
            } else {
                showTooltip(label, key, true);
                createTouchDismissOverlay();
            }
        }
        
        function createTouchDismissOverlay() {
            removeTouchDismissOverlay();
            
            const overlay = document.createElement('div');
            overlay.className = 'touch-dismiss-overlay';
            overlay.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                hideTooltip(true);
                removeTouchDismissOverlay();
            }, { passive: false });
            
            document.body.appendChild(overlay);
            tooltipState.touchDismissOverlay = overlay;
        }
        
        function removeTouchDismissOverlay() {
            if (tooltipState.touchDismissOverlay) {
                tooltipState.touchDismissOverlay.remove();
                tooltipState.touchDismissOverlay = null;
            }
        }
        
        // Scroll handler
        function handleScroll() {
            if (tooltip.classList.contains('visible')) {
                hideTooltip(true);
                removeTouchDismissOverlay();
            }
        }
        
        // ============================================================
        // Info Panel System
        // ============================================================
        
        const infoPanelState = {
            currentGroup: null,
            currentSelect: null,
            focusedIndex: 0
        };
        
        const infoPanel = document.getElementById('infoPanel');
        const infoPanelTitle = infoPanel.querySelector('.info-panel-title');
        const infoPanelContent = infoPanel.querySelector('.info-panel-content');
        const infoPanelClose = infoPanel.querySelector('.info-panel-close');
        
        function showInfoPanel(element) {
            const group = element.dataset.infoGroup;
            if (!group) return;
            
            // Find associated select in the same param-row
            const paramRow = element.closest('.param-row');
            const select = paramRow?.querySelector('select[data-option-group]');
            if (!select) return;
            
            // Close any tooltip
            hideTooltip(true);
            
            // Close any existing panel (single-panel rule)
            if (infoPanelState.currentGroup && infoPanelState.currentGroup !== group) {
                hideInfoPanel();
            }
            
            infoPanelState.currentGroup = group;
            infoPanelState.currentSelect = select;
            
            // Set title
            infoPanelTitle.textContent = OPTION_GROUP_TITLES[group] || 'Options';
            
            // Build options list from select
            buildInfoPanelOptions(select, group);
            
            // Position panel
            positionInfoPanel(element);
            
            // Show panel
            infoPanel.style.display = 'flex';
            
            // Focus panel for keyboard navigation
            infoPanel.focus();
        }
        
        function buildInfoPanelOptions(select, group) {
            infoPanelContent.innerHTML = '';
            
            const options = Array.from(select.options);
            const currentValue = select.value;
            
            options.forEach((opt, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'info-panel-option';
                optionEl.dataset.value = opt.value;
                optionEl.dataset.index = index;
                
                // Determine tooltip key based on group type
                let tooltipKey;
                const optText = opt.textContent.trim();
                
                // Map option text to tooltip key
                if (group === 'acc') {
                    tooltipKey = `acc.${index}`;
                } else if (group === 'display') {
                    tooltipKey = `display.${optText}`;
                } else if (group === 'faderMode') {
                    tooltipKey = `faderMode.${optText}`;
                } else if (group === 'buttonMode') {
                    tooltipKey = `buttonMode.${optText}`;
                } else {
                    tooltipKey = `${group}.${optText}`;
                }
                
                const description = TOOLTIPS.options[tooltipKey] || '';
                
                const isSelected = opt.value === currentValue;
                if (isSelected) {
                    infoPanelState.focusedIndex = index;
                    optionEl.classList.add('focused');
                }
                
                optionEl.innerHTML = `
                    <span class="info-panel-marker">${isSelected ? 'â–º' : ''}</span>
                    <div class="info-panel-option-content">
                        <div class="info-panel-option-name">${optText}</div>
                        <div class="info-panel-option-desc">${description}</div>
                    </div>
                `;
                
                optionEl.addEventListener('click', () => handleInfoPanelOptionClick(opt.value));
                
                infoPanelContent.appendChild(optionEl);
            });
        }
        
        function handleInfoPanelOptionClick(value) {
            if (!infoPanelState.currentSelect) return;
            
            const currentValue = infoPanelState.currentSelect.value;
            if (value === currentValue) return; // No-op if already selected
            
            // Update select value programmatically
            infoPanelState.currentSelect.value = value;
            
            // Trigger change event
            const event = new Event('change', { bubbles: true });
            infoPanelState.currentSelect.dispatchEvent(event);
            
            // Update markers in panel
            updateInfoPanelMarkers();
        }
        
        function updateInfoPanelMarkers() {
            if (!infoPanelState.currentSelect) return;
            
            const currentValue = infoPanelState.currentSelect.value;
            const options = infoPanelContent.querySelectorAll('.info-panel-option');
            
            options.forEach((opt, index) => {
                const marker = opt.querySelector('.info-panel-marker');
                const isSelected = opt.dataset.value === currentValue;
                marker.textContent = isSelected ? 'â–º' : '';
                
                if (isSelected) {
                    infoPanelState.focusedIndex = index;
                }
            });
        }
        
        function positionInfoPanel(button) {
            const rect = button.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const gap = 8;
            const padding = 16;
            
            // Reset position for measurement
            infoPanel.style.left = '0px';
            infoPanel.style.top = '0px';
            infoPanel.style.display = 'flex';
            
            const panelRect = infoPanel.getBoundingClientRect();
            const panelWidth = panelRect.width;
            const panelHeight = Math.min(panelRect.height, viewportHeight - 2 * padding);
            
            // Position to the right of the button
            let left = rect.right + gap;
            let top = rect.top;
            
            // Right overflow - position to the left instead
            if (left + panelWidth > viewportWidth - padding) {
                left = rect.left - panelWidth - gap;
            }
            
            // Left overflow
            if (left < padding) {
                left = padding;
            }
            
            // Bottom overflow
            if (top + panelHeight > viewportHeight - padding) {
                top = viewportHeight - padding - panelHeight;
            }
            
            // Top overflow
            if (top < padding) {
                top = padding;
            }
            
            infoPanel.style.left = left + 'px';
            infoPanel.style.top = top + 'px';
            infoPanel.style.maxHeight = (viewportHeight - 2 * padding) + 'px';
        }
        
        function hideInfoPanel() {
            infoPanel.style.display = 'none';
            infoPanelState.currentGroup = null;
            infoPanelState.currentSelect = null;
            infoPanelState.focusedIndex = 0;
        }
        
        function handleInfoPanelKeyDown(e) {
            if (infoPanel.style.display === 'none') return;
            
            const options = infoPanelContent.querySelectorAll('.info-panel-option');
            const numOptions = options.length;
            
            switch (e.key) {
                case 'Escape':
                    e.preventDefault();
                    hideInfoPanel();
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    e.stopPropagation();
                    infoPanelState.focusedIndex = (infoPanelState.focusedIndex + 1) % numOptions;
                    updateInfoPanelFocus();
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    e.stopPropagation();
                    infoPanelState.focusedIndex = (infoPanelState.focusedIndex - 1 + numOptions) % numOptions;
                    updateInfoPanelFocus();
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    const focusedOption = options[infoPanelState.focusedIndex];
                    if (focusedOption) {
                        handleInfoPanelOptionClick(focusedOption.dataset.value);
                    }
                    break;
            }
        }
        
        function updateInfoPanelFocus() {
            const options = infoPanelContent.querySelectorAll('.info-panel-option');
            options.forEach((opt, index) => {
                opt.classList.toggle('focused', index === infoPanelState.focusedIndex);
            });
            
            // Scroll focused option into view
            options[infoPanelState.focusedIndex]?.scrollIntoView({ block: 'nearest' });
        }
        
        // Watch for external select changes (sync marker)
        function watchSelectChanges() {
            document.addEventListener('change', (e) => {
                if (e.target === infoPanelState.currentSelect) {
                    updateInfoPanelMarkers();
                }
            });
        }
        
        // Initialize tooltip system
        function initTooltipSystem() {
            // Event delegation for mouse events on labels
            document.addEventListener('mouseenter', (e) => {
                if (e.target.classList?.contains('has-tooltip')) {
                    handleLabelMouseEnter(e);
                }
            }, true);
            
            document.addEventListener('mouseleave', (e) => {
                if (e.target.classList?.contains('has-tooltip')) {
                    handleLabelMouseLeave(e);
                }
            }, true);
            
            // Touch events on labels
            if (tooltipState.isTouch) {
                document.addEventListener('touchstart', (e) => {
                    if (e.target.classList?.contains('has-tooltip')) {
                        handleLabelTouch(e);
                    }
                }, { passive: false });
            }
            
            // Scroll dismiss
            window.addEventListener('scroll', handleScroll, true);
            
            // Click outside to dismiss (desktop) - safety net
            document.addEventListener('mousedown', (e) => {
                // Close info panel on click outside
                if (infoPanel.style.display !== 'none') {
                    if (!infoPanel.contains(e.target) && !e.target.closest('.has-options')) {
                        hideInfoPanel();
                    }
                }
            });
            
            // Options label clicks (opens info panel)
            document.addEventListener('click', (e) => {
                const optionsLabel = e.target.closest('.has-options');
                if (optionsLabel) {
                    e.preventDefault();
                    e.stopPropagation();
                    showInfoPanel(optionsLabel);
                }
            });
            
            // Info panel close button
            infoPanelClose.addEventListener('click', hideInfoPanel);
            
            // Info panel keyboard navigation
            document.addEventListener('keydown', handleInfoPanelKeyDown);
            
            // Watch for select changes
            watchSelectChanges();
        }
        
        // ============================================================
        // Keyboard Shortcuts
        // ============================================================
        
        document.addEventListener('keydown', (e) => {
            // Check if we're in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
            
            if (ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if (ctrlKey && e.key === 'z' && e.shiftKey) {
                e.preventDefault();
                redo();
            } else if (ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (ctrlKey && e.key === 'c' && !e.shiftKey && !e.altKey) {
                e.preventDefault();
                handleCopy();
            } else if (ctrlKey && e.key === 'v' && !e.shiftKey) {
                e.preventDefault();
                handlePaste();
            } else if (e.key === 'Escape') {
                // Quick Paste priority escape handling
                if (contextMenu) {
                    hideContextMenu();
                } else if (quickPaste.mode !== 'off') {
                    // Exit Quick Paste mode
                    setQuickPasteMode('off');
                    showToast('Quick Paste off', 'info');
                } else {
                    clearSelection();
                }
            } else if (e.key === 'q' || e.key === 'Q') {
                // Cycle Quick Paste modes: off -> copy -> paste -> off
                if (currentView === 'overview') {
                    e.preventDefault();
                    const modes = ['off', 'copy', 'paste'];
                    const currentIdx = modes.indexOf(quickPaste.mode);
                    const nextIdx = (currentIdx + 1) % modes.length;
                    setQuickPasteMode(modes[nextIdx]);
                }
            } else if ((e.key === '1' || e.key === '2' || e.key === '3') && !ctrlKey && !e.altKey) {
                // Quick Paste scope shortcuts (when in QP mode)
                if (currentView === 'overview' && quickPaste.mode !== 'off') {
                    e.preventDefault();
                    const scopes = { '1': 'cell', '2': 'column', '3': 'row' };
                    setQuickPasteScope(scopes[e.key]);
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveSelection('left');
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveSelection('right');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                moveSelection('up');
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                moveSelection('down');
            } else if (e.key === 'Enter') {
                e.preventDefault();
                handleEnterKey();
            } else if (e.key === 'Tab' && currentView === 'overview') {
                e.preventDefault();
                // Tab moves right, Shift+Tab moves left
                moveSelection(e.shiftKey ? 'left' : 'right');
            }
        });
        
        // ============================================================
        // Init
        // ============================================================
        
        async function loadDefaultSysEx() {
            try {
                updateStatus('', 'Loading factory_default.syx...');
                const response = await fetch('factory_default.syx');
                if (!response.ok) {
                    console.log('No factory_default.syx found, waiting for manual import');
                    updateStatus('', 'No data loaded');
                    return;
                }
                
                const buffer = await response.arrayBuffer();
                rawBuffer = new Uint8Array(buffer);
                
                if (rawBuffer.length !== EXPECTED_SIZE) {
                    console.error(`Invalid file size: ${rawBuffer.length} bytes. Expected ${EXPECTED_SIZE} bytes.`);
                    rawBuffer = null;
                    updateStatus('', 'No data loaded');
                    return;
                }
                
                if (rawBuffer[0] !== 0xF0 || rawBuffer[rawBuffer.length - 1] !== 0xF7) {
                    console.error('Invalid SysEx file: Missing F0/F7 framing bytes.');
                    rawBuffer = null;
                    updateStatus('', 'No data loaded');
                    return;
                }
                
                sectionIndex = buildIndex(rawBuffer);
                
                // Enable UI
                document.getElementById('setupSelect').disabled = false;
                document.getElementById('setupSelect').value = '0';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('exportJsonBtn').disabled = false;
                
                currentSetup = 0;
                encoderGroup = 0;
                faderGroup = 0;
                isModified = false;
                dirtyBanks.clear();
                
                // Clear undo/redo stacks on fresh load
                undoStack.length = 0;
                redoStack.length = 0;
                updateUndoRedoUI();
                
                updateGroupTabs('encoderGroupTabs', 0);
                updateGroupTabs('faderGroupTabs', 0);
                updateGroupNames();
                updateStatus('loaded', 'Loaded: factory_default.syx');
                document.getElementById('fileInfo').textContent = `factory_default.syx (${rawBuffer.length.toLocaleString()} bytes)`;
                
                // Build initial conflict map
                rebuildConflictMap();
                
                renderFocusedView();
            } catch (err) {
                console.log('Could not auto-load factory_default.syx:', err.message);
                updateStatus('', 'No data loaded');
            }
        }
        
        async function initializeEditor() {
            // Check if user previously said "don't ask again"
            if (sessionStorage.getItem('uc4-skip-restore') === 'true') {
                clearSession();
                dirtyBanks.clear();
                await loadDefaultSysEx();
                return;
            }
            
            // Check for saved session with actual unsaved changes
            const savedSession = loadSession();
            
            // Only prompt if there are dirty banks (actual unsaved edits)
            if (savedSession && savedSession.dirtyBanks && savedSession.dirtyBanks.length > 0) {
                const timeSince = formatTimeSince(savedSession.timestamp);
                
                // Show restore prompt
                const result = await showRestoreDialog(timeSince, savedSession);
                
                if (result === 'restore') {
                    restoreSession(savedSession);
                    return;
                } else if (result === 'discard-permanently') {
                    clearSession();
                    dirtyBanks.clear();
                    // Don't prompt again this browser session
                    sessionStorage.setItem('uc4-skip-restore', 'true');
                } else {
                    clearSession();
                    dirtyBanks.clear();
                }
            } else if (savedSession) {
                // Session exists but no dirty banks = clean baseline, just clear it
                clearSession();
            }
            
            // Load factory defaults
            await loadDefaultSysEx();
        }
        
        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            // Check if there are unsaved changes
            if (isModified || dirtyBanks.size > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        
        initUI();
        initTooltipSystem();
        initializeEditor();
    </script>
</body>
</html>

